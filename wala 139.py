import logging

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.DEBUG
)
logger = logging.getLogger(__name__)
import asyncio
import signal
import re
import psycopg2
from psycopg2 import sql
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove, InputMediaPhoto, Update
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ConversationHandler, filters, CallbackContext
import os
import requests
import logging
from datetime import datetime, timedelta
from close_jobs_scheduler import start_scheduler  # Import the start_scheduler function
from job_alerts_script_high import main_loop


# States for the conversation
(SELECT_SECTION, JOB_TITLE, JOB_DESCRIPTION, JOB_SITE, JOB_TYPE, JOB_SECTOR, EDUCATION_QUALIFICATION,
EXPERIENCE_LEVEL, LOCATION_COUNTRY,LOCATION_CITY, COMPENSATION_TYPE, SALARY_COMPENSATION, VACANCY_NUMBER, CURRENCY_TYPE, APPLICANT_GENDER, JOB_APPLICATION_DEADLINE,
CONFIRM_JOB_POST, EDIT_SECTION, USER_REGISTRATION, USER_TYPE, FIRST_NAME, LAST_NAME, GENDER, COUNTRY, CITY, EMAIL, DOB, CONTACT, PROFILE_CONFIRMATION,
EDIT_PROFILE, EDIT_FIRST_NAME, EDIT_LAST_NAME, EDIT_GENDER, EDIT_COUNTRY, EDIT_USER_TYPE, EDIT_CITY, EDIT_DOB, EDIT_EMAIL, EMPLOYER_MENU, JOB_MANAGEMENT, APPLICATIONS, SEARCH_FILTER, PROFILE_MANAGEMENT, BILLING_PAYMENTS, NOTIFICATIONS, SETTINGS, SUPPORT,
APPLICANT_MAIN_MENU, SEARCH_JOBS, MY_PROFILE_MENU, APPLICATIONS_MENU, JOB_ALERTS_MENU, MESSAGES_MENU,
SKILL_ASSESSMENTS_MENU, SETTINGS_MENU, HELP_SUPPORT_MENU, JOB_SEARCH_MENU,
SEARCH_JOBS_BY_LOCATION, SEARCH_JOBS_BY_INDUSTRY, FILTER_JOBS_BY_TYPE,
UPLOAD_RESUME, UPLOAD_CERTIFICATION, UPLOAD_PORTFOLIO, MANAGE_CERTIFICATIONS,
POST_JOB_MENU, MANAGE_JOBS_MENU, VIEW_APPLICANTS_MENU, SEARCH_CANDIDATES_MENU,
SHORTLISTED_CANDIDATES_MENU, COMPANY_PROFILE_MENU, NOTIFICATIONS_MENU, JOB_ANALYTICS_MENU,
NEW_JOB, JOB_TEMPLATES, JOB_GUIDELINES, ACTIVE_JOBS, EXPIRED_JOBS, DRAFT_JOBS,
PENDING_APPROVAL_JOBS, CLOSED_JOBS, REPOST_JOBS, VIEW_BY_JOB_POSTS, APPLICANT_DETAILS,
APPLICATION_STATUS, SCHEDULE_INTERVIEW, FILTER_BY_SKILLS, FILTER_BY_EXPERIENCE, FILTER_BY_LOCATION,
VIEW_CANDIDATE_PROFILES, REVIEW_SHORTLISTED_APPLICANTS, MESSAGE_CANDIDATES,
SCHEDULE_SHORTLISTED_INTERVIEWS, EDIT_COMPANY_DETAILS, UPDATE_LOGO, COMPANY_DESCRIPTION,
COMPANY_CONTACT_INFORMATION_MENU, JOB_POST_STATUS_UPDATES, NEW_APPLICANT_NOTIFICATIONS,
INTERVIEW_SCHEDULE_NOTIFICATIONS, JOB_VIEWS, NUMBER_OF_APPLICANTS, APPLICATION_CONVERSION_RATE,
AVERAGE_TIME_TO_HIRE,APPROVE_REJECT_JOB_POSTS, EDIT_JOB_POSTS, VIEW_FLAGGED_JOB_POSTS, MANAGE_EMPLOYERS, MANAGE_JOB_SEEKERS,
BAN_UNBAN_USERS, VIEW_REGISTERED_USERS, MANAGE_COMMENTS, FLAGGED_CONTENT_REVIEW, JOB_CATEGORIES,
LOCATION_MANAGEMENT, NOTIFICATION_SETTINGS, USER_ACTIVITY_REPORTS, JOB_POST_INSIGHTS, APPLICANT_INSIGHTS,
REVENUE_REPORTS, MANAGE_PAYMENT_OPTIONS, VIEW_TRANSACTIONS, REFUND_MANAGEMENT, VIEW_USER_REPORTS,
RESOLVE_ISSUES,ADMIN_MENU, JOB_POST_MANAGEMENT, USER_MANAGEMENT, CONTENT_MODERATION,
PLATFORM_SETTINGS, ANALYTICS_REPORTS, MONETIZATION, SUPPORT_ISSUE_RESOLUTION, APPLY_JOB, FORWARD_TO_EMPLOYER, PROFILE_EDIT_MENU, COMPANY_NAME, COMPANY_EMAIL, COMPANY_PHONE, COMPANY_WEBSITE,
    INDUSTRY, COMPANY_SIZE, COMPANY_COUNTRY , COMPANY_CITY , COMPANY_ADDRESS,EMPLOYER_NAME, EMPLOYER_POSITION, EMPLOYER_CONTACT,
    COMPANY_LOGO, COMPANY_DESCRIPTION, SOCIAL_MEDIA_LINKS, COMPANY_VIDEO_URL,
    COMPANY_FOUNDING_YEAR, COMPANY_CEO_NAME, OPEN_POSITIONS, COMPANY_CERTIFICATIONS,
    EMPLOYEE_BENEFITS, AVERAGE_SALARY_RANGE, CONTACT_INFORMATION_MENU, PROFILE_CONTACT_MENU, VIEW_PROFILE,
APPLICANT_FULL_NAME, APPLICANT_JOB_TITLE, APPLICANT_LOCATION, APPLICANT_PHONE, APPLICANT_EMAIL,
 APPLICANT_OVERVIEW, APPLICANT_SKILLS, APPLICANT_EMPLOYMENT_TYPE, APPLICANT_AVAILABILITY, ENTER_SPECIFIC_DATE,
 APPLICANT_WORK_EXPERIENCE, APPLICANT_EDUCATION, APPLICANT_CERTIFICATIONS,
 APPLICANT_LANGUAGES, APPLICANT_PORTFOLIO, APPLICANT_RESUME, APPLICANT_PROFILE_EDIT_MENU, APPLICANT_HIGHEST_DEGREE, APPLICANT_UNIVERSITY, APPLICANT_GRADUATION_YEAR, APPLICANT_LANGUAGES, APPLICANT_COLLEGE, APPLICANT_GPA, SET_JOB_ALERTS,
SELECT_JOB_TYPE, SET_ALERT_CRITERION_INPUT, APPLY_CONVERSATION, CONFIRM_APPLICATION, COLLECT_INFO, SUBMIT_APPLICATION, APPLICATION_COMPLETE, UPLOAD_CV, COLLECT_APPLICATION_MESSAGE,COLLECT_PORTFOLIO_LINKS, REVIEW_APPLICATION,
VIEW_APPLICANTS, VIEW_APPLICANTS_STATE, SUBMISSION_MENU, APPLICANT_PROFILE_PICTURE, APPLICANT_PORTFOLIO_LINK, APPLICANT_PORTFOLIO_LINK_1, APPLICANT_PORTFOLIO_LINK_2, APPLICANT_PORTFOLIO_LINK_3, APPLICANT_PORTFOLIO_LINK_4, APPLICANT_PORTFOLIO_EDIT, APPLICANT_PORTFOLIO_EDIT_LINK, VIEW_SHORTLISTED_STATE,
CONTACT_APPLICANTS, CONTACT_APPLICANTS_STATE, EDIT_DRAFT_STATE, SUBMIT_DRAFT_STATE, DELETE_DRAFT_STATE, EDIT_MESSAGE_STATE, EDIT_PORTFOLIO_STATE, EDIT_ATTACHMENTS_STATE, CONFIRMATION, UPLOAD_PAYMENT, PAYMENT_SCREENSHOT, REQUEST_PAYMENT, SEARCH_APPLICANTS_STATE, BROWSE_APPLICANTS_STATE, VIEW_PROFILE_STATE, FILTER_APPLICATIONS_STATE,
FILTER_CRITERIA_STATE, BACK_TO_START_STATE, APPLICATIONS_STATE, MANAGE_JOB_PAYMENTS, SELECT_PREMIUM_PACKAGE, CONFIRM_PREMIUM_PACKAGE, PAYMENT_PROCESSING, BILLING_PAYMENTS_MENU, UPLOAD_PAYMENT_SCREENSHOT, WAITING_FOR_PAYMENT_SCREENSHOT, UPLOAD_PACKAGE_PAYMENT_SCREENSHOT, VIEW_PAYMENT_HISTORY, PAYMENT_STAT_BACK, JOB_APPLICATION_ALERTS_MENU,
POST_EXPIRY_ALERTS_MENU, CHAT_WITH_ADMIN, SUPPORT_MENU, EMPLOYER_MANAGEMENT, SEARCH_USERS, EDIT_SELECTED_JOB, SEARCH_JOB_POSTS, EDIT_JOB_DETAIL, WAITING_FOR_NEW_VALUE, CHAT_WITH_USER, HELP_CENTER, FAQS, SEARCH_USER_ADMIN, SELECT_USER, EDIT_JOB_FIELD, EDIT_JOB_CONFIRM, EDIT_FIELD, EDIT_DRAFT_SECTION, EDIT_DRAFT_TITLE, EDIT_DRAFT_DESCRIPTION, EDIT_DRAFT_SITE,
EDIT_DRAFT_TYPE, EDIT_DRAFT_SECTOR, EDIT_DRAFT_EDUCATION, EDIT_DRAFT_EXPERIENCE, EDIT_DRAFT_COUNTRY, EDIT_DRAFT_CITY, EDIT_DRAFT_COMPENSATION_TYPE, EDIT_DRAFT_SALARY, EDIT_DRAFT_CURRENCY, EDIT_DRAFT_VACANCY, EDIT_DRAFT_GENDER, EDIT_DRAFT_DEADLINE, ADD_PACKAGE, EDIT_PACKAGE, REMOVE_PACKAGE, LIST_PACKAGES, SAVE_PACKAGE, ADD_CATEGORY, REMOVE_CATEGORY, ADD_LOCATION, REMOVE_LOCATION, LIST_CATEGORIES,
LIST_LOCATIONS, JOB_POST_EARNINGS, PACKAGE_EARNINGS, CHAT_WITH_ADMIN_APPLICANT, SEARCH_APPLICANT_ADMIN, VIEW_APPLICANT_REPORTS, SELECT_APPLICANT, CHAT_WITH_APPLICANT,
) = range(288)



ADMIN_ID = '896853541'  # Admin Telegram ID
CHANNEL_ID = '-1002270681847'  # Your Telegram channel ID

import psycopg2  # Ensure you've installed this library with pip install psycopg2

# Step 1: Connect to PostgreSQL database
# Replace with your actual database credentials
conn = psycopg2.connect(
    dbname="my_project_db",
    user="postgres",
    password="1201",
    host="localhost",  # or '127.0.0.1' or the actual host
    port="5432"  # default PostgreSQL port
)

# Create a cursor object to interact with the database
cursor = conn.cursor()


# Step 3: Recreate the 'users' table with new columns
cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        user_id SERIAL PRIMARY KEY,  -- SERIAL for auto-incrementing IDs
        first_name TEXT,
        last_name TEXT,
        gender TEXT,
        user_type TEXT,  -- Can be "applicant" or "employer"
        country TEXT,
        city TEXT,
        dob DATE,  -- Using DATE type for date of birth
        email TEXT,
        contact TEXT UNIQUE NOT NULL,  -- Ensuring unique contacts
        is_registered INTEGER DEFAULT 0  -- 0 means not registered, 1 means registered
    )
''')

# Commit changes for the 'users' table
conn.commit()

# Step 5: Create the 'job_status' table
cursor.execute('''
      CREATE TABLE IF NOT EXISTS job_status (
          status_id SERIAL PRIMARY KEY,
          status_name TEXT NOT NULL UNIQUE
      )
  ''')
conn.commit()

# Step 6: Insert default job statuses into the 'job_status' table
statuses = [
    ('pending',),
    ('approved',),
    ('declined',),
    ('flagged',),
    ('opened',),
    ('closed',),
    ('reposted',)
]

for status in statuses:
    cursor.execute('''
          INSERT INTO job_status (status_name) 
          VALUES (%s) 
          ON CONFLICT (status_name) DO NOTHING
      ''', status)

conn.commit()

# Step 7: Create the 'job_posts' table with a foreign key reference to 'job_status' and 'users'
cursor.execute('''
    CREATE TABLE IF NOT EXISTS job_posts (
        job_id SERIAL PRIMARY KEY,
        job_title TEXT NOT NULL,
        job_description TEXT NOT NULL,
        job_site TEXT,
        job_type TEXT,
        job_sector TEXT,
        education_qualification TEXT,
        experience_level TEXT,
        location_country TEXT,  -- Location of work (Country)
        location_city TEXT,     -- Location of work (City)
        compensation_type TEXT,
        salary_compensation REAL, -- Salary values as REAL (numeric type)
        currency_type TEXT,     -- Currency type (e.g., USD, EUR)
        vacancy_number INTEGER, -- Number of vacancies
        applicant_gender TEXT,
        job_application_deadline DATE, -- Use DATE type for deadlines
        created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,  -- Timestamp with time zone
        user_id INTEGER,  -- Foreign key to 'users' table
        status_id INTEGER DEFAULT 1,  -- Default status is 'pending'
        FOREIGN KEY (status_id) REFERENCES job_status(status_id) ON DELETE CASCADE,  -- Ensure job status integrity
        FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE  -- Ensure user integrity
    )
''')

# Commit the changes for the 'job_posts' and 'job_status' tables
conn.commit()

# Step 8: Close the connection
cursor.close()
conn.close()

print("Tables created and data inserted successfully.")



# Helper function for logging
def log_debug(message):
    print(f"DEBUG: {message}")



async def exit(update: Update, context: CallbackContext) -> int:
    chat_id = update.message.chat_id
    admin_id = 896853541  # Replace this with the actual Telegram ID of the admin

    # Debugging information
    print(f"DEBUG: /exit command received from user: {chat_id}")

    # Check if the user is the admin
    if chat_id == admin_id:
        return await show_admin_menu(update, context)

    # Convert chat_id to string to match the TEXT type in PostgreSQL
    contact = str(chat_id)

    # Fetch user registration info by chat_id (as contact)
    try:
        conn = psycopg2.connect(
            dbname="my_project_db",  # Replace with your actual DB name
            user="postgres",         # Replace with your DB user
            password="1201",         # Replace with your DB password
            host="localhost",        # Replace with your host (if different)
            port="5432"              # Default port for PostgreSQL
        )
        cursor = conn.cursor()

        # Check if the user is registered using the contact (as string)
        cursor.execute('SELECT user_type, is_registered FROM users WHERE contact = %s', (contact,))
        result = cursor.fetchone()
        conn.close()

        if result:
            user_type, is_registered = result
            print(f"DEBUG: User {chat_id} fetched registration info: {result}")

            if is_registered == 1:
                # User is registered, show appropriate menu
                if user_type == "Applicant":
                    return await show_applicant_main_menu(update, context)
                elif user_type == "Employer":
                    return await show_employer_menu(update, context)
            else:
                await update.message.reply_text("You are not registered yet. Please complete registration.")
                return USER_TYPE  # Go back to registration process
        else:
            # If no registration found, ask to register
            print(f"DEBUG: User {chat_id} not found in the database. Asking for registration.")
            await update.message.reply_text(
                "You need to register first. Please use the /start command to begin registration."
            )
            return

    except Exception as e:
        print(f"ERROR: Failed to interact with the database: {e}")
        await update.message.reply_text("An error occurred while accessing the database. Please try again later.")
        return



# Start command
async def start(update, context) -> int:
    contact = str(update.message.chat_id)
    admin_id = 896853541  # Replace with the actual Telegram ID of the admin

    logger.info(f"/start command received from user: {contact}")

    # Check if the user is the admin
    if contact == str(admin_id):
        logger.info("Admin is accessing the bot.")
        return await show_admin_menu(update, context)

    # Handle if the /start command is used with an apply argument (e.g., "/start apply_123")
    if context.args and context.args[0].startswith("apply_"):
        job_id = context.args[0].split("_")[1]
        return await confirm_application(update, context, job_id)

    # Check if the user is in the middle of an application process
    if context.user_data.get('job_id'):
        logger.info("User is in the middle of an application process.")
        await update.message.reply_text(
            "You are currently in the middle of an application process. Would you like to continue or cancel?",
            reply_markup=ReplyKeyboardMarkup([["Continue", "Cancel Application"]], resize_keyboard=True)
        )
        context.user_data['awaiting_confirmation'] = True
        return CONFIRMATION

    # Connect to PostgreSQL database to check user status
    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Check if the user is banned or already registered
        cursor.execute('SELECT user_type, is_registered, status FROM users WHERE contact = %s', (contact,))
        result = cursor.fetchone()

        logger.info(f"User {contact} status check result: {result}")

        if result:
            user_type, is_registered, status = result

            # Handle banned users
            if status == "banned":
                logger.warning(f"User {contact} is banned.")
                await update.message.reply_text(
                    "🚫 Your access to this platform has been restricted due to a violation of our policies.\n\n"
                    "If you believe this is a mistake, please contact support:\n"
                    "📧 support@example.com\n📞 +1 800 123 4567",
                    parse_mode="HTML"
                )
                return

            # Handle registered users
            if is_registered == 1:
                if user_type == "Applicant":
                    logger.info(f"User {contact} is a registered Applicant.")
                    return await show_applicant_main_menu(update, context)
                elif user_type == "Employer":
                    logger.info(f"User {contact} is a registered Employer.")
                    return await show_employer_menu(update, context)

        # If not registered, start the registration process
        return await start_user_registration(update, context)

    except psycopg2.Error as db_error:
        logger.error(f"Database error: {db_error}")
        await update.message.reply_text("An error occurred while checking your status. Please try again later.")
        return

    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        await update.message.reply_text("An unexpected error occurred. Please try again later.")
        return

    finally:
        if 'conn' in locals() and conn:
            cursor.close()
            conn.close()
            logger.info("Database connection closed.")


async def handle_confirmation_resume_cancel(update: Update, context: CallbackContext) -> int:
    """Handle user response to continue or cancel the current application process."""
    message_text = update.message.text.strip().lower()

    if message_text == "continue":
        # User wants to continue the application
        await update.message.reply_text("Resuming your application...")
        # Redirect to the appropriate state or function
        current_state = context.user_data.get('current_state', )
        return current_state

    elif message_text == "cancel application":
        # User chooses to cancel the application
        context.user_data.clear()  # Clear all user data related to the current application
        await update.message.reply_text(
            "Your application process has been canceled. You can restart with /start.",
            reply_markup=ReplyKeyboardRemove()
        )
        return

    # If the response is unexpected, prompt again
    await update.message.reply_text(
        "Sorry, I didn't understand that response. Please choose 'Continue' or 'Cancel Application'.",
        reply_markup=ReplyKeyboardMarkup([["Continue", "Cancel Application"]], resize_keyboard=True)
    )
    return CONFIRMATION


async def cancel(update: Update, context: CallbackContext) -> int:
    """Handle the /cancel command to exit the conversation."""
    context.user_data.clear()  # Clear user-specific data to ensure no residual state remains
    await update.message.reply_text(
        "You have canceled the current operation. You can restart anytime with /start."
    )
    return

from telegram import ReplyKeyboardMarkup



# Registration process
async def start_user_registration(update, context) -> int:
    logger.info("Entered start_user_registration.")
    await update.message.reply_text(
        (
            "👋🏾 <b>Welcome to Afro Joblink!</b>\n\n"
            "We're thrilled to have you onboard. Let's get started by creating your profile. "
            "Please follow the steps below to fill out your details. Once all sections are complete, "
            "click <b>Confirm</b> to finalize your registration.\n\n"
            "💡 <i>Tip:</i> You can update any section as you go along."
        ),
        reply_markup=ReplyKeyboardMarkup(
            [
                ["👔 User Type", "✍🏾 First Name"],
                ["👴🏾 Last Name", "🚻 Gender"],
                ["🎂 Date of Birth (DOB)", "🌍 Country"],
                ["📍 City", "📧 Email"],
                ["📱 Phone Number", "✔️ Confirm"],
            ],
            resize_keyboard=True,
        ),
        parse_mode="HTML",  # Enables HTML formatting
    )
    logger.info("Displayed user registration menu. Returning USER_REGISTRATION state.")
    return USER_REGISTRATION



# Handle profile section selection
async def handle_user_profile_section_selection(update, context) -> int:
    section = update.message.text.strip()
    logger.info(f"User selected section: {section}")

    context.user_data["current_section"] = section  # Track the current section

    # Dynamically handle the selected section
    if section == "👔 User Type":
        await update.message.reply_text(
            "Are you an Applicant or an Employer?",
            reply_markup=ReplyKeyboardMarkup([["Applicant", "Employer"]], resize_keyboard=True)
        )
        return USER_TYPE

    elif section == "✍🏾 First Name":
        await update.message.reply_text(
            "Please enter your First Name (letters only, 2-20 characters):",
            reply_markup=ReplyKeyboardRemove()
        )
        return FIRST_NAME

    elif section == "👴🏾 Last Name":
        await update.message.reply_text(
            "Please enter your Last Name (letters only, 2-20 characters):",
            reply_markup=ReplyKeyboardRemove()
        )
        return LAST_NAME

    elif section == "🚻 Gender":
        await update.message.reply_text(
            "Please select your Gender:",
            reply_markup=ReplyKeyboardMarkup([["Male", "Female"]], resize_keyboard=True)
        )
        return GENDER

    elif section == "🎂 Date of Birth (DOB)":
        await update.message.reply_text(
            "Please enter your Date of Birth in the format 'dd/mm/yyyy' or your age (15-100):",
            reply_markup=ReplyKeyboardRemove()
        )
        return DOB
    elif section == "🌍 Country":
        return await fetch_and_show_user_countries(update, context)
    elif section == "📍 City":
        return await fetch_and_show_user_cities(update, context)
    elif section == "📧 Email":
        await update.message.reply_text(
            "Please enter your Email address:",
            reply_markup=ReplyKeyboardRemove()  # Temporarily remove buttons for free text input
        )
        return EMAIL
    elif section == "📱 Phone Number":
        await update.message.reply_text(
            "Please share your contact number using the button below:",
            reply_markup=ReplyKeyboardMarkup(
                [[KeyboardButton("Share Contact", request_contact=True)]],  # Button to share contact
                resize_keyboard=True,
                one_time_keyboard=True  # Keyboard hides after contact is shared
            )
        )
        return CONTACT  # Proceed to the contact handling state

    elif section == "✔️ Confirm":
        logger.info("User selected 'Confirm'. Proceeding to profile confirmation.")
        return await handle_profile_confirmation(update, context)
    else:
        logger.warning(f"Invalid section selected: {section}")
        await update.message.reply_text(
            "⚠️ Invalid selection. Please choose one of the options provided below.",
            reply_markup=ReplyKeyboardMarkup(
                [
                    ["👔 User Type", "✍🏾 First Name"],
                    ["👴🏾 Last Name", "🚻 Gender"],
                    ["🎂 Date of Birth (DOB)", "🌍 Country"],
                    ["📍 City", "📧 Email"],
                    ["📱 Phone Number", "✔️ Confirm"],
                ],
                resize_keyboard=True,
            ),
        )
        return USER_REGISTRATION



async def receive_user_type(update: Update, context: CallbackContext) -> int:
    """Handle input for User Type."""
    user_type = update.message.text.strip()

    # List of section buttons to avoid registering as input
    invalid_inputs = [
        "👔 User Type", "✍🏾 First Name", "👴🏾 Last Name", "🚻 Gender",
        "🎂 Date of Birth (DOB)", "🌍 Country", "📍 City", "📧 Email",
        "📱 Phone Number", "✔️ Confirm"
    ]

    # Validate if the input is a button press
    if user_type in invalid_inputs:
        await update.message.reply_text(
            "⚠️ Please select a valid User Type instead of selecting a section button."
        )
        return USER_TYPE  # Prompt the user to re-enter the user type

    # Validate if the input is one of the allowed user types
    if user_type not in ["Applicant", "Employer"]:
        await update.message.reply_text(
            "⚠️ Please select either 'Applicant' or 'Employer' from the options provided.",
            reply_markup=ReplyKeyboardMarkup([["Applicant", "Employer"]], resize_keyboard=True)
        )
        return USER_TYPE  # Stay in the user type input state

    # Save the validated user type
    context.user_data['user_type'] = user_type

    await show_updated_profile_summary(update, context)
    return USER_REGISTRATION  # Move to the first name input state

async def receive_first_name(update: Update, context: CallbackContext) -> int:
    """Handle input for First Name."""
    first_name = update.message.text.strip()

    # List of section buttons to avoid registering as input
    invalid_inputs = [
        "👔 User Type", "✍🏾 First Name", "👴🏾 Last Name", "🚻 Gender",
        "🎂 Date of Birth (DOB)", "🌍 Country", "📍 City", "📧 Email",
        "📱 Phone Number", "✔️ Confirm"
    ]

    # Validate if the input is a button press
    if first_name in invalid_inputs:
        await update.message.reply_text(
            "⚠️ Please enter a valid First Name instead of selecting a section button."
        )
        return FIRST_NAME  # Prompt the user to re-enter the first name

    # Validate if the input is valid or contains only letters and is between 2 and 20 characters
    if not first_name.isalpha() or not (2 <= len(first_name) <= 20):
        await update.message.reply_text(
            "⚠️ Please enter a valid First Name (letters only, 2-20 characters).",
            reply_markup=ReplyKeyboardMarkup([["Back"]], resize_keyboard=True)
        )
        return FIRST_NAME  # Stay in the first name input state

    # Save the validated first name
    context.user_data['first_name'] = first_name

    # Show the updated profile summary
    await show_updated_profile_summary(update, context)

    return USER_REGISTRATION  # Proceed to the next state (profile registration summary)




async def receive_last_name(update: Update, context: CallbackContext) -> int:
    """Handle input for Last Name."""
    last_name = update.message.text.strip()

    # List of section buttons to avoid registering as input
    invalid_inputs = [
        "👔 User Type", "✍🏾 First Name", "👴🏾 Last Name", "🚻 Gender",
        "🎂 Date of Birth (DOB)", "🌍 Country", "📍 City", "📧 Email",
        "📱 Phone Number", "✔️ Confirm"
    ]

    # Validate if the input is a button press
    if last_name in invalid_inputs:
        await update.message.reply_text(
            "⚠️ Please enter a valid Last Name instead of selecting a section button."
        )
        return LAST_NAME  # Prompt the user to re-enter the last name

    # Validate if the input contains only letters and is between 2 and 20 characters
    if not last_name.isalpha() or not (2 <= len(last_name) <= 20):
        await update.message.reply_text(
            "⚠️ Please enter a valid Last Name (letters only, 2-20 characters).",
            reply_markup=ReplyKeyboardMarkup([["Back"]], resize_keyboard=True)
        )
        return LAST_NAME  # Stay in the last name input state

    # Save the validated last name
    context.user_data['last_name'] = last_name

    # Show the updated profile summary
    await show_updated_profile_summary(update, context)

    return USER_REGISTRATION  # Proceed to the profile registration summary


async def receive_gender(update: Update, context: CallbackContext) -> int:
    """Handle input for Gender."""
    gender = update.message.text.strip()

    # List of section buttons to avoid registering as input
    invalid_inputs = [
        "👔 User Type", "✍🏾 First Name", "👴🏾 Last Name", "🚻 Gender",
        "🎂 Date of Birth (DOB)", "🌍 Country", "📍 City", "📧 Email",
        "📱 Phone Number", "✔️ Confirm"
    ]

    # Validate if the input is a button press
    if gender in invalid_inputs:
        await update.message.reply_text(
            "⚠️ Please select a valid Gender instead of selecting a section button."
        )
        return GENDER  # Prompt the user to re-enter the gender

    # Validate that the gender input is one of the valid options
    valid_genders = ["Male", "Female"]
    if gender not in valid_genders:
        await update.message.reply_text(
            "⚠️ Please select a valid gender from the options provided.",
            reply_markup=ReplyKeyboardMarkup([["Male", "Female"]], resize_keyboard=True)
        )
        return GENDER  # Stay in the gender input state

    # Save the validated gender
    context.user_data['gender'] = gender

    # Show the updated profile summary
    await show_updated_profile_summary(update, context)

    return USER_REGISTRATION  # Proceed to the profile registration summary


async def fetch_and_show_user_countries(update: Update, context: CallbackContext) -> int:
    """Fetch and display countries dynamically from the database."""
    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432",
        )
        cursor = conn.cursor()

        # Fetch active countries from the database
        cursor.execute("SELECT country_name FROM countries WHERE is_active = TRUE ORDER BY country_name ASC;")
        countries = [row[0] for row in cursor.fetchall()]

        if not countries:
            await update.message.reply_text("No active countries available.")
            return SELECT_SECTION

        # Save valid countries to context for validation
        context.user_data["valid_countries"] = countries

        # Prepare keyboard buttons for countries in a single column
        country_buttons = [[country] for country in countries]

        # Display the countries to the user
        await update.message.reply_text(
            "Please select the Country:",
            reply_markup=ReplyKeyboardMarkup(country_buttons, resize_keyboard=True),
        )
        return COUNTRY  # Proceed to country selection

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error while fetching countries: {error}")
        await update.message.reply_text(
            "An error occurred while fetching countries. Please try again later."
        )
        return SELECT_SECTION

    finally:
        if conn:
            cursor.close()
            conn.close()


async def receive_country(update: Update, context: CallbackContext) -> int:
    """Handle the user's country selection."""
    selected_country = update.message.text.strip()

    # Validate the selection
    valid_countries = context.user_data.get("valid_countries", [])

    if selected_country not in valid_countries:
        await update.message.reply_text(
            "⚠️ Invalid selection. Please choose a valid Country from the options provided.",
            reply_markup=ReplyKeyboardMarkup(
                [[country] for country in valid_countries],
                resize_keyboard=True,
            ),
        )
        return COUNTRY  # Keep the user in the current state

    # Save the selected country to context
    context.user_data["country"] = selected_country

    # Show the updated profile summary
    await show_updated_profile_summary(update, context)

    return USER_REGISTRATION  # Proceed to the next registration step


async def fetch_and_show_user_cities(update: Update, context: CallbackContext):
    """Fetch and display cities dynamically from the database."""
    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432",
        )
        cursor = conn.cursor()

        # Fetch active cities from the database
        cursor.execute("SELECT city_name FROM locations ORDER BY city_name ASC;")
        cities = [row[0] for row in cursor.fetchall()]

        if not cities:
            await update.message.reply_text("No active cities available.")
            return SELECT_SECTION

        # Save valid cities to context for validation
        context.user_data["valid_cities"] = cities

        # Prepare keyboard buttons for cities in a single column
        city_buttons = [[city] for city in cities]

        # Display the cities to the user
        await update.message.reply_text(
            "Please select the City:",
            reply_markup=ReplyKeyboardMarkup(city_buttons, resize_keyboard=True),
        )
        return CITY  # Proceed to the city selection state

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error while fetching cities: {error}")
        await update.message.reply_text(
            "An error occurred while fetching cities. Please try again later."
        )
        return SELECT_SECTION

    finally:
        if conn:
            cursor.close()
            conn.close()


async def receive_city(update, context: CallbackContext):
    """Handle the user's city selection."""
    selected_city = update.message.text.strip()

    # Validate the selection
    valid_cities = context.user_data.get("valid_cities", [])


    if selected_city not in valid_cities:
        await update.message.reply_text(
            "⚠️ Invalid selection. Please choose a valid City from the options provided.",
            reply_markup=ReplyKeyboardMarkup(
                [[city] for city in valid_cities],
                resize_keyboard=True,
            ),
        )
        return CITY  # Keep the user in the current state

    # Save the selected city to context
    context.user_data["city"] = selected_city

    # Show the updated profile summary
    await show_updated_profile_summary(update, context)

    # Return to the section selection
    return USER_REGISTRATION


async def receive_email(update: Update, context: CallbackContext) -> int:
    """Handle input for Email."""
    email = update.message.text.strip()

    # List of section buttons to avoid registering as input
    invalid_inputs = [
        "👔 User Type", "✍🏾 First Name", "👴🏾 Last Name", "🚻 Gender",
        "🎂 Date of Birth (DOB)", "🌍 Country", "📍 City", "📧 Email",
        "📱 Phone Number", "✔️ Confirm"
    ]

    # Validate if the input is a button press
    if email in invalid_inputs:
        await update.message.reply_text(
            "⚠️ Please enter a valid Email instead of selecting a section button."
        )
        return EMAIL  # Prompt the user to re-enter the email

    # Validate email format
    if "@" not in email or "." not in email:
        await update.message.reply_text(
            "⚠️ Please enter a valid email address."
        )
        return EMAIL  # Stay in the email input state

    # Save the validated email
    context.user_data['email'] = email

    # Show the updated profile summary
    await show_updated_profile_summary(update, context)

    return USER_REGISTRATION  # Proceed to the profile registration summary



async def receive_dob(update: Update, context: CallbackContext) -> int:
    """Handle input for Date of Birth (DOB) in dd/mm/yyyy format only."""
    dob_input = update.message.text.strip()

    # List of section buttons to avoid registering as input
    invalid_inputs = [
        "👔 User Type", "✍🏾 First Name", "👴🏾 Last Name", "🚻 Gender",
        "🎂 Date of Birth (DOB)", "🌍 Country", "📍 City", "📧 Email",
        "📱 Phone Number", "✔️ Confirm"
    ]

    # Validate if the input is a button press
    if dob_input in invalid_inputs:
        await update.message.reply_text(
            "⚠️ Please enter a valid Date of Birth instead of selecting a section button."
        )
        return DOB  # Prompt the user to re-enter the DOB

    # Validate the DOB input (strictly in dd/mm/yyyy format)
    if re.match(r"^(0[1-9]|[12][0-9]|3[01])/(0[1-9]|1[0-2])/\d{4}$", dob_input):
        try:
            # Convert to standard format (YYYY-MM-DD) and validate
            formatted_dob = datetime.strptime(dob_input, '%d/%m/%Y').strftime('%Y-%m-%d')
            context.user_data['dob'] = formatted_dob  # Save in standard format
            context.user_data['dob_label'] = "Date of Birth"
        except ValueError:
            # Handle invalid date like 31/02/2024
            await update.message.reply_text(
                "⚠️ The date you entered is invalid. Please use the format 'dd/mm/yyyy'."
            )
            return DOB  # Stay in DOB input state
    else:
        # Reject invalid formats
        await update.message.reply_text(
            "⚠️ Invalid input. Please enter your Date of Birth in the format 'dd/mm/yyyy'."
        )
        return DOB  # Stay in DOB input state

    # Show the updated profile summary
    await show_updated_profile_summary(update, context)

    return USER_REGISTRATION  # Proceed to the profile registration summary


def escape_markdown(text):
    """Helper function to escape special characters for Markdown."""
    return (
        text.replace("_", "\\_")
            .replace("*", "\\*")
            .replace("[", "\\[")
            .replace("]", "\\]")
            .replace("(", "\\(")
            .replace(")", "\\)")
            .replace("~", "\\~")
            .replace("`", "\\`")
            .replace(">", "\\>")
            .replace("#", "\\#")
            .replace("+", "\\+")
            .replace("-", "\\-")  # Properly escaping the dash
            .replace("=", "\\=")
            .replace("|", "\\|")
            .replace("{", "\\{")
            .replace("}", "\\}")
            .replace(".", "\\.")
            .replace("!", "\\!")
    )


async def handle_contact(update: Update, context: CallbackContext) -> int:
    """Handle input for Contact Information."""
    # Check if the user shared contact details via the contact sharing button
    contact = update.message.contact.phone_number if update.message.contact else None

    # Validate if the contact was provided
    if not contact:
        await update.message.reply_text(
            "⚠️ Please share a valid contact number using the button provided."
        )
        return CONTACT  # Stay in the contact input state if no contact is shared

    # Save the Telegram chat ID and phone number
    user_id = update.message.from_user.id  # Telegram chat ID
    context.user_data['contact'] = user_id  # Store chat ID in 'contact' column
    context.user_data['phone_number'] = contact  # Store phone number in 'phone_number' column

    # Show the updated profile summary
    await show_updated_profile_summary(update, context)

    return USER_REGISTRATION  # Proceed to the profile confirmation state





import psycopg2  # Use psycopg2 for PostgreSQL connection
from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import CallbackContext
import logging
from datetime import datetime  # Import datetime for date conversion

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def handle_profile_confirmation(update: Update, context: CallbackContext) -> int:
    """Handle profile confirmation and ensure all required fields are entered."""
    choice = update.message.text.strip()

    if choice != "✔️ Confirm":
        await update.message.reply_text("Invalid choice. Please select 'Confirm' to proceed.")
        return PROFILE_CONFIRMATION  # Stay in the confirmation state

    # Validate all required fields
    required_fields = {
        "user_type": "User Type",
        "first_name": "First Name",
        "last_name": "Last Name",
        "gender": "Gender",
        "dob": "Date of Birth",
        "country": "Country",
        "city": "City",
        "email": "Email",
        "phone_number": "Phone Number",
    }

    missing_fields = [
        f"- {field_name}" for field_key, field_name in required_fields.items()
        if not context.user_data.get(field_key)
    ]

    if missing_fields:
        await update.message.reply_text(
            f"⚠️ The following required fields are missing:\n\n{'\n'.join(missing_fields)}"
            f"\n\n💡 Please complete your profile before confirming."
        )
        return USER_REGISTRATION  # Stay in the confirmation state to correct details

    # Retrieve the user's Telegram username
    username = update.message.from_user.username
    # Store the chat_id as the contact field for consistency
    chat_id = update.message.chat_id
    context.user_data['contact'] = str(chat_id)  # Cast the chat_id to string
    contact = context.user_data['contact']  # Use the correct contact/chat ID

    # Handle phone number separately for formatting and database insertion
    phone_number = context.user_data.get('phone_number')
    if phone_number.startswith("+"):
        # Use a formatted version for display but keep the raw version for database
        formatted_phone_number = phone_number
        raw_phone_number = phone_number.lstrip("+")  # Remove '+' for database storage
    else:
        # If no '+' prefix, use the raw phone number as-is
        formatted_phone_number = f"+{phone_number}"
        raw_phone_number = phone_number

        # Validate and convert the date of birth
        dob = context.user_data.get('dob')
        try:
            # Check if the format is already correct
            if not re.match(r"^\d{4}-\d{2}-\d{2}$", dob):  # Convert only if not already in 'YYYY-MM-DD'
                dob_converted = datetime.strptime(dob, '%d/%m/%Y').strftime('%Y-%m-%d')
                context.user_data['dob'] = dob_converted  # Replace the original dob with the converted one
        except ValueError as e:
            logger.error(f"Date conversion error: {e}")
            await update.message.reply_text(
                "⚠️ Invalid date format. Please use DD/MM/YYYY format."
            )
            return USER_REGISTRATION  # Stay in the confirmation state

    # Connect to PostgreSQL database
    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Check if the user is already registered
        contact = context.user_data['contact']
        cursor.execute('SELECT * FROM users WHERE contact = %s', (contact,))
        existing_user = cursor.fetchone()

        if existing_user:
            logger.info(f"User {contact} is already registered. Skipping insertion.")
            conn.close()

            # Redirect to the appropriate main menu based on user type
            if context.user_data['user_type'] == 'Applicant':
                return await show_applicant_main_menu(update, context)
            else:
                return await show_employer_menu(update, context)

        # Insert new user data into the database
        try:
            logger.info(f"Inserting new user into the database with details: {context.user_data}")
            cursor.execute('''
                INSERT INTO users (first_name, last_name, gender, user_type, country, city, dob, email, contact, username, phone_number, is_registered)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, 1)
            ''', (
                context.user_data['first_name'],
                context.user_data['last_name'],
                context.user_data['gender'],
                context.user_data['user_type'],
                context.user_data['country'],
                context.user_data['city'],
                context.user_data['dob'],  # Use the converted date
                context.user_data['email'],
                contact,
                username,  # Save the Telegram username
                raw_phone_number  # Save the phone number
            ))
            conn.commit()
            logger.info(f"User {contact} successfully registered.")
        except Exception as e:
            logger.error(f"Error inserting user: {str(e)}")
        finally:
            conn.close()

            # Send congratulations message after successful registration
            await update.message.reply_text(
                "🎉 <b>Congratulations!</b>\n\n"
                "Your profile has been successfully created on <b>Afro Joblink</b>.\n\n"
                "Welcome aboard! 🌟",
                parse_mode="HTML"
            )

        # Redirect to the appropriate main menu based on user type
        if context.user_data['user_type'] == 'Applicant':
            return await show_applicant_main_menu(update, context)
        else:
            return await show_employer_menu(update, context)

    except Exception as e:
        logger.error(f"Database connection error: {str(e)}")
        await update.message.reply_text("An error occurred while processing your registration. Please try again later.")
        return PROFILE_CONFIRMATION




# Step 4: Handle profile editing based on user type (Employer or Applicant)
async def handle_edit_profile(update: Update, context: CallbackContext) -> int:
    field = update.message.text
    user_type = context.user_data.get('user_type', 'employer')  # Default to 'employer' if not set

    # Check if the user selected "Back" to go back to the profile summary
    if field.lower() == "back":
        return await show_updated_profile_summary(update, context)


    elif field == "First Name":
        # Ask for the new First Name and show only the Back button
        await update.message.reply_text(
            "Please enter your new First Name (2-20 characters, letters only):",
            reply_markup=ReplyKeyboardMarkup([["Back"]], resize_keyboard=True)  # Only show the Back button
        )
        return EDIT_FIRST_NAME  # Move to the first name editing state

    elif field == "Last Name":
        # Ask for the new Last Name and show only the Back button
        await update.message.reply_text(
            "Please enter your new Last Name (2-20 characters, letters only):",
            reply_markup=ReplyKeyboardMarkup([["Back"]], resize_keyboard=True)  # Only show the Back button
        )
        return EDIT_LAST_NAME  # Move to the last name editing state

    elif field == "Gender":
        await update.message.reply_text(
            "Please select your gender:",
            reply_markup=ReplyKeyboardMarkup([["Male", "Female"], ["Back"]], resize_keyboard=True)
        )
        return EDIT_GENDER  # Move to the gender editing state


    elif field == "Country":
        await update.message.reply_text(
            "Which country are you living in?",
            reply_markup=ReplyKeyboardMarkup([["Ethiopia", "Back"]], resize_keyboard=True)
        )
        return EDIT_COUNTRY  # Move to the country editing state

    elif field == "City":
        await update.message.reply_text(
            "Which city are you living in?",
            reply_markup=ReplyKeyboardMarkup([
                ["Addis Ababa", "Adama"],
                ["Dire Dawa", "Hawassa"],
                ["Mekele", "Gonder"],
                ["Bahir Dar", "Aksum"],
                ["Jigjiga", "Semera"],
                ["Gambella", "Harar"],
                ["Dessie", "Jimma"],
                ["Shashamane", "Debre Birhan"],
                ["Bishoftu", "Sodo"],
                ["Nekemte", "Other"],
                ["Back"]
            ], resize_keyboard=True, one_time_keyboard=True)
        )
        return EDIT_CITY  # Move to the city editing state


    elif field == "Email":
        # Ask for the new Email and show only the Back button
        await update.message.reply_text(
            "Please enter your new Email address:",
            reply_markup=ReplyKeyboardMarkup([["Back"]], resize_keyboard=True)  # Only show the Back button
        )
        return EDIT_EMAIL  # Move to the email editing state

    elif field == "Date of Birth":
        # Ask for the new Date of Birth and show only the Back button
        await update.message.reply_text(
            "Please enter your new Date of Birth in the format 'dd/mm/yyyy' or your age (15-100):",
            reply_markup=ReplyKeyboardMarkup([["Back"]], resize_keyboard=True)  # Only show the Back button
        )
        return EDIT_DOB  # Move to the DOB editing state

    elif field == "User Type":
        # Ask for the new User Type (Applicant or Employer) and show only the Back button
        await update.message.reply_text(
            "Please select your User Type:",
            reply_markup=ReplyKeyboardMarkup([["Applicant", "Employer"], ["Back"]], resize_keyboard=True)
            # Include Back button
        )
        return EDIT_USER_TYPE  # Move to the user type editing state

    else:
        await update.message.reply_text("Invalid choice. Please try again.")
        return EDIT_PROFILE  # Stay in the editing state




# Step 4.1: Handle first name editing with proper back handling
async def edit_first_name(update: Update, context: CallbackContext) -> int:
    new_first_name = update.message.text

    # Check if the user selected "Back"
    if new_first_name.lower() == "back":
        # If "Back" is pressed, show the profile summary without making changes
        return await show_updated_profile_summary(update, context)

    # Validate the new first name (letters only, 2-20 characters)
    if not new_first_name.isalpha() or not (2 <= len(new_first_name) <= 20):
        await update.message.reply_text(
            "Please enter a valid first name (letters only, 2-20 characters).",
            reply_markup=ReplyKeyboardMarkup([["Back"]], resize_keyboard=True)
        )
        return EDIT_FIRST_NAME  # Stay in the first name editing state

    # Store the new first name and update context
    context.user_data['first_name'] = new_first_name

    # Confirm the update and remove the keyboard
    await update.message.reply_text(
        f"First name updated to: {new_first_name}",
        reply_markup=ReplyKeyboardRemove()  # Hide keyboard after input
    )

    # Return to profile summary after updating
    return await show_updated_profile_summary(update, context)


# Step 4.2: Handle last name editing with proper back handling
async def edit_last_name(update: Update, context: CallbackContext) -> int:
    new_last_name = update.message.text

    # Check if the user selected "Back"
    if new_last_name.lower() == "back":
        # If "Back" is pressed, show the profile summary without making changes
        return await show_updated_profile_summary(update, context)

    # Validate the new last name (letters only, 2-20 characters)
    if not new_last_name.isalpha() or not (2 <= len(new_last_name) <= 20):
        await update.message.reply_text(
            "Please enter a valid last name (letters only, 2-20 characters).",
            reply_markup=ReplyKeyboardMarkup([["Back"]], resize_keyboard=True)
        )
        return EDIT_LAST_NAME  # Stay in the last name editing state

    # Store the new last name and update context
    context.user_data['last_name'] = new_last_name

    # Confirm the update and remove the keyboard
    await update.message.reply_text(
        f"Last name updated to: {new_last_name}",
        reply_markup=ReplyKeyboardRemove()  # Hide keyboard after input
    )

    # Return to profile summary after updating
    return await show_updated_profile_summary(update, context)

async def edit_user_type(update: Update, context: CallbackContext) -> int:
    new_user_type = update.message.text

    # Check if the user selected "Back"
    if new_user_type.lower() == "back":
        return await show_updated_profile_summary(update, context)  # Go back to profile summary

    # Validate the new user type
    valid_user_types = ["Applicant", "Employer"]
    if new_user_type not in valid_user_types:
        await update.message.reply_text(
            "Please select a valid User Type (Applicant or Employer).",
            reply_markup=ReplyKeyboardMarkup([["Applicant", "Employer"], ["Back"]], resize_keyboard=True)
        )
        return EDIT_USER_TYPE  # Stay in the user type editing state

    # Store the new user type and update context
    context.user_data['user_type'] = new_user_type

    # Confirmation and return to profile summary
    await update.message.reply_text(
        f"User Type updated to: {new_user_type}",
        reply_markup=ReplyKeyboardRemove()
    )

    # Proceed to show the updated profile summary
    return await show_updated_profile_summary(update, context)


# Step 4.3: Handle gender editing with proper back handling
async def edit_gender(update: Update, context: CallbackContext) -> int:
    new_gender = update.message.text

    # Check if the user selected "Back"
    if new_gender.lower() == "back":
        # If "Back" is pressed, show the profile summary without making changes
        return await show_updated_profile_summary(update, context)

    # Validate the new gender (must be either "Male" or "Female")
    if new_gender not in ["Male", "Female"]:
        await update.message.reply_text(
            "Please select a valid gender (Male or Female).",
            reply_markup=ReplyKeyboardMarkup([["Male", "Female"], ["Back"]], resize_keyboard=True)
        )
        return EDIT_GENDER  # Stay in the gender editing state

    # Store the new gender and update context
    context.user_data['gender'] = new_gender

    # Confirm the update and remove the keyboard
    await update.message.reply_text(
        f"Gender updated to: {new_gender}",
        reply_markup=ReplyKeyboardRemove()  # Hide keyboard after input
    )

    # Return to profile summary after updating
    return await show_updated_profile_summary(update, context)


# Step 4.4: Handle country editing with proper back handling
async def edit_country(update: Update, context: CallbackContext) -> int:
    new_country = update.message.text

    # Check if the user selected "Back"
    if new_country.lower() == "back":
        # If "Back" is pressed, show the profile summary without making changes
        return await show_updated_profile_summary(update, context)

    # Validate the new country (must be one of the provided options)
    valid_countries = ["Ethiopia"]
    if new_country not in valid_countries:
        await update.message.reply_text(
            "Please select a valid country.",
            reply_markup=ReplyKeyboardMarkup([["Ethiopia", "Back"]], resize_keyboard=True)
        )
        return EDIT_COUNTRY  # Stay in the country editing state

    # Store the new country and update context
    context.user_data['country'] = new_country

    # Confirm the update and remove the keyboard
    await update.message.reply_text(
        f"Country updated to: {new_country}",
        reply_markup=ReplyKeyboardRemove()  # Hide keyboard after input
    )

    # Return to profile summary after updating
    return await show_updated_profile_summary(update, context)


# Step 4.5: Handle city editing with proper back handling
async def edit_city(update: Update, context: CallbackContext) -> int:
    new_city = update.message.text

    # Check if the user selected "Back"
    if new_city.lower() == "back":
        # If "Back" is pressed, show the profile summary without making changes
        return await show_updated_profile_summary(update, context)

    # Validate the new city (must be one of the provided options)
    valid_cities = [
        ["Addis Ababa", "Adama"],
        ["Dire Dawa", "Hawassa"],
        ["Mekele", "Gonder"],
        ["Bahir Dar", "Aksum"],
        ["Jigjiga", "Semera"],
        ["Gambella", "Harar"],
        ["Dessie", "Jimma"],
        ["Shashamane", "Debre Birhan"],
        ["Bishoftu", "Sodo"],
        ["Nekemte", "Other"],


    ]
    if new_city not in valid_cities:
        await update.message.reply_text(
            "Please select a valid city.",
            reply_markup=ReplyKeyboardMarkup([
                ["Addis Ababa", "Adama"],
                ["Dire Dawa", "Hawassa"],
                ["Mekele", "Gonder"],
                ["Bahir Dar", "Aksum"],
                ["Jigjiga", "Semera"],
                ["Gambella", "Harar"],
                ["Dessie", "Jimma"],
                ["Shashamane", "Debre Birhan"],
                ["Bishoftu", "Sodo"],
                ["Nekemte", "Other"],
                ["Back"]], resize_keyboard=True)
        )
        return EDIT_CITY  # Stay in the city editing state

    # Store the new city and update context
    context.user_data['city'] = new_city

    # Confirm the update and remove the keyboard
    await update.message.reply_text(
        f"City updated to: {new_city}",
        reply_markup=ReplyKeyboardRemove()  # Hide keyboard after input
    )

    # Return to profile summary after updating
    return await show_updated_profile_summary(update, context)


# Step 4.6: Handle email editing with proper back handling
async def edit_email(update: Update, context: CallbackContext) -> int:
    new_email = update.message.text

    # Check if the user selected "Back"
    if new_email.lower() == "back":
        # If "Back" is pressed, show the profile summary without making changes
        return await show_updated_profile_summary(update, context)

    # Validate the new email
    if "@" not in new_email or "." not in new_email:
        await update.message.reply_text(
            "Please enter a valid email address.",
            reply_markup=ReplyKeyboardMarkup([["Back"]], resize_keyboard=True)
        )
        return EDIT_EMAIL  # Stay in the email editing state

    # Store the new email and update context
    context.user_data['email'] = new_email

    # Confirm the update and remove the keyboard
    await update.message.reply_text(
        f"Email updated to: {new_email}",
        reply_markup=ReplyKeyboardRemove()  # Hide keyboard after input
    )

    # Return to profile summary after updating
    return await show_updated_profile_summary(update, context)


# Step 4.7: Handle date of birth editing with proper back handling
async def edit_dob(update: Update, context: CallbackContext) -> int:
    new_dob = update.message.text

    # Check if the user selected "Back"
    if new_dob.lower() == "back":
        # If "Back" is pressed, show the profile summary without making changes
        return await show_updated_profile_summary(update, context)

    # Validate the new date of birth (format: dd/mm/yyyy) or age (between 15 and 100)
    if re.match(r"^(0[1-9]|[12][0-9]|3[01])/(0[1-9]|1[0-2])/\d{4}$", new_dob):
        context.user_data['dob'] = new_dob
    elif new_dob.isdigit() and 15 <= int(new_dob) <= 100:
        context.user_data['dob'] = f"Age: {new_dob}"
    else:
        await update.message.reply_text(
            "Please enter a valid Date of Birth in the format 'dd/mm/yyyy' or age (15-100).",
            reply_markup=ReplyKeyboardMarkup([["Back"]], resize_keyboard=True)
        )
        return EDIT_DOB  # Stay in the date of birth editing state

    # Confirm the update and remove the keyboard
    await update.message.reply_text(
        f"Date of Birth updated to: {new_dob}",
        reply_markup=ReplyKeyboardRemove()  # Hide keyboard after input
    )

    # Return to profile summary after updating
    return await show_updated_profile_summary(update, context)



# Profile summary function with dynamic DOB/age label
async def show_updated_profile_summary(update: Update, context: CallbackContext) -> int:
    # Dynamically assign an icon based on the gender
    if context.user_data.get('gender') == "Male":
        first_name_icon = "👨🏾"  # Young black man icon for male
        gender_icon = "♂️"  # Male gender icon
    elif context.user_data.get('gender') == "Female":
        first_name_icon = "👩🏾"  # Young black woman icon for female
        gender_icon = "♀️"  # Female gender icon
    else:
        first_name_icon = "🧑🏾"  # General person icon for unspecified gender
        gender_icon = "⚥"  # General gender icon

        # Dynamically assign a user type icon based on the gender and user type
    user_type = context.user_data.get('user_type')
    gender = context.user_data.get('gender')

    if user_type == "Employer":
        if gender == "Male":
            user_type_icon = "👨🏾‍💼"  # Male employer icon
        elif gender == "Female":
            user_type_icon = "👩🏾‍💼"  # Female employer icon
        else:
            user_type_icon = "👔"  # Default employer icon
    elif user_type == "Applicant":
        if gender == "Male":
            user_type_icon = "👨🏾‍🎓"  # Male applicant icon
        elif gender == "Female":
            user_type_icon = "👩🏾‍🎓"  # Female applicant icon
        else:
            user_type_icon = "🎓"  # Default applicant icon
    else:
        user_type_icon = "💼"  # Default user type icon

    # Format the phone number with a "+" prefix
    phone_number = context.user_data.get('phone_number')
    if phone_number and not phone_number.startswith("+"):
        phone_number = f"+{phone_number}"  # Add "+" if it's not already there
        context.user_data['phone_number'] = phone_number  # Update the phone number in context

    # Field labels and their icons
    fields = [
        ("first_name", f"{first_name_icon} *First Name*:"),
        ("last_name", "👴🏾 *Last Name*:"),
        ("gender", f"{gender_icon} *Gender*:"),
        ("user_type", f"{user_type_icon} *User Type*:"),
        ("dob", f"🎂 *{context.user_data.get('dob_label', 'Date of Birth')}:*"),
        ("city", "📍 *City*:"),
        ("country", "🌍 *Country*:"),
        ("email", "📧 *Email*:"),
        ("phone_number", "📱 *Phone Number*:"),
    ]

    # Prepare the profile summary dynamically
    summary_lines = []
    for field_key, label in fields:
        value = context.user_data.get(field_key)
        if value and value.strip():  # Only include fields with non-empty, non-null values
            if field_key in context.user_data.get("updated_fields", []):
                # Highlight recently updated fields
                summary_lines.append(f"{label} {escape_markdown(value)}")
            else:
                summary_lines.append(f"{label} {escape_markdown(value)}")

    # If no fields are set, display a default message
    if not summary_lines:
        profile_summary = "No profile details have been provided yet."
    else:
        # Join the summary lines with separators for better formatting
        profile_summary = (
            "\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\n\n" +
            "\n\n".join(summary_lines) +
            "\n\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\n"
        )

    # Send the summary with the specified buttons
    await update.message.reply_text(
        f"Here is your updated profile summary:\n\n{profile_summary}",
        reply_markup=ReplyKeyboardMarkup(
            [
                ["👔 User Type", "✍🏾 First Name"],
                ["👴🏾 Last Name", "🚻 Gender"],
                ["🎂 Date of Birth (DOB)", "🌍 Country"],
                ["📍 City", "📧 Email"],
                ["📱 Phone Number", "✔️ Confirm"],
            ],
            resize_keyboard=True,
        ),
        parse_mode='MarkdownV2'  # Ensure Telegram uses MarkdownV2 for formatting
    )

    # Reset the "updated_fields" tracker
    context.user_data["updated_fields"] = []

    return PROFILE_CONFIRMATION  # Return to the profile confirmation state


# Function to show Applicant Main Menu
async def show_applicant_main_menu(update: Update, context: CallbackContext) -> int:
    contact = str(update.message.chat_id)
    log_debug(f"Attempting to display Applicant Menu for user: {contact}")

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Check if the user is banned
        cursor.execute('SELECT status, first_name FROM users WHERE contact = %s', (contact,))
        result = cursor.fetchone()

        if result:
            status, first_name = result

            if status == "banned":
                # Notify banned user and terminate the flow
                await update.message.reply_text(
                    f"🚫 Dear {first_name},\n\n"
                    "Your access to the platform has been restricted due to a violation of our policies.\n\n"
                    "If you believe this is a mistake, please contact support:\n"
                    "📧 support@example.com\n📞 +1 800 123 4567",
                    parse_mode="HTML"
                )
                return

        # Display the Applicant Main Menu
        await update.message.reply_text(
            "<b>🎓 Applicant Dashboard</b>\n\n"
            "Welcome to your personalized dashboard on <b>Afro Joblink</b>. Explore opportunities, manage your profile, and stay updated on your applications:\n\n"
            "🔍 <b>Job Search:</b> Discover job opportunities tailored to your skills and preferences.\n\n"
            "🪪 <b>My Profile:</b> View and update your profile to make a strong impression on employers.\n\n"
            "📄 <b>Applications:</b> Track and manage the jobs you’ve applied for.\n\n"
            "📢 <b>Job Alerts:</b> Set up alerts to never miss new opportunities.\n\n"
            "💬 <b>Messages:</b> Stay connected with Afro Joblink Admins.\n\n"
            "📜 <b>History:</b> Review your job application history and interactions.\n\n"
            "⚙️ <b>Settings:</b> Adjust your preferences and account details.\n\n"
            "📞 <b>Help & Support:</b> Get assistance or provide feedback.\n\n"
            "Choose an option below to get started:",
            reply_markup=ReplyKeyboardMarkup([
                ["🔍 Job Search", "🪪 My Profile"],
                ["📄 Applications", "📢 Job Alerts"],
                ["💬 Messages", "📜 History"],
                ["⚙️ Settings", "📞 Help & Support"]
            ], resize_keyboard=True),
            parse_mode="HTML"
        )
        return APPLICANT_MAIN_MENU  # Transition to the applicant main menu state

    except Exception as e:
        log_error(f"Database error while checking banned status for {contact}: {e}")
        await update.message.reply_text("An error occurred. Please try again later.")
        return

    finally:
        if conn:
            cursor.close()
            conn.close()



# Function to handle the main menu choices for applicants
async def handle_applicant_main_menu_choice(update: Update, context: CallbackContext) -> int:
    choice = update.message.text

    if choice == "🔍 Job Search":
        return await show_job_search_menu(update, context)  # Transition to Job Search submenu

    elif choice == "🪪 My Profile":
        return await show_my_profile_menu(update, context)  # Transition to My Profile submenu

    elif choice == "📄 Applications":
        return await show_applications_menu(update, context)  # Transition to Applications submenu

    elif choice == "📢 Job Alerts":
        return await show_job_alerts_menu(update, context)  # Transition to Job Alerts submenu

    elif choice == "💬 Messages":
        return await show_messages_menu(update, context)  # Transition to Messages submenu

    elif choice == "📜 History":
        return await show_skill_assessments_menu(update, context)  # Transition to Skill Assessments submenu

    elif choice == "⚙️ Settings":
        return await show_settings_menu(update, context)  # Transition to Settings submenu

    elif choice == "📞 Help & Support":
        return await show_help_support_menu(update, context)  # Transition to Help & Support submenu


    else:
        # If the choice is invalid, show the main menu buttons again
        await update.message.reply_text(
            "⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button:",
            reply_markup=ReplyKeyboardMarkup(
                [
                    ["🔍 Job Search", "🪪 My Profile"],
                    ["📄 Applications", "📢 Job Alerts"],
                    ["💬 Messages", "📜 History"],
                    ["⚙️ Settings", "📞 Help & Support"]
                ],
                resize_keyboard=True
            )
        )
        return APPLICANT_MAIN_MENU  # Stay in the main menu state

# Job Search Submenu
async def show_job_search_menu(update: Update, context: CallbackContext) -> int:
    # Define valid choices for the Job Search Menu
    valid_choices = {
        "🌍 By Location",
        "🏭 By Industry",
        "🛠️ Filter by Job Type",
        "🆕 Recently Posted",
        "💾 Saved Jobs",
        "🔙 Back to Main Menu",
    }

    # Display the Job Search Menu
    await update.message.reply_text(
        "<b>🔍 Job Search Menu</b>\n\n"
        "Explore job opportunities tailored to your preferences. Use the options below to filter and find the perfect role for you:\n\n"
        "🌍 <b>By Location:</b> Search for jobs based on specific cities or regions.\n\n"
        "🏭 <b>By Industry:</b> Narrow down opportunities within your field of expertise.\n\n"
        "🛠️ <b>Filter by Job Type:</b> Choose full-time, part-time, freelance, or other job types.\n\n"
        "🆕 <b>Recently Posted:</b> Check out the latest job listings updated regularly.\n\n"
        "💾 <b>Saved Jobs:</b> View and manage jobs you’ve saved for later.\n\n"
        "Choose an option below to get started or return to the main menu:",
        reply_markup=ReplyKeyboardMarkup([
            ["🌍 By Location", "🏭 By Industry"],
            ["🛠️ Filter by Job Type", "🆕 Recently Posted"],
            ["💾 Saved Jobs", "🔙 Back to Main Menu"]
        ], resize_keyboard=True),
        parse_mode="HTML"
    )
    return JOB_SEARCH_MENU  # Transition to the job search menu state


# Function to show the profile menu for the user
async def show_my_profile_menu(update: Update, context: CallbackContext) -> int:
    # Define valid choices for the Profile Menu
    valid_choices = {
        "➕🪪 Add Profile",
        "🧑🏿‍🎓 View Profile",
        "📄 Upload Resume/CV",
        "🔙 Back to Main Menu",
    }

    # Display the Profile Menu
    await update.message.reply_text(
        "<b>🪪 Profile Menu</b>\n\n"
        "Manage your profile effectively with the options below:\n\n"
        "➕🪪 <b>Add Profile:</b> Create or update your professional profile to stand out to employers.\n\n"
        "🧑🏿‍🎓 <b>View Profile:</b> Review your profile details as employers see them.\n\n"
        "📄 <b>Upload Resume/CV:</b> Upload your latest resume or CV to enhance your applications.\n\n"
        "Choose an action to proceed or return to the main menu:",
        reply_markup=ReplyKeyboardMarkup([
            ["➕🪪 Add Profile", "🧑🏿‍🎓 View Profile"],
            ["📄 Upload Resume/CV", "🔙 Back to Main Menu"],
        ], resize_keyboard=True),
        parse_mode="HTML"
    )
    return MY_PROFILE_MENU  # Transition to the profile menu state


# Applications Submenu
async def show_applications_menu(update: Update, context: CallbackContext) -> int:
    # Define valid choices for the Applications Menu
    valid_choices = {
        "📄 Active Applications",
        "⚡ Application Status",
        "🗂️ History of Applied Jobs",
        "💾 Saved Drafts",
        "🔙 Back to Main Menu",
    }

    # Display the Applications Menu
    await update.message.reply_text(
        "<b>📄 Applications Menu</b>\n\n"
        "Efficiently manage your job applications using the options below:\n\n"
        "📄 <b>Active Applications:</b> View jobs you’ve recently applied for and track their progress.\n\n"
        "⚡ <b>Application Status:</b> Check the current status of your submitted applications.\n\n"
        "🗂️ <b>History of Applied Jobs:</b> Access a complete list of jobs you’ve applied to in the past.\n\n"
        "💾 <b>Saved Drafts:</b> Review and complete your unfinished job applications.\n\n"
        "Choose an action to proceed or return to the main menu:",
        reply_markup=ReplyKeyboardMarkup([
            ["📄 Active Applications", "⚡ Application Status"],
            ["🗂️ History of Applied Jobs", "💾 Saved Drafts"],
            ["🔙 Back to Main Menu"]
        ], resize_keyboard=True),
        parse_mode="HTML"
    )
    return APPLICATIONS_MENU  # Transition to the applications menu state


# Job Alerts Submenu
async def show_job_alerts_menu(update: Update, context: CallbackContext) -> int:
    # Define valid choices for the Job Alerts Menu
    valid_choices = {
        "📢 Set Job Alerts",
        "⚙️ Manage Job Alerts",
        "🗂️ View Alert History",
        "🔙 Back to Main Menu",
    }

    # Display the Job Alerts Menu
    await update.message.reply_text(
        "<b>📢 Job Alerts Menu</b>\n\n"
        "Stay updated with the latest job opportunities tailored to your preferences. Choose an option below:\n\n"
        "📢 <b>Set Job Alerts:</b> Create custom alerts for jobs that match your criteria.\n\n"
        "⚙️ <b>Manage Job Alerts:</b> Edit or deactivate your existing job alerts as needed.\n\n"
        "🗂️ <b>View Alert History:</b> Review the alerts you’ve received and track their performance.\n\n"
        "Choose an action to proceed or return to the main menu:",
        reply_markup=ReplyKeyboardMarkup([
            ["📢 Set Job Alerts", "⚙️ Manage Job Alerts"],
            ["🗂️ View Alert History", "🔙 Back to Main Menu"]
        ], resize_keyboard=True),
        parse_mode="HTML"
    )
    return JOB_ALERTS_MENU  # Transition to the job alerts menu state


# Messages Submenu
async def show_messages_menu(update: Update, context: CallbackContext) -> int:
    # Define valid choices for the Messages Menu
    valid_choices = {
        "💬 Contact Admin",
        "🔙 Back to Main Menu",
    }

    # Display the Messages Menu
    await update.message.reply_text(
        "<b>💬 Messages Menu</b>\n\n"
        "Stay connected and get the assistance you need. Choose an option below:\n\n"
        "💬 <b>Contact Admin:</b> Reach out to our support team for inquiries or assistance.\n\n"
        "🔙 <b>Back to Main Menu:</b> Return to the main dashboard to explore other options.\n\n"
        "Choose an action to proceed:",
        reply_markup=ReplyKeyboardMarkup([
            ["💬 Contact Admin", "🔙 Back to Main Menu"],
        ], resize_keyboard=True),
        parse_mode="HTML"
    )
    return MESSAGES_MENU  # Transition to the messages menu state


# Skill Assessments Submenu
async def show_skill_assessments_menu(update: Update, context: CallbackContext) -> int:
    # Define valid choices for the Skill Assessments Menu
    valid_choices = {
        "🤝🏾 Hired",
        "📋 Shortlisted",
        "🙅🏾‍♂️️ Rejected",
        "🔙 Back to Main Menu",
    }

    # Display the Skill Assessments Menu
    await update.message.reply_text(
        "<b>📜 Application History</b>\n\n"
        "Access a complete history of your application outcomes. Select an option below to review:\n\n"
        "🤝🏾 <b>Hired:</b> View the jobs where you were successfully hired.\n\n"
        "📋 <b>Shortlisted:</b> Check the jobs where you made it to the shortlist.\n\n"
        "🙅🏾‍♂️ <b>Rejected:</b> Review the jobs where your application was unsuccessful.\n\n"
        "🔙 <b>Back to Main Menu:</b> Return to the main dashboard.\n\n"
        "Choose an action to proceed:",
        reply_markup=ReplyKeyboardMarkup([
            ["🤝🏾 Hired", "📋 Shortlisted"],
            ["🙅🏾‍♂️ Rejected", "🔙 Back to Main Menu"]
        ], resize_keyboard=True),
        parse_mode="HTML"
    )
    return SKILL_ASSESSMENTS_MENU  # Transition to the skill assessments menu state


# Settings Submenu
async def show_settings_menu(update: Update, context: CallbackContext) -> int:
    # Define valid choices for the Settings Menu
    valid_choices = {
        "🔒 Privacy Settings",
        "🔙 Back to Main Menu",
    }

    # Display the Settings Menu
    await update.message.reply_text(
        "<b>⚙️ Settings Menu</b>\n\n"
        "Control your visibility and manage privacy preferences for your profile. Select an option below:\n\n"
        "🔒 <b>Privacy Settings:</b> Decide who can view your profile:\n"
        "• <b>Opt Out:</b> Only employers you've applied to can see your profile.\n"
        "• <b>Stay Visible:</b> All employers can view your profile.\n\n"
        "🔙 <b>Back to Main Menu:</b> Return to your dashboard.\n\n"
        "Choose an action to proceed:",
        reply_markup=ReplyKeyboardMarkup([
            ["🔒 Privacy Settings", "🔙 Back to Main Menu"],
        ], resize_keyboard=True),
        parse_mode="HTML"
    )
    return SETTINGS_MENU  # Transition to the settings menu state


# Help & Support Submenu
async def show_help_support_menu(update: Update, context: CallbackContext) -> int:
    # Define valid choices for the Help & Support Menu
    valid_choices = {
        "❓ FAQs",
        "📞 Contact Support",
        "🔙 Back to Main Menu",
    }

    # Display the Help & Support Menu
    await update.message.reply_text(
        "<b>📞 Help & Support Menu</b>\n\n"
        "We are here to assist you. Choose an option below for help:\n\n"
        "❓ <b>FAQs:</b> Browse frequently asked questions to find quick answers.\n\n"
        "📞 <b>Contact Support:</b> Reach out to our support team for personalized assistance.\n\n"
        "🔙 <b>Back to Main Menu:</b> Return to your dashboard.\n\n"
        "Select an option to proceed:",
        reply_markup=ReplyKeyboardMarkup([
            ["❓ FAQs", "📞 Contact Support"],
            ["🔙 Back to Main Menu"]
        ], resize_keyboard=True),
        parse_mode="HTML"
    )
    return HELP_SUPPORT_MENU  # Transition to the Help & Support menu state


# Job Search Submenu Handler
async def handle_job_search_menu_choice(update: Update, context: CallbackContext) -> int:
    choice = update.message.text

    if choice == "🌍 By Location":
        return await handle_search_jobs_by_location(update, context)

    elif choice == "🏭 By Industry":
        return await handle_search_jobs_by_industry(update, context)

    elif choice == "🛠️ Filter by Job Type":
        return await handle_filter_jobs_by_type(update, context)

    elif choice == "🆕 Recently Posted":
        return await handle_recently_posted_jobs(update, context)

    elif choice == "💾 Saved Jobs":
        return await show_saved_jobs(update, context)

    elif choice == "🔙 Back to Main Menu":
        return await show_applicant_main_menu(update, context)

    else:
        # If the choice is invalid, show the main menu buttons again
        await update.message.reply_text(
            "⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button:",
            reply_markup=ReplyKeyboardMarkup(
                [
                ["🌍 By Location", "🏭 By Industry"],
                ["🛠️ Filter by Job Type", "🆕 Recently Posted"],
                ["💾 Saved Jobs", "🔙 Back to Main Menu"]
            ], resize_keyboard=True)
        )
        return JOB_SEARCH_MENU


# My Profile Submenu Handler
async def handle_my_profile_menu_choice(update: Update, context: CallbackContext) -> int:
    choice = update.message.text

    if choice == "🧑🏿‍🎓 View Profile":
        return await handle_view_profile(update, context)

    elif choice == "➕🪪 Add Profile":
        return await handle_edit_applicant_profile(update, context)

    elif choice == "📄 Upload Resume/CV":
        return await handle_upload_resume(update, context)

    elif choice == "🔙 Back to Main Menu":
        return await show_applicant_main_menu(update, context)

    else:
        # If the choice is invalid, show the main menu buttons again
        await update.message.reply_text(
            "⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button:",
            reply_markup=ReplyKeyboardMarkup(
                [
                ["➕🪪 Add Profile", "🧑🏿‍🎓 View Profile"],
                ["📄 Upload Resume/CV", "🔙 Back to Main Menu"],
            ], resize_keyboard=True)
        )
        return MY_PROFILE_MENU

# Applications Submenu Handler
async def handle_applications_menu_choice(update: Update, context: CallbackContext) -> int:
    choice = update.message.text

    if choice == "📄 Active Applications":
        return await handle_active_applications(update, context)

    elif choice == "⚡ Application Status":
        return await handle_application_status(update, context)

    elif choice == "🗂️ History of Applied Jobs":
        return await handle_applied_jobs_history(update, context)

    elif choice == "💾 Saved Drafts":
        return await handle_saved_drafts(update, context)

    elif choice == "🔙 Back to Main Menu":
        return await show_applicant_main_menu(update, context)

    else:
        # If the choice is invalid, show the main menu buttons again
        await update.message.reply_text(
            "⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button:",
            reply_markup=ReplyKeyboardMarkup(
                [
                ["📄 Active Applications", "⚡ Application Status"],
                ["🗂️ History of Applied Jobs", "💾 Saved Drafts"],
                ["🔙 Back to Main Menu"]
            ], resize_keyboard=True)
        )
        return APPLICATIONS_MENU



# Job Alerts Submenu Handler
async def handle_job_alerts_menu_choice(update: Update, context: CallbackContext) -> int:
    choice = update.message.text

    if choice == "📢 Set Job Alerts":
        return await handle_set_job_alerts(update, context)

    elif choice == "⚙️ Manage Job Alerts":
        return await handle_manage_job_alerts(update, context)

    elif choice == "🗂️ View Alert History":
        return await handle_view_alert_history(update, context)

    elif choice == "🔙 Back to Main Menu":
        return await show_applicant_main_menu(update, context)


    else:
        # If the choice is invalid, show the main menu buttons again
        await update.message.reply_text(
            "⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button:",
            reply_markup=ReplyKeyboardMarkup(
                [
                ["📢 Set Job Alerts", "⚙️ Manage Job Alerts"],
                ["🗂️ View Alert History", "🔙 Back to Main Menu"]
            ], resize_keyboard=True)
        )
        return JOB_ALERTS_MENU



# Messages Submenu Handler
async def handle_messages_menu_choice(update: Update, context: CallbackContext) -> int:
    choice = update.message.text

    if choice == "💬 Contact Admin":
        return await contact_admin_applicant(update, context)

    elif choice == "🔙 Back to Main Menu":
        return await show_applicant_main_menu(update, context)


    else:
        # If the choice is invalid, show the main menu buttons again
        await update.message.reply_text(
            "⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button:",
            reply_markup=ReplyKeyboardMarkup(
                [
                ["💬 Contact Admin", "🔙 Back to Main Menu"],
            ], resize_keyboard=True)
        )
        return MESSAGES_MENU


# Skill Assessments Submenu Handler
async def handle_skill_assessments_menu_choice(update: Update, context: CallbackContext) -> int:
    choice = update.message.text

    if choice == "🤝🏾 Hired":
        return await handle_take_new_assessment(update, context)

    elif choice == "📋 Shortlisted":
        return await handle_view_completed_assessments(update, context)

    elif choice == "🙅🏾‍♂️ Rejected":
        return await handle_view_badges_certifications(update, context)

    elif choice == "🔙 Back to Main Menu":
        return await show_applicant_main_menu(update, context)


    else:
        # If the choice is invalid, show the main menu buttons again
        await update.message.reply_text(
            "⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button:",
            reply_markup=ReplyKeyboardMarkup(
                [
                ["🤝🏾 Hired", "📋 Shortlisted"],
                ["🙅🏾‍♂️️ Rejected", "🔙 Back to Main Menu"]
            ], resize_keyboard=True)
        )
        return SKILL_ASSESSMENTS_MENU


# Settings Submenu Handler
from telegram import Update, ReplyKeyboardRemove, ReplyKeyboardMarkup
from telegram.ext import CallbackContext

# Settings Menu Handler
async def handle_settings_menu_choice(update: Update, context: CallbackContext) -> int:
    choice = update.message.text


    if choice == "🔒 Privacy Settings":
        return await handle_privacy_settings(update, context)


    elif choice == "🔙 Back to Main Menu":
        return await show_applicant_main_menu(update, context)


    else:
        # If the choice is invalid, show the main menu buttons again
        await update.message.reply_text(
            "⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button:",
            reply_markup=ReplyKeyboardMarkup(
                [
                ["🔒 Privacy Settings", "🔙 Back to Main Menu"],
            ], resize_keyboard=True)
        )
        return SETTINGS_MENU



# Help & Support Submenu Handler
async def handle_help_support_menu_choice(update: Update, context: CallbackContext) -> int:
    choice = update.message.text

    if choice == "❓ FAQs":
        return await handle_faqs(update, context)

    elif choice == "📞 Contact Support":
        return await handle_contact_support(update, context)

    elif choice == "🔙 Back to Main Menu":
        return await show_applicant_main_menu(update, context)


    else:
        # If the choice is invalid, show the main menu buttons again
        await update.message.reply_text(
            "⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button:",
            reply_markup=ReplyKeyboardMarkup(

                [
                ["❓ FAQs", "📞 Contact Support"],
                ["🔙 Back to Main Menu"]
            ], resize_keyboard=True)
        )
        return HELP_SUPPORT_MENU


async def handle_search_jobs_by_location(update: Update, context: CallbackContext) -> int:
    """
    Fetch and display cities dynamically from the database for job search by location.
    """
    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432",
        )
        cursor = conn.cursor()

        # Fetch cities from the database
        cursor.execute("SELECT city_name FROM locations ORDER BY city_name ASC;")
        cities = [row[0] for row in cursor.fetchall()]

        if not cities:
            # No cities found in the database
            await update.message.reply_text("No cities are available for job search.")
            return JOB_SEARCH_MENU  # Return to the main job search menu

        # Save valid cities to context for validation
        context.user_data["valid_cities"] = cities

        # Prepare keyboard buttons (2 columns per row)
        city_buttons = [cities[i:i+2] for i in range(0, len(cities), 2)]
        city_buttons.append(["Back to Job Search Menu"])  # Add a "Back" button

        # Create the reply markup with location buttons
        reply_markup = ReplyKeyboardMarkup(city_buttons, resize_keyboard=True)

        # Send the location selection prompt
        await update.message.reply_text(
            "Please select the location you'd like to search for jobs:",
            reply_markup=reply_markup
        )
        return SEARCH_JOBS_BY_LOCATION  # State to capture location input

    except (Exception, psycopg2.DatabaseError) as error:
        # Log and handle any database errors
        logger.error(f"Database error while fetching cities: {error}")
        await update.message.reply_text(
            "An error occurred while fetching locations. Please try again later."
        )
        return JOB_SEARCH_MENU  # Return to the main job search menu

    finally:
        # Close the database connection
        if conn:
            cursor.close()
            conn.close()


from telegram import InlineKeyboardButton, InlineKeyboardMarkup
import re
from datetime import date

# Function to escape special characters for MarkdownV2
def escape_markdown_v2(text):
    return re.sub(r'([_\*\[\]\(\)~`>#+\-=|{}.!])', r'\\\1', str(text))

async def process_location_input(update: Update, context: CallbackContext) -> int:
    location_city = update.message.text.strip()  # Get the selected location city

    # Handle "Back to Job Search Menu" explicitly
    if location_city == "Back to Job Search Menu":
        return await show_job_search_menu(update, context)  # Navigate back to the job search menu

    # Validate the input against the list of valid cities
    valid_cities = context.user_data.get("valid_cities", [])
    if location_city not in valid_cities:
        # If input is invalid, prompt the user to select only from the list
        await update.message.reply_text(
            "⚠️ Invalid selection. Please choose a location from the provided list.",
            reply_markup=ReplyKeyboardMarkup(
                [[city for city in valid_cities[i:i + 2]] for i in range(0, len(valid_cities), 2)] + [
                    ["Back to Job Search Menu"]],
                resize_keyboard=True
            )
        )
        return SEARCH_JOBS_BY_LOCATION  # Stay in the same state for valid input

    try:
        # Connect to the PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch only opened jobs based on the provided location from the job_posts table
        cursor.execute('''
            SELECT 
                jp.job_id,  -- Include job_id to use in the apply button
                jp.job_title,
                jp.job_site, 
                jp.job_type,
                jp.job_sector,
                jp.location_country,
                jp.location_city,
                jp.salary_compensation,
                jp.job_description,
                cp.company_name,
                jp.education_qualification,
                jp.experience_level,
                jp.applicant_gender,
                jp.job_application_deadline,
                jp.vacancy_number,
                jp.compensation_type,  -- Add compensation type
                jp.currency_type,      -- Add currency type
                cp.is_verified         -- Verification status
            FROM 
                job_posts jp
            JOIN 
                company_profiles cp ON jp.user_id = cp.user_id  -- Adjust based on your foreign key
            JOIN 
                job_status js ON jp.status_id = js.status_id  -- Join with job_status table
            WHERE 
                jp.location_city = %s AND js.status_name = 'opened'  -- Filter for opened jobs
        ''', (location_city,))

        jobs = cursor.fetchall()

        if jobs:
            for job in jobs:
                job_id = job[0]
                company_name = job[9]
                is_verified = job[17]

                # Gender icon
                gender_icon = {"Male": "♂️", "Female": "♀️"}.get(job[12], "⚥")  # General icon for undefined

                # Salary/compensation summary
                if job[7]:  # salary_compensation exists
                    salary_compensation = job[7]
                    if float(salary_compensation).is_integer():
                        salary_compensation = int(salary_compensation)
                    salary_compensation_summary = f"{salary_compensation} {job[16]} {job[15]}"
                else:
                    salary_compensation_summary = f"{job[16]} {job[15]}"

                # Convert date fields to strings if necessary
                job_application_deadline = job[13]
                if isinstance(job_application_deadline, date):
                    job_application_deadline = job_application_deadline.strftime('%Y-%m-%d')

                # Construct the job summary with escaped text
                job_summary = (
                    f"🏷️ *Job Title:* {escape_markdown_v2(job[1])}\n\n"
                    f"🕒 *Job Type:* {escape_markdown_v2(job[2])}, {escape_markdown_v2(job[3])}\n\n"
                    f"🏢 *Job Sector:* {escape_markdown_v2(job[4])}\n\n"
                    f"📍 *Work Location:* {escape_markdown_v2(job[6])}, {escape_markdown_v2(job[5])}\n\n"
                    f"🎓 *Education Qualification:* {escape_markdown_v2(job[10])}\n\n"
                    f"🎖️ *Experience Level:* {escape_markdown_v2(job[11])}\n\n"
                    f"💰 *Salary/Compensation:* {escape_markdown_v2(salary_compensation_summary)}\n\n"
                    f"👥 *Vacancy Number:* {escape_markdown_v2(str(job[14]))}\n\n"
                    f"{gender_icon} *Applicant Gender:* {escape_markdown_v2(job[12])}\n\n"
                    f"⏳ *Job Application Deadline:* {escape_markdown_v2(job_application_deadline)}\n\n"
                    f"📄 *Job Description:*\n{escape_markdown_v2(job[8])}"
                )

                # Add verified company section at the bottom if the company is verified
                if is_verified:
                    verified_company_section = (
                        f"\n\n{'\\_' * 30}\n\n*{escape_markdown_v2(company_name)}*\n✅ Verified Company\n\u200B\n\u200B\n\n"
                    )
                    job_summary += verified_company_section

                # Create inline buttons for applying and saving
                apply_button = InlineKeyboardButton("Apply",
                                                    url=f"https://t.me/{context.bot.username}?start=apply_{job_id}")
                save_button = InlineKeyboardButton("Save", callback_data=f"save:{job_id}")
                reply_markup = InlineKeyboardMarkup([[apply_button, save_button]])

                # Send each job summary with the corresponding buttons
                await update.message.reply_text(job_summary, reply_markup=reply_markup, parse_mode='MarkdownV2')

        else:
            await update.message.reply_text(f"No opened jobs found in {location_city}.")

    except psycopg2.Error as db_error:
        logger.error(f"Database error: {db_error}")
        await update.message.reply_text("An error occurred while searching for jobs. Please try again later.")

    except Exception as general_error:
        logger.error(f"General error: {general_error}")
        await update.message.reply_text("An unexpected error occurred. Please try again later.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return await show_job_search_menu(update, context)


async def handle_search_jobs_by_industry(update: Update, context: CallbackContext) -> int:
    """
    Fetch and display industries dynamically from the database for job search.
    """
    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch industry categories from the job_categories table
        cursor.execute("SELECT category_name FROM job_categories WHERE is_active = true ORDER BY category_name ASC;")
        industries = [row[0] for row in cursor.fetchall()]

        if not industries:
            # No industries found in the database
            await update.message.reply_text("No industries are available for job search.")
            return JOB_SEARCH_MENU  # Return to the main job search menu

        # Save valid industries to context for validation
        context.user_data["valid_industries"] = industries

        # Prepare keyboard buttons (1 column per row)
        industry_buttons = [[industry] for industry in industries]
        industry_buttons.append(["Back to Job Search Menu"])  # Add a "Back" button

        # Create the reply markup with industry buttons
        reply_markup = ReplyKeyboardMarkup(industry_buttons, resize_keyboard=True)

        # Send the industry selection prompt
        await update.message.reply_text(
            "Please select an industry to search for jobs:",
            reply_markup=reply_markup
        )
        return SEARCH_JOBS_BY_INDUSTRY  # State to capture industry input

    except (Exception, psycopg2.DatabaseError) as error:
        # Log and handle any database errors
        logger.error(f"Database error while fetching industries: {error}")
        await update.message.reply_text(
            "An error occurred while fetching industries. Please try again later."
        )
        return JOB_SEARCH_MENU  # Return to the main job search menu

    finally:
        # Close the database connection
        if conn:
            cursor.close()
            conn.close()

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
import re
from datetime import date

# Function to escape special characters for MarkdownV2
def escape_markdown_v2(text):
    return re.sub(r'([_\*\[\]\(\)~`>#+\-=|{}.!])', r'\\\1', str(text))

async def process_industry_input(update: Update, context: CallbackContext) -> int:
    selected_industry = update.message.text.strip()  # Get the selected industry

    # Handle "Back to Job Search Menu" explicitly
    if selected_industry == "Back to Job Search Menu":
        return await show_job_search_menu(update, context)  # Navigate back to the main job search menu

    # Validate the input against the list of valid industries
    valid_industries = context.user_data.get("valid_industries", [])
    if selected_industry not in valid_industries:
        # If input is invalid, prompt the user to select only from the list
        await update.message.reply_text(
            "⚠️ Invalid selection. Please choose an industry from the provided list.",
            reply_markup=ReplyKeyboardMarkup(
                [[industry] for industry in valid_industries] + [["Back to Job Search Menu"]],
                resize_keyboard=True
            )
        )
        return SEARCH_JOBS_BY_INDUSTRY  # Stay in the same state

    try:
        # Connect to the PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch jobs based on the provided industry from the job_posts table
        cursor.execute('''
            SELECT 
                jp.job_id,  -- Include job_id to use in the apply button
                jp.job_title,
                jp.job_site, 
                jp.job_type,
                jp.job_sector,  -- Fetch job sector
                jp.location_country,
                jp.location_city,
                jp.salary_compensation,
                jp.job_description,
                cp.company_name,
                jp.education_qualification,
                jp.experience_level,
                jp.applicant_gender,
                jp.job_application_deadline,
                jp.vacancy_number,
                jp.compensation_type,  -- Add compensation type
                jp.currency_type,      -- Add currency type
                cp.is_verified         -- Verification status
            FROM 
                job_posts jp
            JOIN 
                company_profiles cp ON jp.user_id = cp.user_id  -- Adjust based on your foreign key
            JOIN 
                job_status js ON jp.status_id = js.status_id  -- Join with job_status table
            WHERE 
                jp.job_sector = %s AND js.status_name = 'opened'  -- Filter for the selected industry and opened jobs
        ''', (selected_industry,))

        jobs = cursor.fetchall()

        if jobs:
            for job in jobs:
                job_id = job[0]
                company_name = job[9]
                is_verified = job[17]

                # Gender icon
                gender_icon = {"Male": "♂️", "Female": "♀️"}.get(job[12], "⚥")  # General icon for undefined

                # Salary/compensation summary
                if job[7]:  # salary_compensation exists
                    salary_compensation = job[7]
                    if float(salary_compensation).is_integer():
                        salary_compensation = int(salary_compensation)
                    salary_compensation_summary = f"{salary_compensation} {job[16]} {job[15]}"
                else:
                    salary_compensation_summary = f"{job[16]} {job[15]}"

                # Convert date fields to strings if necessary
                job_application_deadline = job[13]
                if isinstance(job_application_deadline, date):
                    job_application_deadline = job_application_deadline.strftime('%Y-%m-%d')

                # Construct the job summary with escaped text
                job_summary = (
                    f"🏷️ *Job Title:* {escape_markdown_v2(job[1])}\n\n"
                    f"🕒 *Job Type:* {escape_markdown_v2(job[2])}, {escape_markdown_v2(job[3])}\n\n"
                    f"🏢 *Job Sector:* {escape_markdown_v2(job[4])}\n\n"
                    f"📍 *Work Location:* {escape_markdown_v2(job[6])}, {escape_markdown_v2(job[5])}\n\n"
                    f"🎓 *Education Qualification:* {escape_markdown_v2(job[10])}\n\n"
                    f"🎖️ *Experience Level:* {escape_markdown_v2(job[11])}\n\n"
                    f"💰 *Salary/Compensation:* {escape_markdown_v2(salary_compensation_summary)}\n\n"
                    f"👥 *Vacancy Number:* {escape_markdown_v2(str(job[14]))}\n\n"
                    f"{gender_icon} *Applicant Gender:* {escape_markdown_v2(job[12])}\n\n"
                    f"⏳ *Job Application Deadline:* {escape_markdown_v2(job_application_deadline)}\n\n"
                    f"📄 *Job Description:*\n{escape_markdown_v2(job[8])}"
                )

                # Add verified company section at the bottom if the company is verified
                if is_verified:
                    verified_company_section = (
                        f"\n\n{'\\_' * 30}\n\n*{escape_markdown_v2(company_name)}*\n✅ Verified Company\n\u200B\n\u200B\n\n"
                    )
                    job_summary += verified_company_section

                # Create inline buttons for applying and saving
                apply_button = InlineKeyboardButton("Apply",
                                                    url=f"https://t.me/{context.bot.username}?start=apply_{job_id}")
                save_button = InlineKeyboardButton("Save", callback_data=f"save:{job_id}")
                reply_markup = InlineKeyboardMarkup([[apply_button, save_button]])

                # Send each job summary with the corresponding buttons
                await update.message.reply_text(job_summary, reply_markup=reply_markup, parse_mode='MarkdownV2')

        else:
            await update.message.reply_text(f"No opened jobs found in the industry: {selected_industry}.")

    except psycopg2.Error as db_error:
        logger.error(f"Database error: {db_error}")
        await update.message.reply_text("An error occurred while searching for jobs. Please try again later.")

    except Exception as general_error:
        logger.error(f"General error: {general_error}")
        await update.message.reply_text("An unexpected error occurred. Please try again later.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return await show_job_search_menu(update, context)


async def handle_filter_jobs_by_type(update: Update, context: CallbackContext) -> int:
    """
    Fetch and display job types dynamically from the database for filtering.
    """
    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch job types from the job_types table
        cursor.execute("SELECT job_type_name FROM job_types ORDER BY job_type_name ASC;")
        job_types = [row[0] for row in cursor.fetchall()]

        if not job_types:
            # No job types found in the database
            await update.message.reply_text("No job types are available.")
            return JOB_SEARCH_MENU  # Return to the main job search menu

        # Save valid job types to context for validation
        context.user_data["valid_job_types"] = job_types

        # Prepare keyboard buttons (2 columns per row)
        job_type_buttons = [job_types[i:i + 2] for i in range(0, len(job_types), 2)]
        job_type_buttons.append(["Back"])  # Add a "Back" button in its own row

        # Create the reply markup with job type buttons
        reply_markup = ReplyKeyboardMarkup(job_type_buttons, resize_keyboard=True)

        # Send the job type selection prompt
        await update.message.reply_text(
            "Please select a job type:",
            reply_markup=reply_markup
        )
        return FILTER_JOBS_BY_TYPE  # State to capture job type input

    except (Exception, psycopg2.DatabaseError) as error:
        # Log and handle any database errors
        logger.error(f"Database error while fetching job types: {error}")
        await update.message.reply_text(
            "An error occurred while fetching job types. Please try again later."
        )
        return JOB_SEARCH_MENU  # Return to the main job search menu

    finally:
        # Close the database connection
        if conn:
            cursor.close()
            conn.close()



from telegram import InlineKeyboardButton, InlineKeyboardMarkup
import re
from datetime import date

# Function to escape special characters for MarkdownV2
def escape_markdown_v2(text):
    return re.sub(r'([_\*\[\]\(\)~`>#+\-=|{}.!])', r'\\\1', str(text))

async def process_job_type_input(update: Update, context: CallbackContext) -> int:
    selected_job_type = update.message.text.strip()  # Get the selected job type

    # Retrieve valid job types from context for validation
    valid_job_types = context.user_data.get("valid_job_types", [])

    # Check if the user selected "Back" to navigate back
    if selected_job_type == "Back":
        return await show_job_search_menu(update, context)  # Redirect to the job search menu

    # Validate the selected job type
    if selected_job_type not in valid_job_types:
        await update.message.reply_text(
            "⚠️ Invalid selection. Please choose a valid job type from the provided list."
        )
        return FILTER_JOBS_BY_TYPE  # Prompt the user to select again
    try:
        # Connect to the PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch jobs based on the provided job type from the job_posts table
        cursor.execute('''
            SELECT 
                jp.job_id,  -- Include job_id to use in the apply button
                jp.job_title,
                jp.job_site, 
                jp.job_type,
                jp.job_sector,
                jp.location_country,
                jp.location_city,
                jp.salary_compensation,
                jp.job_description,
                cp.company_name,
                jp.education_qualification,
                jp.experience_level,
                jp.applicant_gender,
                jp.job_application_deadline,
                jp.vacancy_number,
                jp.compensation_type,  -- Add compensation type
                jp.currency_type,      -- Add currency type
                cp.is_verified         -- Verification status
            FROM 
                job_posts jp
            JOIN 
                company_profiles cp ON jp.user_id = cp.user_id  -- Adjust based on your foreign key
            JOIN 
                job_status js ON jp.status_id = js.status_id  -- Join with job_status table
            WHERE 
                (jp.job_site = %s OR jp.job_type = %s) 
                AND js.status_name = 'opened'
        ''', (selected_job_type, selected_job_type))

        jobs = cursor.fetchall()

        if jobs:
            for job in jobs:
                job_id = job[0]
                company_name = job[9]
                is_verified = job[17]

                # Gender icon
                gender_icon = {"Male": "♂️", "Female": "♀️"}.get(job[12], "⚥")  # General icon for undefined

                # Salary/compensation summary
                if job[7]:  # salary_compensation exists
                    salary_compensation = job[7]
                    if float(salary_compensation).is_integer():
                        salary_compensation = int(salary_compensation)
                    salary_compensation_summary = f"{salary_compensation} {job[16]} {job[15]}"
                else:
                    salary_compensation_summary = f"{job[16]} {job[15]}"

                # Convert date fields to strings if necessary
                job_application_deadline = job[13]
                if isinstance(job_application_deadline, date):
                    job_application_deadline = job_application_deadline.strftime('%Y-%m-%d')

                # Construct the job summary with escaped text
                job_summary = (
                    f"🏷️ *Job Title:* {escape_markdown_v2(job[1])}\n\n"
                    f"🕒 *Job Type:* {escape_markdown_v2(job[2])}, {escape_markdown_v2(job[3])}\n\n"
                    f"🏢 *Job Sector:* {escape_markdown_v2(job[4])}\n\n"
                    f"📍 *Work Location:* {escape_markdown_v2(job[6])}, {escape_markdown_v2(job[5])}\n\n"
                    f"🎓 *Education Qualification:* {escape_markdown_v2(job[10])}\n\n"
                    f"🎖️ *Experience Level:* {escape_markdown_v2(job[11])}\n\n"
                    f"💰 *Salary/Compensation:* {escape_markdown_v2(salary_compensation_summary)}\n\n"
                    f"👥 *Vacancy Number:* {escape_markdown_v2(str(job[14]))}\n\n"
                    f"{gender_icon} *Applicant Gender:* {escape_markdown_v2(job[12])}\n\n"
                    f"⏳ *Job Application Deadline:* {escape_markdown_v2(job_application_deadline)}\n\n"
                    f"📄 *Job Description:*\n{escape_markdown_v2(job[8])}"
                )

                # Add verified company section at the bottom if the company is verified
                if is_verified:
                    verified_company_section = (
                        f"\n\n{'\\_' * 30}\n\n*{escape_markdown_v2(company_name)}*\n✅ Verified Company\n\u200B\n\u200B\n\n"
                    )
                    job_summary += verified_company_section

                # Create inline buttons for applying and saving
                apply_button = InlineKeyboardButton("Apply",
                                                    url=f"https://t.me/{context.bot.username}?start=apply_{job_id}")
                save_button = InlineKeyboardButton("Save", callback_data=f"save:{job_id}")
                reply_markup = InlineKeyboardMarkup([[apply_button, save_button]])

                # Send each job summary with the corresponding buttons
                await update.message.reply_text(job_summary, reply_markup=reply_markup, parse_mode='MarkdownV2')

        else:
            await update.message.reply_text(f"No opened jobs found for the job type: {selected_job_type}.")

    except psycopg2.Error as db_error:
        logger.error(f"Database error: {db_error}")
        await update.message.reply_text("An error occurred while searching for jobs. Please try again later.")

    except Exception as general_error:
        logger.error(f"General error: {general_error}")
        await update.message.reply_text("An unexpected error occurred. Please try again later.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return await show_job_search_menu(update, context)


from telegram import InlineKeyboardButton, InlineKeyboardMarkup
import re
from datetime import date

# Function to escape special characters for MarkdownV2
def escape_markdown_v2(text):
    return re.sub(r'([_\*\[\]\(\)~`>#+\-=|{}.!])', r'\\\1', str(text))

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
import re
from datetime import date

# Function to escape special characters for MarkdownV2
def escape_markdown_v2(text):
    return re.sub(r'([_\*\[\]\(\)~`>#+\-=|{}.!])', r'\\\1', str(text))

async def handle_recently_posted_jobs(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text("Displaying recently posted jobs...")

    try:
        # Connect to the PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch recently opened jobs, ordering by created_at timestamp
        cursor.execute('''
            SELECT 
                jp.job_id, 
                jp.job_title, 
                jp.job_site, 
                jp.job_type, 
                jp.job_sector, 
                jp.location_country, 
                jp.location_city, 
                jp.salary_compensation, 
                jp.job_description, 
                cp.company_name, 
                jp.education_qualification, 
                jp.experience_level, 
                jp.applicant_gender, 
                jp.job_application_deadline, 
                jp.vacancy_number, 
                jp.compensation_type, 
                jp.currency_type,
                cp.is_verified  -- Verification status
            FROM 
                job_posts jp
            JOIN 
                company_profiles cp ON jp.user_id = cp.user_id
            JOIN 
                job_status js ON jp.status_id = js.status_id
            WHERE 
                js.status_name = 'opened'  -- Ensure the job is opened
            ORDER BY 
                jp.created_at DESC  -- Order by the created_at timestamp, most recent first
            LIMIT 10;  -- Adjust limit as needed
        ''')

        jobs = cursor.fetchall()
        job_summaries = []  # List to store job summaries

        if jobs:
            for job in jobs:
                job_id = job[0]
                company_name = job[9]
                is_verified = job[17]

                # Gender icon
                gender_icon = {"Male": "♂️", "Female": "♀️"}.get(job[12], "⚥")  # General icon for undefined

                # Salary/compensation summary
                if job[7]:  # salary_compensation exists
                    salary_compensation = job[7]
                    if float(salary_compensation).is_integer():
                        salary_compensation = int(salary_compensation)
                    salary_compensation_summary = f"{salary_compensation} {job[16]} {job[15]}"
                else:
                    salary_compensation_summary = f"{job[16]} {job[15]}"

                # Convert date fields to strings if necessary
                job_application_deadline = job[13]
                if isinstance(job_application_deadline, date):
                    job_application_deadline = job_application_deadline.strftime('%Y-%m-%d')

                # Construct the job summary with escaped text
                job_summary = (
                    f"🏷️ *Job Title:* {escape_markdown_v2(job[1])}\n\n"
                    f"🕒 *Job Type:* {escape_markdown_v2(job[2])}, {escape_markdown_v2(job[3])}\n\n"
                    f"🏢 *Job Sector:* {escape_markdown_v2(job[4])}\n\n"
                    f"📍 *Work Location:* {escape_markdown_v2(job[6])}, {escape_markdown_v2(job[5])}\n\n"
                    f"🎓 *Education Qualification:* {escape_markdown_v2(job[10])}\n\n"
                    f"🎖️ *Experience Level:* {escape_markdown_v2(job[11])}\n\n"
                    f"💰 *Salary/Compensation:* {escape_markdown_v2(salary_compensation_summary)}\n\n"
                    f"👥 *Vacancy Number:* {escape_markdown_v2(str(job[14]))}\n\n"
                    f"{gender_icon} *Applicant Gender:* {escape_markdown_v2(job[12])}\n\n"
                    f"⏳ *Job Application Deadline:* {escape_markdown_v2(job_application_deadline)}\n\n"
                    f"📄 *Job Description:*\n{escape_markdown_v2(job[8])}"
                )

                # Add verified company section at the bottom if the company is verified
                if is_verified:
                    verified_company_section = (
                        f"\n\n{'\\_' * 30}\n\n*{escape_markdown_v2(company_name)}*\n✅ Verified Company\n\u200B\n\u200B\n\n"
                    )
                    job_summary += verified_company_section

                # Add summary to the list
                job_summaries.append((job_summary, job_id))

            # Reverse the job summaries to display the newest job at the bottom
            for job_summary, job_id in reversed(job_summaries):
                # Create inline buttons for applying and saving
                apply_button = InlineKeyboardButton("Apply",
                                                    url=f"https://t.me/{context.bot.username}?start=apply_{job_id}")
                save_button = InlineKeyboardButton("Save", callback_data=f"save:{job_id}")
                reply_markup = InlineKeyboardMarkup([[apply_button, save_button]])

                # Send each job summary with the corresponding buttons
                await update.message.reply_text(job_summary, reply_markup=reply_markup, parse_mode='MarkdownV2')

        else:
            await update.message.reply_text("No recently opened jobs found.")

    except psycopg2.Error as db_error:
        logger.error(f"Database error: {db_error}")
        await update.message.reply_text("An error occurred while searching for jobs. Please try again later.")

    except Exception as general_error:
        logger.error(f"General error: {general_error}")
        await update.message.reply_text("An unexpected error occurred. Please try again later.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return JOB_SEARCH_MENU  # Return back to Job Search Menu after showing results



from telegram.ext import CallbackQueryHandler


# Function to handle saving a job
async def save_job(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()  # Acknowledge the callback query

    job_id = query.data.split(":")[1]  # Extract job_id from callback data
    user_chat_id = update.effective_chat.id  # Get user chat ID

    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve the user ID based on the chat ID
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await query.edit_message_text("You are not registered. Please register before saving jobs.")
            return

        user_id = user_row[0]  # Get the user_id from the result

        # Insert into the saved_jobs table
        cursor.execute('''
            INSERT INTO saved_jobs (user_id, job_id)
            VALUES (%s, %s)
            ON CONFLICT (user_id, job_id) DO NOTHING;  -- Prevent duplicates
        ''', (user_id, job_id))

        conn.commit()  # Commit the transaction

        await query.edit_message_text("Job has been saved successfully!")

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error: {error}")
        await query.edit_message_text("An error occurred while saving the job. Please try again later.")

    finally:
        if conn:
            cursor.close()
            conn.close()


from telegram import InlineKeyboardButton, InlineKeyboardMarkup
import re
from datetime import date

# Function to escape special characters for MarkdownV2
def escape_markdown_v2(text):
    return re.sub(r'([_\*\[\]\(\)~`>#+\-=|{}.!])', r'\\\1', str(text))

async def show_saved_jobs(update: Update, context: CallbackContext) -> None:
    user_chat_id = update.effective_chat.id  # Get user chat ID

    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve saved jobs for the user
        cursor.execute('''
            SELECT 
                jp.job_id, 
                jp.job_title,
                jp.job_site, 
                jp.job_type, 
                jp.job_sector, 
                jp.location_country, 
                jp.location_city, 
                jp.salary_compensation, 
                jp.job_description, 
                cp.company_name, 
                jp.education_qualification, 
                jp.experience_level, 
                jp.applicant_gender, 
                jp.job_application_deadline, 
                jp.vacancy_number, 
                jp.compensation_type,  
                jp.currency_type,
                cp.is_verified  -- Verification status
            FROM saved_jobs sj
            JOIN job_posts jp ON sj.job_id = jp.job_id
            JOIN company_profiles cp ON jp.user_id = cp.user_id
            WHERE sj.user_id = (SELECT user_id FROM users WHERE contact = %s)
        ''', (str(user_chat_id),))

        saved_jobs = cursor.fetchall()

        if saved_jobs:
            for job in saved_jobs:
                job_id = job[0]
                company_name = job[9]
                is_verified = job[17]

                # Gender icon
                gender_icon = {"Male": "♂️", "Female": "♀️"}.get(job[12], "⚥")  # General icon for undefined

                # Salary/compensation summary
                if job[7]:  # salary_compensation exists
                    salary_compensation = job[7]
                    if float(salary_compensation).is_integer():
                        salary_compensation = int(salary_compensation)
                    salary_compensation_summary = f"{salary_compensation} {job[16]} {job[15]}"
                else:
                    salary_compensation_summary = f"{job[16]} {job[15]}"

                # Convert date fields to strings if necessary
                job_application_deadline = job[13]
                if isinstance(job_application_deadline, date):
                    job_application_deadline = job_application_deadline.strftime('%Y-%m-%d')

                # Construct the job summary with escaped text
                job_summary = (
                    f"🏷️ *Job Title:* {escape_markdown_v2(job[1])}\n\n"
                    f"🕒 *Job Type:* {escape_markdown_v2(job[2])}, {escape_markdown_v2(job[3])}\n\n"
                    f"🏢 *Job Sector:* {escape_markdown_v2(job[4])}\n\n"
                    f"📍 *Work Location:* {escape_markdown_v2(job[6])}, {escape_markdown_v2(job[5])}\n\n"
                    f"🎓 *Education Qualification:* {escape_markdown_v2(job[10])}\n\n"
                    f"🎖️ *Experience Level:* {escape_markdown_v2(job[11])}\n\n"
                    f"💰 *Salary/Compensation:* {escape_markdown_v2(salary_compensation_summary)}\n\n"
                    f"👥 *Vacancy Number:* {escape_markdown_v2(str(job[14]))}\n\n"
                    f"{gender_icon} *Applicant Gender:* {escape_markdown_v2(job[12])}\n\n"
                    f"⏳ *Job Application Deadline:* {escape_markdown_v2(job_application_deadline)}\n\n"
                    f"📄 *Job Description:*\n{escape_markdown_v2(job[8])}"
                )

                # Add verified company section at the bottom if the company is verified
                if is_verified:
                    verified_company_section = (
                        f"\n\n{'\\_' * 30}\n\n*{escape_markdown_v2(company_name)}*\n✅ Verified Company\n\u200B\n\u200B\n\n"
                    )
                    job_summary += verified_company_section

                # Create inline buttons for applying and removing the job
                apply_button = InlineKeyboardButton("Apply",
                                                    url=f"https://t.me/{context.bot.username}?start=apply_{job_id}")
                remove_button = InlineKeyboardButton("Remove", callback_data=f"remove:{job_id}")
                reply_markup = InlineKeyboardMarkup([[apply_button, remove_button]])

                # Send each job summary with the corresponding buttons
                await update.message.reply_text(job_summary, reply_markup=reply_markup, parse_mode='MarkdownV2')

        else:
            await update.message.reply_text("You have no saved jobs.")

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error: {error}")
        await update.message.reply_text("An error occurred while retrieving your saved jobs.")

    finally:
        if conn:
            cursor.close()
            conn.close()

async def remove_saved_job(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()  # Acknowledge the callback query

    job_id = query.data.split(":")[1]  # Extract job_id from callback data
    user_chat_id = update.effective_chat.id  # Get user chat ID

    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve the user ID based on the chat ID
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await query.edit_message_text("You are not registered. Please register before removing jobs.")
            return

        user_id = user_row[0]  # Get the user_id from the result

        # Remove the job from the saved_jobs table
        cursor.execute('''
            DELETE FROM saved_jobs 
            WHERE user_id = %s AND job_id = %s;
        ''', (user_id, job_id))

        conn.commit()  # Commit the transaction

        await query.edit_message_text("Job has been removed from your saved jobs successfully!")

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error: {error}")
        await query.edit_message_text("An error occurred while removing the job. Please try again later.")

    finally:
        if conn:
            cursor.close()
            conn.close()



async def handle_saved_jobs(update: Update, context: CallbackContext) -> int:
    # Logic for displaying saved jobs
    await update.message.reply_text("Here are your saved jobs:")
    # Display saved jobs from the database or context
    return JOB_SEARCH_MENU  # Return back to Job Search Menu after showing saved jobs

async def capture_location_input(update: Update, context: CallbackContext) -> int:
    location = update.message.text
    # Store the location in the user data or database
    context.user_data['location_search'] = location

    await update.message.reply_text(f"Searching jobs in {location}...")
    # You can add logic here to search jobs by location and display results

    return JOB_SEARCH_MENU  # Return to Job Search Menu after processing

async def capture_industry_input(update: Update, context: CallbackContext) -> int:
    industry = update.message.text
    # Store the industry in the user data or database
    context.user_data['industry_search'] = industry

    await update.message.reply_text(f"Searching jobs in the {industry} industry...")
    # You can add logic here to search jobs by industry and display results

    return JOB_SEARCH_MENU  # Return to Job Search Menu after processing

async def capture_job_type_input(update: Update, context: CallbackContext) -> int:
    job_type = update.message.text
    # Store the job type in the user data or database
    context.user_data['job_type_search'] = job_type

    await update.message.reply_text(f"Filtering jobs by {job_type}...")
    # You can add logic here to filter jobs by job type and display results

    return JOB_SEARCH_MENU  # Return to Job Search Menu after processing

import re
import logging
from datetime import datetime
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import CallbackContext, ConversationHandler
import psycopg2
from PIL import Image


def escape_markdown_v2(text):
    """Escapes special characters for Telegram's MarkdownV2 syntax."""
    if not isinstance(text, str):
        text = str(text)
    return re.sub(r'([_*[\]()~>#+\-=|{}.!])', r'\\\1', text)


def format_field(field, default='N/A'):
    """Formats field values and escapes MarkdownV2 special characters."""
    if field is None:
        return default
    if isinstance(field, datetime):
        return field.strftime('%Y-%m-%d')
    return escape_markdown_v2(str(field))


def process_field(field):
    """Handles both list and string fields dynamically."""
    if isinstance(field, list):
        return ", ".join(escape_markdown_v2(str(item)) for item in field)
    elif isinstance(field, str):
        return ", ".join(escape_markdown_v2(item.strip()) for item in field.split(","))
    return escape_markdown_v2(str(field).strip())


def resize_image(image_path, output_path, max_size=(300, 300)):
    """Resize the image to the given max size and save it to the output path."""
    with Image.open(image_path) as img:
        img.thumbnail(max_size)
        img.save(output_path, format="JPEG")


async def handle_view_profile(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        cursor.execute('SELECT user_id, gender FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return

        user_id, gender = user_row

        # Fetch applicant profile
        cursor.execute('''
            SELECT full_name, job_title, location, phone_number, email, experience_level, 
                   skills, employment_type, availability, work_experience, highest_degree, 
                   university, college, graduation_year, gpa, certifications, languages, 
                   portfolio_link, resume, profile_picture
            FROM applicant_profiles
            WHERE applicant_id = %s
        ''', (user_id,))
        profile_data = cursor.fetchone()

        if not profile_data:
            await update.message.reply_text("You do not have a profile yet.")
            return

        gender_icon = "👨🏾" if gender.strip().lower() == "male" else "👩🏾"

        # Profile summary
        profile_info = "\n\n*Personal Information*\n\n"
        profile_info += f"{gender_icon} *Full Name:* {format_field(profile_data[0])}\n\n"
        if profile_data[1]:  # Check if Job Title is not None or empty
            profile_info += f"🏷️ *Job Title:* {format_field(profile_data[1])}\n\n"
        profile_info += f"📍 *Location:* {format_field(profile_data[2])}\n\n"
        phone_number = profile_data[3]
        if phone_number and not phone_number.startswith("+"):
            phone_number = f"+{phone_number}"
        profile_info += f"📞 *Phone Number:* {format_field(phone_number)}\n\n"
        profile_info += f"✉️ *Email:* {format_field(profile_data[4])}\n"

        # Professional Overview
        professional_overview = "\n\n*Professional Overview*\n\n"
        if profile_data[5]:  # Experience Level
            professional_overview += f"🥇 *Experience Level:* {format_field(profile_data[5])}\n\n"
        if profile_data[6]:  # Skills
            professional_overview += f"🛠️ *Skills:* {process_field(profile_data[6])}\n\n"
        if profile_data[7]:  # Employment Type
            professional_overview += f"⏳ *Employment Type:* {format_field(profile_data[7])}\n\n"
        if profile_data[8]:  # Availability
            professional_overview += f"📅 *Availability:* {format_field(profile_data[8])}\n"

        if professional_overview.strip() != "*Professional Overview*":
            profile_info += professional_overview

        # Education
        education = "\n*Education*\n\n"
        if profile_data[10]:  # Highest Degree
            education += f"🎓 *Degrees:* {format_field(profile_data[10])}\n\n"
        if profile_data[11]:  # University
            education += f"🏫 *University:* {format_field(profile_data[11])}\n\n"
        if profile_data[12]:  # College
            education += f"🏛️ *College:* {format_field(profile_data[12])}\n\n"
        if profile_data[13]:  # Graduation Year
            education += f"📅 *Graduation Year:* {format_field(profile_data[13])}\n\n"
        if profile_data[14]:  # GPA
            education += f"📚 *GPA:* {format_field(profile_data[14])}\n"

        if education.strip() != "*Education*":
            profile_info += education

        # Certifications
        if profile_data[15]:  # Certifications
            profile_info += f"\n\n*Certifications*\n\n📜 {process_field(profile_data[15])}\n"

        # Languages
        if profile_data[16]:  # Languages
            profile_info += f"\n*Languages*\n\n🌐 {process_field(profile_data[16])}\n"

        # Portfolio Links
        if profile_data[17]:  # Portfolio Links
            formatted_links = "\n\n".join(f"🔗 {escape_markdown_v2(link.strip())}" for link in profile_data[17].split(","))
            profile_info += f"\n\n*Portfolio Links*\n\n{formatted_links}\n"

        # Uploaded Resume
        if profile_data[18]:  # Resume
            profile_info += "\n\n*Uploaded Resume*\n\n📄 *Resume:* Uploaded"

        # Resize and send profile picture
        if profile_data[19]:
            file_id = profile_data[19]
            sent_message = await context.bot.send_photo(
                chat_id=user_chat_id,
                photo=file_id,
                caption=profile_info,
                parse_mode='MarkdownV2'
            )
        else:
            await update.message.reply_text(profile_info, parse_mode='MarkdownV2')

    except (Exception, psycopg2.DatabaseError) as error:
        logging.error(f"Error fetching applicant profile: {error}")
        await update.message.reply_text("An error occurred while retrieving your profile.")
        return

    finally:
        if conn:
            cursor.close()
            conn.close()

    return



import logging
import psycopg2
from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import CallbackContext, ConversationHandler

# Callback handler for downloading the CV
async def handle_download_cv_profile(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    user_id = query.data.split("_")[-1]

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch the file ID of the resume
        cursor.execute('SELECT resume FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
        resume_row = cursor.fetchone()

        if not resume_row or not resume_row[0]:
            await query.answer("No CV available for download.", show_alert=True)
            return APPLICANT_MAIN_MENU

        resume_file_id = resume_row[0]

        # Send the file directly using the file ID
        await query.message.reply_document(
            document=resume_file_id,
            caption="Here is the uploaded CV.",
            reply_to_message_id=query.message.message_id
        )
        await query.answer()

    except Exception as e:
        logging.error(f"Error retrieving CV for user {user_id}: {e}")
        await query.message.reply_text("An error occurred while retrieving the CV.")
        return APPLICANT_MAIN_MENU

    finally:
        if conn:
            cursor.close()
            conn.close()

    return APPLICANT_MAIN_MENU

# Function to prompt the user to upload their resume or CV
async def handle_upload_resume(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please upload your resume or CV as a file (PDF, DOC, DOCX).",
        reply_markup=ReplyKeyboardMarkup([["Back"]], resize_keyboard=True)
    )
    return UPLOAD_RESUME  # A new state to handle the file upload

# Handle invalid inputs during the resume upload
async def handle_invalid_input(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "⚠️ Invalid input. Please upload your resume or CV as a file (PDF, DOC, DOCX).",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return UPLOAD_RESUME  # Stay in the same state

import psycopg2
import logging
from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import CallbackContext, ConversationHandler

# Function to handle the uploaded resume or CV file
async def save_uploaded_resume(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id

    if update.message.document:  # Check if the user uploaded a document
        document = update.message.document
        file_id = document.file_id
        file_name = document.file_name

        # Only allow specific file types (PDF, DOC, DOCX)
        if not file_name.lower().endswith(('.pdf', '.doc', '.docx')):
            await update.message.reply_text("Please upload a valid resume file (PDF, DOC, DOCX).")
            return UPLOAD_RESUME  # Stay in the same state for re-upload

        # Connect to the database to check for an existing resume
        try:
            conn = psycopg2.connect(
                dbname="my_project_db",
                user="postgres",
                password="1201",
                host="localhost",
                port="5432"
            )
            cursor = conn.cursor()

            # Fetch the user_id based on chat_id
            cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
            user_row = cursor.fetchone()

            if not user_row:
                await update.message.reply_text("You are not registered. Please register.")
                return

            user_id = user_row[0]

            # Check if a record exists in applicant_profiles for this user_id
            cursor.execute('SELECT 1 FROM applicant_profiles WHERE user_id = %s', (user_id,))
            record_exists = cursor.fetchone()

            if record_exists:
                # Update the resume in the applicant_profiles table
                cursor.execute('UPDATE applicant_profiles SET resume = %s WHERE user_id = %s', (file_id, user_id))
                logging.info(f"Updated resume for user_id {user_id} in applicant_profiles.")
            else:
                # Insert a new record into the applicant_profiles table
                cursor.execute('INSERT INTO applicant_profiles (user_id, resume) VALUES (%s, %s)', (user_id, file_id))
                logging.info(f"Inserted new resume for user_id {user_id} in applicant_profiles.")

            # Commit the changes
            conn.commit()
            logging.info("Commit successful for updating/adding resume in applicant_profiles.")

            # Notify the user that their resume has been uploaded
            await update.message.reply_text("✅ Your resume has been uploaded successfully.")

        except (Exception, psycopg2.DatabaseError) as error:
            logging.error(f"Error saving resume: {error}")
            await update.message.reply_text("An error occurred while saving your resume.")
        finally:
            if conn:
                cursor.close()
                conn.close()

        # Return to the profile menu
        return await show_profile_menu(update, context)

    else:
        # No document was uploaded, ask again
        await update.message.reply_text("❌ Please upload a valid file (PDF, DOC, DOCX).")
        return UPLOAD_RESUME  # Stay in the current state for re-upload


# Corrected function for handling "Back to Profile Menu"
async def show_profile_menu(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "You are now in your profile menu. Please select an option:",
        reply_markup=ReplyKeyboardMarkup([
            ["➕🪪 Add Profile", "🧑🏿‍🎓 View Profile"],
            ["📄 Upload Resume/CV", "🔙 Back to Main Menu"],
        ], resize_keyboard=True)
    )
    return MY_PROFILE_MENU  # Return to the correct state (MY_PROFILE_MENU)

from telegram import ReplyKeyboardMarkup
import logging
import psycopg2

# Function to handle the resume upload
async def handle_resume_upload(update: Update, context: CallbackContext) -> int:
    conn = None  # Initialize connection variable
    try:
        document = update.message.document
        file_id = document.file_id
        file_name = document.file_name

        # Log file upload start
        logging.debug(f"Received file: {file_name} with file_id: {file_id}")

        # Open a database connection
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Get user ID from the chat ID (mapping)
        user_chat_id = update.message.chat_id
        logging.debug(f"Updating resume file_id for user {user_chat_id} in the database.")

        # Fetch the user_id from the database
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return

        user_id = user_row[0]

        # Check if a record exists in applicant_profiles for this user_id
        cursor.execute('SELECT 1 FROM applicant_profiles WHERE user_id = %s', (user_id,))
        record_exists = cursor.fetchone()

        if record_exists:
            # Update the resume file_id in the applicant_profiles table
            cursor.execute('UPDATE applicant_profiles SET resume = %s WHERE user_id = %s', (file_id, user_id))
            logging.info(f"Updated resume file_id for user_id {user_id} in applicant_profiles.")
        else:
            # Insert a new record into the applicant_profiles table
            cursor.execute('INSERT INTO applicant_profiles (user_id, resume) VALUES (%s, %s)', (user_id, file_id))
            logging.info(f"Inserted new resume file_id for user_id {user_id} in applicant_profiles.")

        # Commit the changes
        conn.commit()
        logging.info("Commit successful for updating/adding resume file_id in applicant_profiles.")

        # Notify the user that their resume has been uploaded
        await update.message.reply_text("✔️ Your resume has been uploaded successfully.")

        # Return to the profile menu
        return await show_profile_menu(update, context)

    except Exception as e:
        logging.error(f"Error handling resume upload: {e}")
        await update.message.reply_text("An error occurred while uploading your resume. Please try again.")

        # Return to the profile menu even after an error
        return await show_profile_menu(update, context)

    finally:
        if conn:  # Ensure the connection is closed if it was opened
            conn.close()





# Function to handle managing certifications and portfolios
async def handle_manage_certifications(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please choose an option related to your certifications or portfolios:",
        reply_markup=ReplyKeyboardMarkup([
            ["Upload Certification", "View Certifications"],
            ["Upload Portfolio", "View Portfolios"],
            ["Back to Profile Menu"]
        ], resize_keyboard=True)
    )
    return MANAGE_CERTIFICATIONS  # A new state for managing certifications and portfolios

# Function to handle uploading a certification
async def handle_upload_certification(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text("Please upload your certification as a file.")
    return UPLOAD_CERTIFICATION  # New state for handling certification upload

# Function to handle viewing certifications
async def handle_view_certifications(update: Update, context: CallbackContext) -> int:
    # Example placeholder for viewing certifications
    await update.message.reply_text("Here are your certifications: (Display certifications here)")
    return MANAGE_CERTIFICATIONS  # Return to the certifications management menu

# Function to handle uploading a portfolio
async def handle_upload_portfolio(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text("Please upload your portfolio as a file.")
    return UPLOAD_PORTFOLIO  # New state for handling portfolio upload

# Function to handle viewing portfolios
async def handle_view_portfolios(update: Update, context: CallbackContext) -> int:
    # Example placeholder for viewing portfolios
    await update.message.reply_text("Here are your portfolios: (Display portfolios here)")
    return MANAGE_CERTIFICATIONS  # Return to the certifications management menu

# Function to handle receiving the uploaded certification file
async def receive_certification_file(update: Update, context: CallbackContext) -> int:
    if update.message.document:
        file_id = update.message.document.file_id
        file_name = update.message.document.file_name
        context.user_data['certification_file_id'] = file_id
        context.user_data['certification_file_name'] = file_name

        await update.message.reply_text(f"Your certification '{file_name}' has been successfully uploaded.")
        return MANAGE_CERTIFICATIONS  # Return to the certifications management menu
    else:
        await update.message.reply_text("No document was uploaded. Please try again.")
        return UPLOAD_CERTIFICATION

# Function to handle receiving the uploaded portfolio file
async def receive_portfolio_file(update: Update, context: CallbackContext) -> int:
    if update.message.document:
        file_id = update.message.document.file_id
        file_name = update.message.document.file_name
        context.user_data['portfolio_file_id'] = file_id
        context.user_data['portfolio_file_name'] = file_name

        await update.message.reply_text(f"Your portfolio '{file_name}' has been successfully uploaded.")
        return MANAGE_CERTIFICATIONS  # Return to the certifications management menu
    else:
        await update.message.reply_text("No document was uploaded. Please try again.")
        return UPLOAD_PORTFOLIO


import re
import logging
import psycopg2
from PIL import Image
from telegram import ReplyKeyboardMarkup, Update
from telegram.ext import CallbackContext, ConversationHandler

# Function to escape special characters for Telegram's MarkdownV2
def escape_markdown_v2(text):
    """Escapes special characters for Telegram's MarkdownV2 syntax."""
    return re.sub(r'([_*[\]()~`>#+\-=|{}.!])', r'\\\1', text)

def format_field(field, default='N/A'):
    """Formats field values and escapes MarkdownV2 special characters."""
    if field is None:
        return default
    return escape_markdown_v2(str(field).strip())

def process_field(field):
    """Handles both list and string fields dynamically."""
    if isinstance(field, list):
        return ", ".join(escape_markdown_v2(str(item).strip()) for item in field)
    elif isinstance(field, str):
        return ", ".join(escape_markdown_v2(item.strip()) for item in field.split(","))
    return escape_markdown_v2(str(field).strip())

def resize_image(image_path, output_path, max_size=(300, 300)):
    """Resize the image to the given max size and save to output path."""
    with Image.open(image_path) as img:
        img.thumbnail(max_size)  # Resize while maintaining aspect ratio
        img.save(output_path, format="JPEG")  # Save as JPEG to reduce size

async def handle_edit_applicant_profile(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id

    if update.message.text == "🔙 Back":
        await update.message.reply_text(
            "Main Menu: Please choose an action.",
            reply_markup=ReplyKeyboardMarkup([
                ["➕🪪 Add Profile", "🧑🏿‍🎓 View Profile"],
                ["📄 Upload Resume/CV", "🔙 Back to Main Menu"],

            ], resize_keyboard=True)
        )
        return MY_PROFILE_MENU

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return

        user_id = user_row[0]

        # Fetch applicant profile
        cursor.execute('''
            SELECT full_name, job_title, location, phone_number, email, experience_level, 
                   skills, employment_type, availability, highest_degree, university, 
                   graduation_year, certifications, languages, portfolio_link, resume, 
                   college, gpa, gender, profile_picture
            FROM applicant_profiles
            WHERE applicant_id = %s
        ''', (user_id,))
        profile_data = cursor.fetchone()

        if not profile_data:
            await update.message.reply_text("You do not have a profile yet.")
            return

        gender_icon = "👨🏾" if profile_data[18].strip().lower() == "male" else "👩🏾"

        # Personal Information
        profile_info = "*Personal Information*\n\n"
        profile_info += f"{gender_icon} *Full Name:* {format_field(profile_data[0])}\n\n"
        if profile_data[1]:  # Dynamically include Job Title
            profile_info += f"💼 *Job Title:* {format_field(profile_data[1])}\n\n"
        profile_info += f"📍 *Location:* {format_field(profile_data[2])}\n\n"
        phone_number = profile_data[3]
        if phone_number and not phone_number.startswith("+"):
            phone_number = f"+{phone_number}"
        profile_info += f"📞 *Phone Number:* {format_field(phone_number)}\n\n"
        profile_info += f"✉️ *Email:* {format_field(profile_data[4])}\n"

        # Professional Overview
        professional_overview = "\n\n*Professional Overview*\n\n"
        if profile_data[5]:  # Experience Level
            professional_overview += f"📊 *Experience Level:* {format_field(profile_data[5])}\n\n"
        if profile_data[6]:  # Skills
            professional_overview += f"🛠️ *Skills:* {process_field(profile_data[6])}\n\n"
        if profile_data[7]:  # Employment Type
            professional_overview += f"⏳ *Employment Type:* {format_field(profile_data[7])}\n\n"
        if profile_data[8]:  # Availability
            professional_overview += f"📅 *Availability:* {format_field(profile_data[8])}\n\n"

        # Add Professional Overview if there is any data
        if professional_overview.strip() != "*Professional Overview*":
            profile_info += professional_overview

        # Education
        education = "\n*Education*\n\n"
        if profile_data[9]:  # Highest Degree
            education += f"🎓 *Degrees:* {format_field(profile_data[9])}\n\n"
        if profile_data[10]:  # University
            education += f"🏫 *University:* {format_field(profile_data[10])}\n\n"
        if profile_data[11]:  # Graduation Year
            education += f"📅 *Graduation Year:* {format_field(profile_data[11])}\n\n"
        if profile_data[16]:  # College
            education += f"🏛️ *College:* {format_field(profile_data[16])}\n\n"
        if profile_data[17]:  # GPA
            education += f"🎓 *GPA:* {format_field(profile_data[17])}\n"

        # Add Education if there is any data
        if education.strip() != "*Education*":
            profile_info += education

        # Certifications
        certifications = ""
        if profile_data[12]:  # Certifications
            certifications = f"\n*Certifications*\n\n📜 {process_field(profile_data[12])}\n"
            profile_info += certifications

        # Languages
        languages = ""
        if profile_data[13]:  # Languages
            languages = f"\n*Languages*\n\n🌐 {process_field(profile_data[13])}\n"
            profile_info += languages

        # Portfolio Links
        portfolio = ""
        if profile_data[14]:  # Portfolio Links
            portfolio = "\n*Portfolio Links*\n\n" + "\n\n".join(
                f"🔗 {escape_markdown_v2(link.strip())}" for link in profile_data[14].split(",")
            ) + "\n"
            profile_info += portfolio

        # Uploaded Resume
        resume = ""
        if profile_data[15]:  # Resume
            resume = "\n*Uploaded Resume*\n\n📄 *Resume:* Uploaded"
            profile_info += resume

        # Resize the profile picture if available
        sent_message = None
        # Send profile picture if available, else send profile info
        if profile_data[19]:
            file_id = profile_data[19]
            sent_message = await context.bot.send_photo(
                chat_id=user_chat_id,
                photo=file_id,
                caption=profile_info,
                parse_mode='MarkdownV2'
            )
        else:
            sent_message = await update.message.reply_text(profile_info, parse_mode='MarkdownV2')

        # Follow-up menu
        await context.bot.send_message(
            chat_id=user_chat_id,
            text="Which field would you like to update?",
            reply_markup=ReplyKeyboardMarkup([
                ["🧑🏾‍💼 Full Name", "💼 Job Title"],
                ["📍 Location", "📞 Phone Number"],
                ["✉️ Email", "📊 Experience Level"],
                ["🛠️ Skills", "⏳ Employment Type"],
                ["📅 Availability", "📜 Certifications"],
                ["🎓 Degrees", "🏫 University"],
                ["📅 Graduation Year", "🏛️ College"],
                ["🎓 GPA", "🖼️ Profile Picture"],
                ["🌍 Portfolio Link", "🌐 Languages"],
                ["🔙 Back"]
            ], resize_keyboard=True),
            reply_to_message_id=sent_message.message_id
        )

    except (Exception, psycopg2.DatabaseError) as error:
        logging.error(f"Error fetching applicant profile: {error}")
        await update.message.reply_text("An error occurred while retrieving your profile.")
        return

    finally:
        if conn:
            cursor.close()
            conn.close()

    return APPLICANT_PROFILE_EDIT_MENU




# Show the applicant profile edit menu
async def show_applicant_profile_edit_menu(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Which field would you like to edit or add next?",
        reply_markup=ReplyKeyboardMarkup([
            ["🧑🏾‍💼 Full Name", "💼 Job Title"],
            ["📍 Location", "📞 Phone Number"],
            ["✉️ Email", "📊 Experience Level"],
            ["🛠️ Skills", "⏳ Employment Type"],
            ["📅 Availability", "📜 Certifications"],
            ["🎓 Degrees", "🏫 University"],
            ["📅 Graduation Year", "🏛️ College"],
            ["🎓 GPA", "🖼️ Profile Picture"],
            ["🌍 Portfolio Link", "🌐 Languages"],
            ["🔙 Back"]
        ], resize_keyboard=True)
    )
    return APPLICANT_PROFILE_EDIT_MENU


# Ask for Full Name
async def ask_for_full_name(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please enter your *Full Name* (or press 'Back' to return):",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return APPLICANT_FULL_NAME

# Ask for Job Title
async def ask_for_job_title(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "What is your *Job Title*? (e.g., 'Software Developer')",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return APPLICANT_JOB_TITLE

async def ask_for_location(update: Update, context: CallbackContext) -> int:
    """
    Fetch and display cities dynamically from the database for location input.
    """
    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432",
        )
        cursor = conn.cursor()

        # Fetch cities from the database
        cursor.execute("SELECT city_name FROM locations ORDER BY city_name ASC;")
        cities = [row[0] for row in cursor.fetchall()]

        if not cities:
            # No cities found in the database
            await update.message.reply_text(
                "No cities are available at the moment. Please try again later."
            )
            return APPLICANT_MENU  # Return to the main applicant menu

        # Save valid cities to context for validation
        context.user_data["valid_cities"] = cities

        # Prepare keyboard buttons (2 columns per row)
        city_buttons = [cities[i:i+2] for i in range(0, len(cities), 2)]
        city_buttons.append(["🔙 Back"])  # Add a "Back" button

        # Create the reply markup with city buttons
        reply_markup = ReplyKeyboardMarkup(city_buttons, resize_keyboard=True)

        # Send the location selection prompt
        await update.message.reply_text(
            "Where are you located? Please select your *City* from the options below:",
            reply_markup=reply_markup
        )
        return APPLICANT_LOCATION  # State to capture location input

    except (Exception, psycopg2.DatabaseError) as error:
        # Log and handle any database errors
        logger.error(f"Database error while fetching cities: {error}")
        await update.message.reply_text(
            "An error occurred while fetching cities. Please try again later."
        )
        return APPLICANT_MENU  # Return to the main applicant menu

    finally:
        # Close the database connection
        if conn:
            cursor.close()
            conn.close()


# Ask for Phone Number
async def ask_for_phone_number(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please share your *Phone Number* by pressing the 'Share Contact' button below. Manual input is not allowed:",
        reply_markup=ReplyKeyboardMarkup(
            [[KeyboardButton("Share Contact", request_contact=True)], ["🔙 Back"]],
            resize_keyboard=True
        )
    )
    return APPLICANT_PHONE

# Ask for Email
async def ask_for_email(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Do you have an *Email Address* you'd like to share? If not, type 'No':",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return APPLICANT_EMAIL

# Ask for Professional Overview
async def ask_for_overview(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please summarize your *Professional Overview* (e.g., '5+ years of experience in full-stack development'):",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return APPLICANT_OVERVIEW

# Ask for Skills
async def ask_for_skills(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "What are your top *3-5 Skills*? Separate them by commas (e.g., 'JavaScript, Python, React'):",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return APPLICANT_SKILLS

# Function to ask for employment types
async def ask_for_employment_type(update: Update, context: CallbackContext) -> int:
    """
    Fetch employment types from the database, display them for selection, and
    handle previously saved values with check marks.
    """
    selected_employment_type = update.message.text.strip() if update.message else None

    # Handle "Back" button
    if selected_employment_type == "🔙 Back":
        return await show_applicant_profile_edit_menu(update, context)

    # Handle "Done" button
    if selected_employment_type == "✅ Done":
        return await save_applicant_employment_type(update, context)

    try:
        # Connect to the PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch all employment types from the database
        cursor.execute("SELECT job_type_name FROM job_types ORDER BY job_type_name ASC;")
        employment_types = [row[0] for row in cursor.fetchall()]

        if not employment_types:
            await update.message.reply_text(
                "No employment types are available at the moment. Please try again later."
            )
            return

        # Fetch previously saved employment types for the user
        if "selected_employment_types" not in context.user_data:
            user_chat_id = update.message.chat_id
            cursor.execute("""
                SELECT employment_type FROM applicant_profiles
                INNER JOIN users ON users.user_id = applicant_profiles.applicant_id
                WHERE users.contact = %s
            """, (str(user_chat_id),))
            result = cursor.fetchone()

            previously_selected = result[0].split(", ") if result and result[0] else []
            context.user_data["selected_employment_types"] = previously_selected

        # Toggle selection if an employment type was clicked
        if selected_employment_type:
            selected_employment_type = selected_employment_type.replace("✔️", "").strip()  # Normalize selection
            selected_employment_types = context.user_data["selected_employment_types"]
            if selected_employment_type in employment_types:
                if selected_employment_type in selected_employment_types:
                    selected_employment_types.remove(selected_employment_type)
                else:
                    if len(selected_employment_types) >= 3:
                        await update.message.reply_text(
                            "⚠️ You can only select up to 3 employment types. Please deselect one before adding another."
                        )
                        return APPLICANT_EMPLOYMENT_TYPE
                    selected_employment_types.append(selected_employment_type)
                context.user_data["selected_employment_types"] = selected_employment_types

        # Prepare buttons with check marks for selected items
        selected_employment_types = context.user_data.get("selected_employment_types", [])
        employment_type_buttons = []
        for i in range(0, len(employment_types), 2):
            row = [
                f"✔️ {etype}" if etype in selected_employment_types else etype
                for etype in employment_types[i:i + 2]
            ]
            employment_type_buttons.append(row)

        # Add Back and Done buttons
        employment_type_buttons.append(["🔙 Back", "✅ Done"])

        # Save valid employment types to context for validation
        context.user_data["valid_employment_types"] = employment_types

        # Create the reply markup with employment type buttons
        reply_markup = ReplyKeyboardMarkup(employment_type_buttons, resize_keyboard=True)

        # Send the employment type selection prompt
        await update.message.reply_text(
            "Please select the Employment Type(s) (you can select up to 3):",
            reply_markup=reply_markup
        )
        return APPLICANT_EMPLOYMENT_TYPE

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error while fetching employment types: {error}")
        await update.message.reply_text(
            "An error occurred while fetching employment types. Please try again later."
        )
        return

    finally:
        if conn:
            cursor.close()
            conn.close()



from datetime import datetime, timedelta  # Ensure correct imports
from telegram import ReplyKeyboardMarkup


# Ask for Availability
async def ask_for_availability(update: Update, context: CallbackContext) -> int:
    # Prompt user to choose from predefined options or enter a specific date
    await update.message.reply_text(
        "When will you be available to start?\n"
        "You can choose one of the options below or type a specific date (YYYY-MM-DD):",
        reply_markup=ReplyKeyboardMarkup(
            [
                ["Immediately", "In 1 week"],
                ["In 2 weeks", "In a month"],
                ["🔙 Back"]
            ],
            one_time_keyboard=True,
            resize_keyboard=True
        )
    )
    return APPLICANT_AVAILABILITY  # This is the state waiting for the user to select an option.


# Handle the user's selection for availability
async def handle_availability_selection(update: Update, context: CallbackContext) -> int:
    user_response = update.message.text

    if user_response in ["Immediately", "In 1 week", "In 2 weeks", "In a month"]:
        today = datetime.now().date()  # Get the current date
        if user_response == "Immediately":
            availability = today
        elif user_response == "In 1 week":
            availability = today + timedelta(weeks=1)
        elif user_response == "In 2 weeks":
            availability = today + timedelta(weeks=2)
        elif user_response == "In a month":
            availability = today + timedelta(weeks=4)

        context.user_data['availability'] = availability
        await update.message.reply_text(f"Your availability has been set to: {availability}")
        return APPLICANT_MAIN_MENU  # Continue with your next state.

    else:
        # If the user input is invalid, ask again
        await update.message.reply_text(
            "Please select a valid option.",
            reply_markup=ReplyKeyboardMarkup(
                [
                    ["Immediately", "In 1 week"],
                    ["In 2 weeks", "In a month"],
                    ["🔙 Back"]
                ],
                one_time_keyboard=True,
                resize_keyboard=True
            )
        )
        return APPLICANT_AVAILABILITY


# Handle the user's input when they enter a specific date
async def handle_specific_date_input(update: Update, context: CallbackContext) -> int:
    user_response = update.message.text

    try:
        # Validate the date format (YYYY-MM-DD)
        specific_date = datetime.strptime(user_response, "%Y-%m-%d").date()  # Parse specific date correctly
        context.user_data['availability'] = specific_date  # Store the specific date
        await update.message.reply_text(f"Your availability has been set to: {specific_date}")
        return APPLICANT_MAIN_MENU  # Continue to the next step in your application flow.
    except ValueError:
        # If the date format is incorrect, ask the user to enter the date again
        await update.message.reply_text(
            "Invalid date format. Please enter a valid date in the format YYYY-MM-DD."
        )
        return ENTER_SPECIFIC_DATE  # Go back to specific date input state


# Ask for Work Experience
async def ask_for_work_experience(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Enter your most recent *Work Experience* in the following format:\n\n"
        "Job Title:\nCompany Name:\nDates (e.g., 'March 2018 - Present'):\nLocation:\nBrief Description of your role:",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return APPLICANT_WORK_EXPERIENCE

# Ask for Education
async def ask_for_education(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Enter your highest *Education* (e.g., 'Bachelor’s in Computer Science') and the university you attended:",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return APPLICANT_EDUCATION

# Ask for Certifications
async def ask_for_certifications(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Do you have any *Certifications* you'd like to add? List them (e.g., 'AWS Certified Developer, 2022'):",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return APPLICANT_CERTIFICATIONS

async def ask_for_highest_degree(update: Update, context: CallbackContext) -> int:
    """
    Fetch, display, and handle highest degrees dynamically from the database, showing check marks for selected items.
    """
    selected_degree = update.message.text.strip() if update.message else None

    # Handle the "Back" button
    if selected_degree == "🔙 Back":
        return await show_applicant_profile_edit_menu(update, context)

    # Handle the "Done" button
    if selected_degree == "✅ Done":
        return await save_applicant_highest_degree(update, context)

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch degrees from the database
        cursor.execute("SELECT education_level_name FROM education_levels ORDER BY education_level_name ASC;")
        degrees = [row[0] for row in cursor.fetchall()]

        if not degrees:
            await update.message.reply_text("No degrees are available at the moment. Please try again later.")
            return

        # Fetch previously saved degrees if this is the first display
        if "selected_degrees" not in context.user_data:
            user_chat_id = update.message.chat_id
            cursor.execute("""
                SELECT highest_degree FROM applicant_profiles
                INNER JOIN users ON users.user_id = applicant_profiles.applicant_id
                WHERE users.contact = %s
            """, (str(user_chat_id),))
            result = cursor.fetchone()
            previously_selected = result[0].split(", ") if result and result[0] else []
            context.user_data["selected_degrees"] = previously_selected

        # Toggle selection if a degree was clicked
        if selected_degree:
            selected_degree = selected_degree.replace("✔️", "").strip()
            if selected_degree in degrees:
                selected_degrees = context.user_data["selected_degrees"]
                if selected_degree in selected_degrees:
                    selected_degrees.remove(selected_degree)
                else:
                    selected_degrees.append(selected_degree)
                context.user_data["selected_degrees"] = selected_degrees

        # Prepare buttons with check marks for selected items
        selected_degrees = context.user_data.get("selected_degrees", [])
        degree_buttons = []
        for i in range(0, len(degrees), 2):
            row = [
                f"✔️ {degree}" if degree in selected_degrees else degree
                for degree in degrees[i:i + 2]
            ]
            degree_buttons.append(row)

        # Add Back and Done buttons
        degree_buttons.append(["🔙 Back", "✅ Done"])

        # Save valid degrees to context for validation
        context.user_data["valid_degrees"] = degrees

        # Create the reply markup with degree buttons
        reply_markup = ReplyKeyboardMarkup(degree_buttons, resize_keyboard=True)

        # Send the degree selection prompt
        await update.message.reply_text(
            "Please select your highest degree(s) (you can select multiple):",
            reply_markup=reply_markup
        )
        return APPLICANT_HIGHEST_DEGREE

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error while fetching degrees: {error}")
        await update.message.reply_text("An error occurred while fetching degrees. Please try again later.")
        return

    finally:
        if conn:
            cursor.close()
            conn.close()




async def ask_for_university(update: Update, context: CallbackContext) -> int:
    """
    Fetch and display universities dynamically from the database for the user to select.
    """
    try:
        # Connect to the PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch universities from the database
        cursor.execute("SELECT university_name FROM universities ORDER BY university_name ASC;")
        universities = [row[0] for row in cursor.fetchall()]

        if not universities:
            # No universities found in the database
            await update.message.reply_text(
                "No universities are available at the moment. Please try again later."
            )
            return  # End the conversation gracefully

        # Save valid universities to context for validation in subsequent steps
        context.user_data["valid_universities"] = universities

        # Prepare keyboard buttons (2 columns per row)
        university_buttons = [universities[i:i+2] for i in range(0, len(universities), 2)]
        university_buttons.append(["🔙 Back"])  # Add a "Back" button

        # Create the reply markup with university buttons
        reply_markup = ReplyKeyboardMarkup(university_buttons, resize_keyboard=True)

        # Send the university selection prompt
        await update.message.reply_text(
            "Please select your University:",
            reply_markup=reply_markup
        )
        return APPLICANT_UNIVERSITY  # State to handle the university input

    except (Exception, psycopg2.DatabaseError) as error:
        # Log and handle any database errors
        logger.error(f"Database error while fetching universities: {error}")
        await update.message.reply_text(
            "An error occurred while fetching universities. Please try again later."
        )
        return  # End the conversation gracefully on error

    finally:
        # Ensure the database connection is closed
        if conn:
            cursor.close()
            conn.close()



# Function to ask for Graduation Year
async def ask_for_graduation_year(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please enter your *Graduation Year* (e.g., '2020'):",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return APPLICANT_GRADUATION_YEAR


async def ask_for_languages(update: Update, context: CallbackContext) -> int:
    """
    Fetch, display, and handle languages dynamically from the database, showing check marks for selected items.
    """
    selected_language = update.message.text.strip() if update.message else None

    # Handle the "Back" button
    if selected_language == "🔙 Back":
        return await show_applicant_profile_edit_menu(update, context)

    # Handle the "Done" button
    if selected_language == "✅ Done":
        return await save_applicant_languages(update, context)

    # Connect to the PostgreSQL database
    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch languages from the database
        cursor.execute("SELECT language_name FROM languages ORDER BY language_name ASC;")
        languages = [row[0] for row in cursor.fetchall()]

        if not languages:
            # No languages found in the database
            await update.message.reply_text(
                "No languages are available at the moment. Please try again later."
            )
            return  # End the conversation gracefully

        # Fetch previously saved languages if this is the first display
        if "selected_languages" not in context.user_data:
            user_chat_id = update.message.chat_id
            cursor.execute("""
                SELECT languages FROM applicant_profiles
                INNER JOIN users ON users.user_id = applicant_profiles.applicant_id
                WHERE users.contact = %s
            """, (str(user_chat_id),))
            result = cursor.fetchone()

            previously_selected = result[0] if result and result[0] else []
            if isinstance(previously_selected, str):
                previously_selected = previously_selected.strip('{}').split(',')  # Handle PostgreSQL array format
            context.user_data["selected_languages"] = previously_selected

        # Toggle selection if a language was clicked
        if selected_language:
            selected_language = selected_language.replace("✔️", "").strip()  # Normalize selection
            if selected_language in languages:
                selected_languages = context.user_data["selected_languages"]
                if selected_language in selected_languages:
                    selected_languages.remove(selected_language)
                else:
                    selected_languages.append(selected_language)
                context.user_data["selected_languages"] = selected_languages

        # Prepare buttons with check marks for selected items
        selected_languages = context.user_data.get("selected_languages", [])
        language_buttons = []
        for i in range(0, len(languages), 2):
            row = [
                f"✔️ {lang}" if lang in selected_languages else lang
                for lang in languages[i:i + 2]
            ]
            language_buttons.append(row)

        # Add Back and Done buttons
        language_buttons.append(["🔙 Back", "✅ Done"])

        # Save valid languages to context for validation
        context.user_data["valid_languages"] = languages

        # Create the reply markup with language buttons
        reply_markup = ReplyKeyboardMarkup(language_buttons, resize_keyboard=True)

        # Send the language selection prompt
        await update.message.reply_text(
            "Please select the Language(s) you speak (you can select multiple):",
            reply_markup=reply_markup
        )
        return APPLICANT_LANGUAGES  # State to handle language selection

    except (Exception, psycopg2.DatabaseError) as error:
        # Log and handle any database errors
        logger.error(f"Database error while fetching languages: {error}")
        await update.message.reply_text(
            "An error occurred while fetching languages. Please try again later."
        )
        return  # End the conversation gracefully on error

    finally:
        # Ensure the database connection is closed
        if conn:
            cursor.close()
            conn.close()



async def ask_for_portfolio(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Do you have a *Portfolio* or website you want to share? Select an option below to add or view links:",
        reply_markup=InlineKeyboardMarkup(
            [
                [InlineKeyboardButton("Add Link 1", callback_data='link_1')],
                [InlineKeyboardButton("Add Link 2", callback_data='link_2')],
                [InlineKeyboardButton("Add Link 3", callback_data='link_3')],
                [InlineKeyboardButton("Add Link 4", callback_data='link_4')],
                [InlineKeyboardButton("View Links", callback_data='view_links')]
            ]
        )
    )
    await update.message.reply_text(
        "Press 'Done' when you are finished or '🔙 Back' to go back:",
        reply_markup=ReplyKeyboardMarkup(
            [["Done", "🔙 Back"]],
            resize_keyboard=True
        )
    )
    return APPLICANT_PORTFOLIO

async def handle_link_1(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()
    context.user_data["current_link"] = "link_1"
    await query.edit_message_text("Please provide your first portfolio link:")
    return APPLICANT_PORTFOLIO_LINK

async def handle_link_2(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()
    context.user_data["current_link"] = "link_2"
    await query.edit_message_text("Please provide your second portfolio link:")
    return APPLICANT_PORTFOLIO_LINK

async def handle_link_3(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()
    context.user_data["current_link"] = "link_3"
    await query.edit_message_text("Please provide your third portfolio link:")
    return APPLICANT_PORTFOLIO_LINK

async def handle_link_4(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()
    context.user_data["current_link"] = "link_4"
    await query.edit_message_text("Please provide your fourth portfolio link:")
    return APPLICANT_PORTFOLIO_LINK


# Ask for Resume
async def ask_for_resume(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "You can upload your *Resume/CV* (PDF or Word format):",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return APPLICANT_RESUME

# Ask for Profile Picture
async def ask_for_profile_picture(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "You can upload your *Profile Picture* (JPEG or PNG format):",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return APPLICANT_PROFILE_PICTURE

from telegram import ReplyKeyboardMarkup, Update
from telegram.ext import CallbackContext

async def ask_for_college(update: Update, context: CallbackContext) -> int:
    """
    Fetch and display colleges dynamically from the database for the user to select.
    """
    try:
        # Connect to the PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch colleges from the database
        cursor.execute("SELECT college_name FROM colleges ORDER BY college_name ASC;")
        colleges = [row[0] for row in cursor.fetchall()]

        if not colleges:
            # No colleges found in the database
            await update.message.reply_text(
                "No colleges are available at the moment. Please try again later."
            )
            return  # End the conversation gracefully

        # Save valid colleges to context for validation in subsequent steps
        context.user_data["valid_colleges"] = colleges

        # Prepare keyboard buttons (2 columns per row)
        college_buttons = [colleges[i:i+2] for i in range(0, len(colleges), 2)]
        college_buttons.append(["🔙 Back"])  # Add a "Back" button

        # Create the reply markup with college buttons
        reply_markup = ReplyKeyboardMarkup(college_buttons, resize_keyboard=True)

        # Send the college selection prompt
        await update.message.reply_text(
            "Please select your University/College:",
            reply_markup=reply_markup
        )
        return APPLICANT_COLLEGE  # State to handle the college input

    except (Exception, psycopg2.DatabaseError) as error:
        # Log and handle any database errors
        logger.error(f"Database error while fetching colleges: {error}")
        await update.message.reply_text(
            "An error occurred while fetching colleges. Please try again later."
        )
        return # End the conversation gracefully on error

    finally:
        # Ensure the database connection is closed
        if conn:
            cursor.close()
            conn.close()


# Function to ask for GPA
async def ask_for_gpa(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please enter your GPA (e.g., 3.5):",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return APPLICANT_GPA  # Replace with the correct state identifier for GPA input


# Save the full name (use user_id as applicant_id)
async def save_applicant_full_name(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    full_name = update.message.text

    # Check if the user pressed the "Back" button
    if full_name.lower() == "🔙 back":
        return await show_applicant_profile_edit_menu(update, context)

    try:
        # Connect to PostgreSQL database
        logger.debug("Connecting to database to save full name")
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return APPLICANT_PROFILE_EDIT_MENU

        user_id = user_row[0]  # Use user_id as applicant_id

        # Insert or update the full name and user_id in applicant_profiles
        cursor.execute('''
            INSERT INTO applicant_profiles (applicant_id, full_name, user_id)
            VALUES (%s, %s, %s)
            ON CONFLICT (applicant_id)
            DO UPDATE SET full_name = EXCLUDED.full_name, user_id = EXCLUDED.user_id
        ''', (user_id, full_name, user_id))  # Set both applicant_id and user_id

        conn.commit()

        # Notify the user that the full name has been saved
        await update.message.reply_text(f"✔️ Full Name '{full_name}' has been saved successfully.")

        # Display the updated profile summary
        return await handle_edit_applicant_profile(update, context)

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating full name: {error}")
        await update.message.reply_text("An error occurred while updating your full name.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return await show_applicant_profile_edit_menu(update, context)




async def save_applicant_job_title(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    job_title = update.message.text

    # Check if the user pressed the "Back" button
    if job_title.lower() == "🔙 back":
        return await show_applicant_profile_edit_menu(update, context)

    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return APPLICANT_PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Update the job title in applicant_profiles without checking for full_name
        cursor.execute('''
            UPDATE applicant_profiles 
            SET job_title = %s
            WHERE applicant_id = %s
        ''', (job_title, user_id))

        conn.commit()
        await update.message.reply_text("✔️ Your Job Title has been saved successfully!")

        # Display the updated profile summary
        return await handle_edit_applicant_profile(update, context)


    except (Exception, psycopg2.DatabaseError) as error:
        await update.message.reply_text("An error occurred while updating your job title.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return await show_applicant_profile_edit_menu(update, context)


# Collect and save Location (ensure full_name is already present)
async def save_applicant_location(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    location = update.message.text.strip()


    # Get the list of valid cities from the context
    valid_cities = context.user_data.get("valid_cities", [])

    # Check if the input is valid or is the "Back" button
    if location not in valid_cities + ["🔙 Back"]:
        await update.message.reply_text(
            "⚠️ Invalid selection. Please choose a location using the provided buttons."
        )
        return APPLICANT_LOCATION  # Stay in the same state
    # Check if the user pressed the "Back" button
    if location.lower() == "🔙 back":
        return await show_applicant_profile_edit_menu(update, context)


    try:
        # Connect to PostgreSQL database
        logger.debug("Connecting to database to save location")
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return APPLICANT_PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Ensure full_name exists in the database before saving location
        cursor.execute('SELECT full_name FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
        full_name_row = cursor.fetchone()

        if not full_name_row or not full_name_row[0]:  # Check if full_name is missing
            await update.message.reply_text(
                "You must provide your Full Name before saving other details."
            )
            return await ask_for_full_name(update, context)

        # Insert or update the location in applicant_profiles
        cursor.execute('''
            UPDATE applicant_profiles 
            SET location = %s
            WHERE applicant_id = %s
        ''', (location, user_id))

        conn.commit()

        # Notify the user that the location has been saved
        await update.message.reply_text("✔️ Your Location has been saved successfully!")

        # Display the updated profile summary
        return await handle_edit_applicant_profile(update, context)


    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating location: {error}")
        await update.message.reply_text("An error occurred while updating your location.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    # Proceed to the next step to collect more information or edit the profile
    return await show_applicant_profile_edit_menu(update, context)


# Save the phone number (ensure full_name exists)
async def save_applicant_phone(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id

    # Check if the user pressed the "Back" button
    if update.message.text == "🔙 Back":
        # Remove the custom keyboard
        await update.message.reply_text(
            "Returning to the previous menu...",
            reply_markup=ReplyKeyboardRemove()
        )
        return await show_applicant_profile_edit_menu(update, context)

    # Validate that the input is a contact object
    if not update.message.contact:
        await update.message.reply_text(
            "⚠️ Please use the 'Share Contact' button to share your phone number."
        )
        return APPLICANT_PHONE  # Stay in the current state and prompt again

    # If contact is shared, get the phone number from the contact object
    phone_number = update.message.contact.phone_number

    try:
        # Connect to PostgreSQL database
        logger.debug("Connecting to database to save phone number")
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return APPLICANT_PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Check if the full_name exists in the applicant_profiles table
        cursor.execute('SELECT full_name FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
        full_name_row = cursor.fetchone()

        # If full_name is missing, prompt the user to enter their full name
        if not full_name_row or not full_name_row[0]:
            await update.message.reply_text(
                "You must provide your Full Name before saving your phone number. Please enter your Full Name first."
            )
            return await ask_for_full_name(update, context)

        # Full Name exists, so proceed with inserting or updating the phone number
        cursor.execute('''
            UPDATE applicant_profiles 
            SET phone_number = %s
            WHERE applicant_id = %s
        ''', (phone_number, user_id))

        conn.commit()

        # Notify the user that the phone number has been saved
        await update.message.reply_text(f"✔️ Phone Number '{phone_number}' has been saved successfully.")

        # Display the updated profile summary
        return await handle_edit_applicant_profile(update, context)


    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating phone number: {error}")
        await update.message.reply_text("An error occurred while updating your phone number.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return await show_applicant_profile_edit_menu(update, context)

# Email validation function
def is_valid_email(email: str) -> bool:
    """
    Validate if the input is a proper email address.
    """
    email_regex = re.compile(
        r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    )
    return bool(re.match(email_regex, email))

# Save the email (ensure full_name exists)
async def save_applicant_email(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    email = update.message.text

    # Check if the user pressed the "Back" button
    if email.lower() == "🔙 back":
        return await show_applicant_profile_edit_menu(update, context)

    # If the user typed 'No', we treat it as no email to share
    if email.lower() == 'no':
        email = None

    else:
        # Validate the email format
        if not is_valid_email(email):
            await update.message.reply_text(
                "⚠️ Invalid email address. Please enter a valid email (e.g., example@example.com)."
            )
            return APPLICANT_EMAIL  # Stay in the same state to re-enter the email

    try:
        # Connect to PostgreSQL database
        logger.debug("Connecting to database to save email")
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return APPLICANT_PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Check if the full_name exists in the applicant_profiles table
        cursor.execute('SELECT full_name FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
        full_name_row = cursor.fetchone()

        # If full_name is missing, prompt the user to enter their full name first
        if not full_name_row or not full_name_row[0]:
            await update.message.reply_text(
                "You must provide your Full Name before saving your email. Please enter your Full Name first."
            )
            return await ask_for_full_name(update, context)

        # Full Name exists, so proceed with updating the email
        cursor.execute('''
            UPDATE applicant_profiles 
            SET email = %s
            WHERE applicant_id = %s
        ''', (email, user_id))

        conn.commit()

        # Notify the user that the email has been saved
        await update.message.reply_text(f"✔️ Email '{email}' has been saved successfully.")

        # Display the updated profile summary
        return await handle_edit_applicant_profile(update, context)


    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating email: {error}")
        await update.message.reply_text("An error occurred while updating your email.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return await show_applicant_profile_edit_menu(update, context)


# Save the professional overview (ensure full_name exists)
async def save_applicant_overview(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    overview = update.message.text

    # Check if the user pressed the "Back" button
    if overview.lower() == "🔙 back":
        return await show_applicant_profile_edit_menu(update, context)

    try:
        # Connect to PostgreSQL database
        logger.debug("Connecting to database to save professional overview")
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return APPLICANT_PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Check if the full_name exists in the applicant_profiles table
        cursor.execute('SELECT full_name FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
        full_name_row = cursor.fetchone()

        # If full_name is missing, prompt the user to enter their full name first
        if not full_name_row or not full_name_row[0]:
            await update.message.reply_text(
                "You must provide your Full Name before saving your professional overview. Please enter your Full Name first."
            )
            return await ask_for_full_name(update, context)

        # Full Name exists, so proceed with updating the professional overview
        cursor.execute('''
            UPDATE applicant_profiles 
            SET experience_level = %s
            WHERE applicant_id = %s
        ''', (overview, user_id))

        conn.commit()

        # Notify the user that the professional overview has been saved
        await update.message.reply_text(f"✔️ Professional Overview '{overview}' has been saved successfully.")

        # Display the updated profile summary
        return await handle_edit_applicant_profile(update, context)


    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating professional overview: {error}")
        await update.message.reply_text("An error occurred while updating your professional overview.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return await show_applicant_profile_edit_menu(update, context)



# Save the skills (ensure full_name exists)
async def save_applicant_skills(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    skills = update.message.text

    # Check if the user pressed the "Back" button
    if skills.lower() == "🔙 back":
        return await show_applicant_profile_edit_menu(update, context)

    skill_list = [skill.strip() for skill in skills.split(',')]

    try:
        # Connect to PostgreSQL database
        logger.debug("Connecting to database to save skills")
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return APPLICANT_PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Check if the full_name exists in the applicant_profiles table
        cursor.execute('SELECT full_name FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
        full_name_row = cursor.fetchone()

        # If full_name is missing, prompt the user to enter their full name first
        if not full_name_row or not full_name_row[0]:
            await update.message.reply_text(
                "You must provide your Full Name before saving your skills. Please enter your Full Name first."
            )
            return await ask_for_full_name(update, context)

        # Full Name exists, so proceed with updating the skills
        cursor.execute('''
            UPDATE applicant_profiles 
            SET skills = %s
            WHERE applicant_id = %s
        ''', (skill_list, user_id))

        conn.commit()

        # Notify the user that the skills have been saved
        await update.message.reply_text("✔️ Your skills have been saved successfully.")

        # Display the updated profile summary
        return await handle_edit_applicant_profile(update, context)


    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating skills: {error}")
        await update.message.reply_text("An error occurred while updating your skills.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return await show_applicant_profile_edit_menu(update, context)

async def save_applicant_work_experience(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    work_experience = update.message.text  # Work experience details entered by the user

    if work_experience.lower() == "🔙 back":
        return await show_applicant_profile_edit_menu(update, context)

    try:
        logger.debug("Connecting to database to save work experience")
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return APPLICANT_PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Ensure full_name exists before proceeding
        cursor.execute('SELECT full_name FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
        full_name_row = cursor.fetchone()

        if not full_name_row or not full_name_row[0]:
            await update.message.reply_text("You must provide your Full Name before saving other details.")
            return await ask_for_full_name(update, context)

        # Insert or update the work experience in applicant_profiles
        cursor.execute('''
            INSERT INTO applicant_profiles (applicant_id, work_experience)
            VALUES (%s, %s)
            ON CONFLICT (applicant_id)
            DO UPDATE SET work_experience = EXCLUDED.work_experience
        ''', (user_id, work_experience))

        conn.commit()

        await update.message.reply_text("✔️ Your work experience has been saved successfully!")

        # Display the updated profile summary
        return await handle_edit_applicant_profile(update, context)


    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating work experience: {error}")
        await update.message.reply_text("An error occurred while saving your work experience.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return await show_applicant_profile_edit_menu(update, context)

async def save_applicant_education(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    education = update.message.text  # The education details entered by the user

    if education.lower() == "🔙 back":
        return await show_applicant_profile_edit_menu(update, context)

    try:
        logger.debug("Connecting to database to save education")
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return APPLICANT_PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Ensure full_name exists before proceeding
        cursor.execute('SELECT full_name FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
        full_name_row = cursor.fetchone()

        if not full_name_row or not full_name_row[0]:
            await update.message.reply_text("You must provide your Full Name before saving other details.")
            return await ask_for_full_name(update, context)

        # Insert or update the education details in applicant_profiles
        cursor.execute('''
            INSERT INTO applicant_profiles (applicant_id, highest_degree)
            VALUES (%s, %s)
            ON CONFLICT (applicant_id)
            DO UPDATE SET highest_degree = EXCLUDED.highest_degree
        ''', (user_id, education))

        conn.commit()

        await update.message.reply_text("✔️ Your education information has been saved successfully!")

        # Display the updated profile summary
        return await handle_edit_applicant_profile(update, context)


    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating education: {error}")
        await update.message.reply_text("An error occurred while saving your education details.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return await show_applicant_profile_edit_menu(update, context)


async def save_applicant_employment_type(update: Update, context: CallbackContext) -> int:
    """
    Save the selected employment types for the applicant, limit the selection to 3,
    and allow deselection of already registered values with proper handling of check marks.
    """
    employment_type = update.message.text.strip()

    # Normalize the employment type by removing the check mark, if present
    employment_type = employment_type.replace("✔️", "").strip()

    logger.debug(f"Normalized employment type: {employment_type}")

    # Handle "Back" button
    if employment_type.lower() == "🔙 back":
        logger.debug("User pressed 'Back' button")
        return await show_applicant_profile_edit_menu(update, context)

    # Handle "Done" button when user finishes selecting employment types
    if employment_type == "✅ Done":
        logger.debug("User pressed 'Done' button")
        selected_types = context.user_data.get('selected_employment_types', [])

        if not selected_types:
            await update.message.reply_text("Please select at least one employment type.")
            return APPLICANT_EMPLOYMENT_TYPE

        try:
            # Connect to PostgreSQL database
            conn = psycopg2.connect(
                dbname="my_project_db",
                user="postgres",
                password="1201",
                host="localhost",
                port="5432"
            )
            logger.debug("Connected to database successfully")
            cursor = conn.cursor()

            # Fetch user_id based on chat_id
            user_chat_id = update.message.chat_id
            cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
            user_row = cursor.fetchone()

            if not user_row:
                await update.message.reply_text("You are not registered. Please register.")
                return APPLICANT_PROFILE_EDIT_MENU

            user_id = user_row[0]

            # Check if full_name exists
            cursor.execute('SELECT full_name FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
            full_name_row = cursor.fetchone()

            if not full_name_row or not full_name_row[0]:
                await update.message.reply_text(
                    "You must provide your Full Name before saving your Employment Type. Please enter your Full Name first."
                )
                return await ask_for_full_name(update, context)

            # Save selected employment types as a comma-separated string
            employment_types_str = ', '.join(selected_types)  # Join without braces
            cursor.execute('''
                UPDATE applicant_profiles 
                SET employment_type = %s
                WHERE applicant_id = %s
            ''', (employment_types_str, user_id))
            conn.commit()

            # Notify the user
            await update.message.reply_text(f"✔️ Your Employment Type(s) have been saved: {employment_types_str}")
            logger.debug(f"Employment types saved: {employment_types_str}")

            # Display the updated profile summary
            return await handle_edit_applicant_profile(update, context)


        except (Exception, psycopg2.DatabaseError) as error:
            logger.error(f"Error updating employment type: {error}")
            await update.message.reply_text("An error occurred while updating your Employment Type.")

        finally:
            if conn:
                cursor.close()
                conn.close()

        # Clear selected employment types from context after saving
        context.user_data.pop('selected_employment_types', None)

        # Return to the profile edit menu after saving
        return await show_applicant_profile_edit_menu(update, context)

    # Add or remove employment types from the list
    valid_employment_types = context.user_data.get('valid_employment_types', [])
    selected_types = context.user_data.get('selected_employment_types', [])

    if employment_type not in valid_employment_types:
        await update.message.reply_text("⚠️ Invalid selection. Please choose a valid employment type.")
        return APPLICANT_EMPLOYMENT_TYPE

    if employment_type in selected_types:
        selected_types.remove(employment_type)
        message = f"❌ {employment_type} removed. Current selection: {', '.join(selected_types)}."
    else:
        if len(selected_types) >= 3:
            await update.message.reply_text("⚠️ You can only select up to 3 employment types. Please deselect one before adding another.")
            return APPLICANT_EMPLOYMENT_TYPE

        selected_types.append(employment_type)
        message = f"✔️ {employment_type} added. Current selection: {', '.join(selected_types)}."

    # Store updated list back in context
    context.user_data['selected_employment_types'] = selected_types

    # Notify the user of the update
    await update.message.reply_text(
        f"{message}\nYou can select more or press '✅ Done' when finished."
    )

    logger.debug(f"Updated selected types: {selected_types}")
    return APPLICANT_EMPLOYMENT_TYPE



# Save the availability (ensure full_name exists and handle "Immediately" case)
async def save_applicant_availability(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    availability = update.message.text.lower()

    # Check if the user pressed the "Back" button
    if availability == "🔙 back":
        return await show_applicant_profile_edit_menu(update, context)

    # Handle different availability options
    today = datetime.now().date()
    if availability == "immediately":
        availability = today  # Use current date for "Immediately"
    elif availability == "in 1 week":
        availability = today + timedelta(weeks=1)  # Calculate the date 1 week from today
    elif availability == "in 2 weeks":
        availability = today + timedelta(weeks=2)  # Calculate the date 2 weeks from today
    elif availability == "in a month":
        availability = today + timedelta(weeks=4)  # Calculate the date 1 month (approx) from today
    else:
        # Try to parse the availability date (assuming user enters valid dates)
        try:
            # Assuming the user enters the date in 'YYYY-MM-DD' format
            availability = datetime.strptime(availability, "%Y-%m-%d").date()
        except ValueError:
            await update.message.reply_text("Invalid date format. Please enter the date in 'YYYY-MM-DD' format.")
            return APPLICANT_AVAILABILITY

    try:
        # Connect to PostgreSQL database
        logger.debug("Connecting to database to save availability")
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return APPLICANT_PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Check if full_name exists in the applicant_profiles table
        cursor.execute('SELECT full_name FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
        full_name_row = cursor.fetchone()

        # If full_name is missing, prompt the user to enter their full name first
        if not full_name_row or not full_name_row[0]:
            await update.message.reply_text(
                "You must provide your Full Name before saving your Availability. Please enter your Full Name first."
            )
            return await ask_for_full_name(update, context)

        # Update the availability in the applicant_profiles table
        cursor.execute('''
            UPDATE applicant_profiles 
            SET availability = %s
            WHERE applicant_id = %s
        ''', (availability, user_id))

        conn.commit()

        # Notify the user that the availability has been saved
        await update.message.reply_text("✔️ Your availability has been saved successfully.")

        # Display the updated profile summary
        return await handle_edit_applicant_profile(update, context)


    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating availability: {error}")
        await update.message.reply_text("An error occurred while updating your availability.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return await show_applicant_profile_edit_menu(update, context)

# Save the certifications (use user_id as applicant_id and ensure full_name is present)
async def save_applicant_certifications(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    certifications = update.message.text

    # Check if the user pressed the "Back" button
    if certifications.lower() == "🔙 back":
        return await show_applicant_profile_edit_menu(update, context)

    # Split certifications into a list
    certification_list = [cert.strip() for cert in certifications.split(',')]

    try:
        # Connect to PostgreSQL database
        logger.debug("Connecting to database to save certifications")
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return APPLICANT_PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Ensure full_name exists in the database before saving certifications
        cursor.execute('SELECT full_name FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
        full_name_row = cursor.fetchone()

        if not full_name_row or not full_name_row[0]:  # Check if full_name is missing
            await update.message.reply_text(
                "You must provide your Full Name before saving other details."
            )
            return await ask_for_full_name(update, context)

        # Insert or update the certifications in applicant_profiles
        cursor.execute('''
            UPDATE applicant_profiles 
            SET certifications = %s
            WHERE applicant_id = %s
        ''', (certification_list, user_id))

        conn.commit()

        # Notify the user that the certifications have been saved
        await update.message.reply_text("✔️ Certifications have been saved successfully!")

        # Display the updated profile summary
        return await handle_edit_applicant_profile(update, context)


    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating certifications: {error}")
        await update.message.reply_text("An error occurred while updating your certifications.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    # Proceed back to the profile edit menu
    return await show_applicant_profile_edit_menu(update, context)



# Save Highest Degree
async def save_applicant_highest_degree(update: Update, context: CallbackContext) -> int:
    """
    Save the selected highest degrees for the applicant, ensuring deselected degrees are removed.
    """
    user_chat_id = update.message.chat_id
    selected_degree = update.message.text.strip()

    # Normalize the selected degree by removing the check mark, if present
    normalized_degree = selected_degree.replace("✔️", "").strip()

    # Handle the "Back" button
    if normalized_degree.lower() == "🔙 back":
        return await show_applicant_profile_edit_menu(update, context)

    # Handle the "Done" button
    if normalized_degree.lower() == "✅ done":
        # Fetch and save all selected degrees
        selected_degrees = context.user_data.get("selected_degrees", [])

        if not selected_degrees:
            await update.message.reply_text("You have not selected any degrees.")
            return APPLICANT_HIGHEST_DEGREE  # Keep the user in the current state

        try:
            # Connect to PostgreSQL database
            conn = psycopg2.connect(
                dbname="my_project_db",
                user="postgres",
                password="1201",
                host="localhost",
                port="5432"
            )
            cursor = conn.cursor()

            # Fetch user_id based on chat_id
            cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
            user_row = cursor.fetchone()

            if not user_row:
                await update.message.reply_text("You are not registered. Please register.")
                return APPLICANT_PROFILE_EDIT_MENU

            user_id = user_row[0]

            # Ensure full_name exists before saving
            cursor.execute('SELECT full_name FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
            full_name_row = cursor.fetchone()

            if not full_name_row or not full_name_row[0]:
                await update.message.reply_text("You must provide your Full Name before saving other details.")
                return await ask_for_full_name(update, context)

            # Save the degrees as a comma-separated string
            cursor.execute('''
                UPDATE applicant_profiles 
                SET highest_degree = %s
                WHERE applicant_id = %s
            ''', (', '.join(selected_degrees), user_id))

            conn.commit()

            # Notify the user that the degrees have been saved
            await update.message.reply_text(f"✔️ Your highest degree(s) have been saved successfully: {', '.join(selected_degrees)}.")

            # Display the updated profile summary
            return await handle_edit_applicant_profile(update, context)


        except (Exception, psycopg2.DatabaseError) as error:
            logger.error(f"Error updating highest degrees: {error}")
            await update.message.reply_text("An error occurred while updating your highest degrees.")

        finally:
            if conn:
                cursor.close()
                conn.close()

        # Clear selected degrees from context
        context.user_data.pop("selected_degrees", None)

        return await show_applicant_profile_edit_menu(update, context)

    # Handle adding or toggling the selected degree
    valid_degrees = context.user_data.get("valid_degrees", [])
    if normalized_degree not in valid_degrees:
        await update.message.reply_text("⚠️ Invalid selection. Please choose a valid degree from the options provided.")
        return APPLICANT_HIGHEST_DEGREE  # Stay in the current state

    # Toggle the selected degree
    selected_degrees = context.user_data.get("selected_degrees", [])
    if normalized_degree in selected_degrees:
        selected_degrees.remove(normalized_degree)  # Properly remove the degree from the list
        context.user_data["selected_degrees"] = selected_degrees  # Update the context
        message = f"❌ {normalized_degree} removed. Current selection: {', '.join(selected_degrees)}."
    else:
        if len(selected_degrees) >= 3:
            await update.message.reply_text("⚠️ You can only select up to 3 degrees. Please deselect one before adding another.")
            return APPLICANT_HIGHEST_DEGREE  # Stay in the current state

        selected_degrees.append(normalized_degree)  # Add the degree to the list
        context.user_data["selected_degrees"] = selected_degrees  # Update the context
        message = f"✔️ {normalized_degree} added. Current selection: {', '.join(selected_degrees)}."

    # Display the updated selection
    await update.message.reply_text(
        f"{message}\nYou can select more or press '✅ Done' when finished."
    )

    return APPLICANT_HIGHEST_DEGREE  # Stay in the current state to allow more selections


async def save_applicant_university(update: Update, context: CallbackContext) -> int:
    """
    Save the selected university for the applicant.
    """
    user_chat_id = update.message.chat_id
    selected_university = update.message.text.strip()  # Get the user's selected university

    # Handle the "Back" button
    if selected_university.lower() == "🔙 back":
        return await show_applicant_profile_edit_menu(update, context)

    try:
        # Connect to the PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id based on chat_id
        cursor.execute("SELECT user_id FROM users WHERE contact = %s", (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register first.")
            return  # End the conversation if the user is not registered

        user_id = user_row[0]

        # Ensure the university is valid (fetched from context)
        valid_universities = context.user_data.get("valid_universities", [])
        if selected_university not in valid_universities:
            await update.message.reply_text(
                "⚠️ Invalid university selected. Please choose from the options provided."
            )
            return APPLICANT_UNIVERSITY  # Return to the university selection state

        # Update the university information in the applicant_profiles table
        cursor.execute(
            "UPDATE applicant_profiles SET university = %s WHERE applicant_id = %s",
            (selected_university, user_id)
        )
        conn.commit()

        # Notify the user of the successful update
        await update.message.reply_text(
            f"✔️ Your university has been successfully updated to: *{selected_university}*.",
            parse_mode="Markdown"
        )

        # Display the updated profile summary
        return await handle_edit_applicant_profile(update, context)


    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating university: {error}")
        await update.message.reply_text(
            "⚠️ An error occurred while updating your university. Please try again later."
        )

    finally:
        # Ensure the database connection is closed
        if conn:
            cursor.close()
            conn.close()

    # Redirect the user back to the applicant profile edit menu
    return await show_applicant_profile_edit_menu(update, context)


async def save_applicant_college(update: Update, context: CallbackContext) -> int:
    """
    Save the selected college for the applicant.
    """
    user_chat_id = update.message.chat_id
    selected_college = update.message.text.strip()  # Get the user's selected college

    # Handle the "Back" button
    if selected_college.lower() == "🔙 back":
        return await show_applicant_profile_edit_menu(update, context)

    try:
        # Connect to the PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id based on chat_id
        cursor.execute("SELECT user_id FROM users WHERE contact = %s", (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register first.")
            return  # End the conversation if the user is not registered

        user_id = user_row[0]

        # Ensure the college is valid (fetched from context)
        valid_colleges = context.user_data.get("valid_colleges", [])
        if selected_college not in valid_colleges:
            await update.message.reply_text(
                "⚠️ Invalid college selected. Please choose from the options provided."
            )
            return APPLICANT_COLLEGE  # Return to the college selection state

        # Update the college information in the applicant_profiles table
        cursor.execute(
            "UPDATE applicant_profiles SET college = %s WHERE applicant_id = %s",
            (selected_college, user_id)
        )
        conn.commit()

        # Notify the user that the college information has been saved
        await update.message.reply_text(
            f"✔️ Your college has been successfully updated to: *{selected_college}*.",
            parse_mode="Markdown"
        )
        # Display the updated profile summary
        return await handle_edit_applicant_profile(update, context)


    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating college information: {error}")
        await update.message.reply_text(
            "❌ An error occurred while updating your college information. Please try again later."
        )

    finally:
        # Close the database connection
        if conn:
            cursor.close()
            conn.close()

    # Redirect the user back to the applicant profile edit menu
    return await show_applicant_profile_edit_menu(update, context)



# Function to save GPA (ensure valid input and full_name exists)
async def save_applicant_gpa(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    gpa_input = update.message.text

    # Check if the user pressed the "Back" button
    if gpa_input.lower() == "🔙 back":
        return await show_applicant_profile_edit_menu(update, context)

    # Validate GPA input
    try:
        gpa = float(gpa_input)
        if not (0.0 <= gpa <= 4.0):  # Typical GPA range, adjust as needed
            raise ValueError("Invalid GPA range")
    except ValueError:
        await update.message.reply_text("Invalid GPA. Please enter a valid GPA (e.g., 3.5).")
        return APPLICANT_GPA  # Go back to asking for GPA

    try:
        # Connect to PostgreSQL database
        logger.debug("Connecting to database to save GPA")
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return APPLICANT_PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Ensure full_name exists in the applicant_profiles table before saving GPA
        cursor.execute('SELECT full_name FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
        full_name_row = cursor.fetchone()

        if not full_name_row or not full_name_row[0]:  # Check if full_name is missing
            await update.message.reply_text("You must provide your Full Name before saving other details.")
            return await ask_for_full_name(update, context)

        # Insert or update the GPA in applicant_profiles
        cursor.execute('''
            UPDATE applicant_profiles
            SET gpa = %s
            WHERE applicant_id = %s
        ''', (gpa, user_id))

        conn.commit()

        # Notify the user that the GPA has been saved
        await update.message.reply_text(f"✔️ Your GPA ({gpa}) has been saved successfully!")

        # Display the updated profile summary
        return await handle_edit_applicant_profile(update, context)


    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating GPA: {error}")
        await update.message.reply_text("An error occurred while updating your GPA.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return await show_applicant_profile_edit_menu(update, context)



# Function to save Graduation Year
async def save_applicant_graduation_year(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    graduation_year = update.message.text
    conn = None  # Initialize conn to avoid unbound variable error
    # Check if the user pressed the "Back" button
    if graduation_year.lower() == "🔙 back":
        return await show_applicant_profile_edit_menu(update, context)

    try:
        # Ensure the input is a valid year
        if not graduation_year.isdigit() or len(graduation_year) != 4:
            await update.message.reply_text("Please enter a valid 4-digit year (e.g., '2020').")
            return APPLICANT_GRADUATION_YEAR

        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return APPLICANT_PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Ensure full_name exists before saving graduation year
        cursor.execute('SELECT full_name FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
        full_name_row = cursor.fetchone()

        if not full_name_row or not full_name_row[0]:
            await update.message.reply_text("You must provide your Full Name before saving your graduation year.")
            return await ask_for_full_name(update, context)

        # Insert or update the graduation year in applicant_profiles
        cursor.execute('''
            UPDATE applicant_profiles 
            SET graduation_year = %s
            WHERE applicant_id = %s
        ''', (graduation_year, user_id))

        conn.commit()

        # Notify the user that the graduation year has been saved
        await update.message.reply_text("✔️ Your Graduation Year has been saved successfully!")

        # Display the updated profile summary
        return await handle_edit_applicant_profile(update, context)


    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating graduation year: {error}")
        await update.message.reply_text("An error occurred while updating your graduation year.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return await show_applicant_profile_edit_menu(update, context)


async def save_applicant_languages(update: Update, context: CallbackContext) -> int:
    """
    Save the selected languages for the applicant, limiting the selection to a maximum of 5.
    """
    user_chat_id = update.message.chat_id
    selected_language = update.message.text.strip()

    # Normalize the selected language by removing the check mark, if present
    selected_language = selected_language.replace("✔️", "").strip()

    # Handle the "Back" button
    if selected_language.lower() == "🔙 back":
        return await show_applicant_profile_edit_menu(update, context)

    # Handle the "Done" button
    if selected_language.lower() == "✅ done":
        # Fetch and save all selected languages
        selected_languages = context.user_data.get("selected_languages", [])

        if not selected_languages:
            await update.message.reply_text("You have not selected any languages.")
            return APPLICANT_LANGUAGES  # Keep the user in the current state

        try:
            # Connect to PostgreSQL database
            conn = psycopg2.connect(
                dbname="my_project_db",
                user="postgres",
                password="1201",
                host="localhost",
                port="5432"
            )
            cursor = conn.cursor()

            # Fetch user_id based on chat_id
            cursor.execute("SELECT user_id FROM users WHERE contact = %s", (str(user_chat_id),))
            user_row = cursor.fetchone()

            if not user_row:
                await update.message.reply_text("You are not registered. Please register first.")
                return

            user_id = user_row[0]

            # Ensure full_name exists before saving
            cursor.execute("SELECT full_name FROM applicant_profiles WHERE applicant_id = %s", (user_id,))
            full_name_row = cursor.fetchone()

            if not full_name_row or not full_name_row[0]:
                await update.message.reply_text("You must provide your Full Name before saving other details.")
                return await ask_for_full_name(update, context)

            # Save the languages as a PostgreSQL array
            cursor.execute(
                "UPDATE applicant_profiles SET languages = %s WHERE applicant_id = %s",
                (selected_languages, user_id)
            )
            conn.commit()

            # Notify the user that the languages have been saved
            await update.message.reply_text("✔️ Your Languages have been saved successfully!")

            # Display the updated profile summary
            return await handle_edit_applicant_profile(update, context)


        except (Exception, psycopg2.DatabaseError) as error:
            logger.error(f"Error updating languages: {error}")
            await update.message.reply_text("An error occurred while updating your languages.")

        finally:
            if conn:
                cursor.close()
                conn.close()

        # Clear selected languages from context
        context.user_data.pop("selected_languages", None)

        return await show_applicant_profile_edit_menu(update, context)

    # Handle adding or toggling the selected language
    valid_languages = context.user_data.get("valid_languages", [])
    if selected_language not in valid_languages:
        await update.message.reply_text("⚠️ Invalid selection. Please choose a valid Language from the options provided.")
        return APPLICANT_LANGUAGES  # Stay in the current state

    # Toggle the selected language with a limit of 5
    selected_languages = context.user_data.get("selected_languages", [])
    if selected_language in selected_languages:
        selected_languages.remove(selected_language)  # Deselect language
        message = f"❌ {selected_language} removed. Current selection: {', '.join(selected_languages)}."
    else:
        if len(selected_languages) >= 5:
            await update.message.reply_text("⚠️ You can only select up to 5 languages. Please deselect one before adding another.")
            return APPLICANT_LANGUAGES  # Stay in the current state

        selected_languages.append(selected_language)  # Select language
        message = f"✔️ {selected_language} added. Current selection: {', '.join(selected_languages)}."

    # Update the context with the modified list
    context.user_data["selected_languages"] = selected_languages

    # Redisplay the selection status
    await update.message.reply_text(
        f"{message}\nYou can select more or press '✅ Done' when finished."
    )

    return APPLICANT_LANGUAGES  # Stay in the current state to allow more selections


import re

def is_valid_url(url):
    """Validate if the input is a proper URL."""
    url_regex = re.compile(
        r'^(https?://)?'  # Optional http:// or https://
        r'(([a-zA-Z0-9_-]+\.)+[a-zA-Z]{2,})'  # Domain name
        r'(/[a-zA-Z0-9._/?=&%-]*)?$'  # Optional path
    )
    return re.match(url_regex, url) is not None

async def save_applicant_portfolio(update: Update, context: CallbackContext, current_link: str) -> int:
    """Save a portfolio link for the user."""
    user_chat_id = update.message.chat_id
    portfolio_link = update.message.text.strip()

    if portfolio_link.lower() == "🔙 back":
        return await ask_for_portfolio(update, context)

    if portfolio_link.lower() == "done":
        await update.message.reply_text(
            "✅ Portfolio links saved successfully! Returning to profile menu."
        )
        return await handle_edit_applicant_profile(update, context)

    if not is_valid_url(portfolio_link):
        await update.message.reply_text(
            "Invalid URL. Please provide a valid link (e.g., https://example.com)."
        )
        return APPLICANT_PORTFOLIO_LINK

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return APPLICANT_PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Get existing portfolio links
        cursor.execute('SELECT portfolio_link FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
        portfolio_links = cursor.fetchone()

        existing_links = portfolio_links[0] if portfolio_links and portfolio_links[0] else ""

        # Append the new link
        updated_links = ','.join(filter(None, [existing_links, portfolio_link]))

        # Update the portfolio_link column
        cursor.execute('''
            UPDATE applicant_profiles
            SET portfolio_link = %s
            WHERE applicant_id = %s
        ''', (updated_links, user_id))

        conn.commit()
        await update.message.reply_text("✔️ Portfolio link saved successfully!")




    except psycopg2.DatabaseError as db_error:
        logger.error(f"Database error: {db_error}")
        await update.message.reply_text("Database issue. Please try again later.")
    except Exception as error:
        logger.error(f"Unexpected error: {error}")
        await update.message.reply_text("An unexpected error occurred.")
    finally:
        if conn:
            cursor.close()
            conn.close()

    return await ask_for_portfolio(update, context)

async def handle_portfolio_input(update: Update, context: CallbackContext) -> int:
    """Handles the portfolio link input dynamically based on the current context."""
    current_link = context.user_data.get("current_link", "portfolio_link")
    return await save_applicant_portfolio(update, context, current_link)


from telegram import InlineKeyboardButton, InlineKeyboardMarkup

async def view_links(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    if query:
        await query.answer()
        user_chat_id = query.message.chat_id
    else:
        user_chat_id = update.message.chat_id  # Handle case when there's no callback query

    conn = None  # Initialize connection to ensure safety in `finally`
    cursor = None

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            if query:
                await query.edit_message_text("You are not registered.")
            else:
                await update.message.reply_text("You are not registered.")
            return APPLICANT_PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Get existing portfolio links
        cursor.execute('SELECT portfolio_link FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
        portfolio_links = cursor.fetchone()

        if not portfolio_links or not portfolio_links[0]:
            if query:
                await query.edit_message_text("No portfolio links saved yet.")
            else:
                await update.message.reply_text("No portfolio links saved yet.")
            return APPLICANT_PORTFOLIO

        links_list = portfolio_links[0].split(',')

        keyboard = []
        for idx, link in enumerate(links_list, start=1):
            keyboard.append([
                InlineKeyboardButton(f"Edit {idx}", callback_data=f"edit_{idx}"),
                InlineKeyboardButton(f"Delete {idx}", callback_data=f"delete_{idx}")
            ])

        reply_markup = InlineKeyboardMarkup(keyboard)

        message = "Your saved portfolio links:\n\n"
        for idx, link in enumerate(links_list, start=1):
            message += f"{idx}. {link}\n"

        if query:
            await query.edit_message_text(message, reply_markup=reply_markup)
        else:
            await update.message.reply_text(message, reply_markup=reply_markup)

        return APPLICANT_PORTFOLIO_EDIT

    except psycopg2.DatabaseError as db_error:
        logger.error(f"Database error: {db_error}")
        if query:
            await query.edit_message_text("Database issue. Please try again later.")
        else:
            await update.message.reply_text("Database issue. Please try again later.")
    except Exception as error:
        logger.error(f"Unexpected error: {error}")
        if query:
            await query.edit_message_text("An unexpected error occurred.")
        else:
            await update.message.reply_text("An unexpected error occurred.")
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

    return APPLICANT_PORTFOLIO


async def handle_edit_or_delete_link(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()
    user_chat_id = query.message.chat_id
    callback_data = query.data

    action, index = callback_data.split('_')
    index = int(index) - 1  # Convert to 0-based index

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await query.edit_message_text("You are not registered.")
            return APPLICANT_PROFILE_EDIT_MENU

        applicant_id = user_row[0]

        # Get existing portfolio links
        cursor.execute('SELECT portfolio_link FROM applicant_profiles WHERE applicant_id = %s', (applicant_id,))
        portfolio_links = cursor.fetchone()

        if not portfolio_links or not portfolio_links[0]:
            await query.edit_message_text("No portfolio links found.")
            return APPLICANT_PORTFOLIO

        links_list = portfolio_links[0].split(',')

        if action == 'edit':
            context.user_data['edit_link_index'] = index
            await query.edit_message_text(f"Current link: {links_list[index]}\nPlease send the new link.")
            return APPLICANT_PORTFOLIO_EDIT_LINK

        elif action == 'delete':
            links_list.pop(index)
            updated_links = ','.join(links_list)
            cursor.execute('''
                UPDATE applicant_profiles
                SET portfolio_link = %s
                WHERE applicant_id = %s
            ''', (updated_links, applicant_id))
            conn.commit()
            await query.edit_message_text("Link deleted successfully.")
            return await view_links(update, context)

    except psycopg2.DatabaseError as db_error:
        logger.error(f"Database error: {db_error}")
        await query.edit_message_text("Database issue. Please try again later.")
    except Exception as error:
        logger.error(f"Unexpected error: {error}")
        await query.edit_message_text("An unexpected error occurred.")
    finally:
        if conn:
            cursor.close()
            conn.close()

    return APPLICANT_PORTFOLIO


async def save_edited_link(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    new_link = update.message.text.strip()

    # Handle the "Back" button
    if new_link.lower() == "🔙 back":
        return await view_links(update, context)

    if not is_valid_url(new_link):
        await update.message.reply_text("Invalid URL. Please try again.")
        return APPLICANT_PORTFOLIO_EDIT_LINK

    conn = None  # Initialize to avoid issues in `finally`
    cursor = None

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user ID
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered.")
            return APPLICANT_PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Fetch portfolio links
        cursor.execute('SELECT portfolio_link FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
        portfolio_links = cursor.fetchone()[0]

        links_list = portfolio_links.split(',')

        link_index = context.user_data.get('edit_link_index')
        if link_index is None or link_index < 0 or link_index >= len(links_list):
            await update.message.reply_text("Invalid link index. Please try again.")
            return APPLICANT_PORTFOLIO

        # Update the link
        links_list[link_index] = new_link
        updated_links = ','.join(links_list)

        cursor.execute('''
            UPDATE applicant_profiles
            SET portfolio_link = %s
            WHERE applicant_id = %s
        ''', (updated_links, user_id))

        conn.commit()

        await update.message.reply_text("Link updated successfully.")
        return await view_links(update, context)

    except psycopg2.DatabaseError as db_error:
        logger.error(f"Database error: {db_error}")
        await update.message.reply_text("Database issue. Please try again.")
    except Exception as e:
        logger.error(f"Error saving edited link: {e}")
        await update.message.reply_text("An unexpected error occurred.")
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

    return APPLICANT_PORTFOLIO



async def save_applicant_resume(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id

    if update.message.text and update.message.text.lower() == "🔙 back":
        return await show_applicant_profile_edit_menu(update, context)

    try:
        logger.debug("Connecting to database to save resume")
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return APPLICANT_PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Ensure full_name exists before proceeding
        cursor.execute('SELECT full_name FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
        full_name_row = cursor.fetchone()

        if not full_name_row or not full_name_row[0]:
            await update.message.reply_text("You must provide your Full Name before saving other details.")
            return await ask_for_full_name(update, context)

        # Check if the user uploaded a document
        if update.message.document:
            # Get the file from Telegram and download it
            file = await update.message.document.get_file()
            file_path = f"resume_{user_chat_id}.pdf"
            await file.download(file_path)
            resume_link = file_path
        else:
            resume_link = None

        # Insert or update the resume file path in applicant_profiles
        cursor.execute('''
            INSERT INTO applicant_profiles (applicant_id, resume)
            VALUES (%s, %s)
            ON CONFLICT (applicant_id)
            DO UPDATE SET resume = EXCLUDED.resume
        ''', (user_id, resume_link))

        conn.commit()

        await update.message.reply_text("Your resume has been saved successfully!")

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating resume: {error}")
        await update.message.reply_text("An error occurred while saving your resume.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return await show_applicant_profile_edit_menu(update, context)


# Save Profile Picture
async def save_applicant_profile_picture(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id

    # Check if the user pressed the "Back" button
    if update.message.text and update.message.text.lower() == "🔙 back":
        return await handle_edit_applicant_profile(update, context)

    try:
        logging.debug("Connecting to database to save profile picture")
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id and existing profile
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return APPLICANT_PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Check if full_name is already set
        cursor.execute('SELECT full_name FROM applicant_profiles WHERE applicant_id = %s', (user_id,))
        full_name_row = cursor.fetchone()

        if not full_name_row or not full_name_row[0]:
            await update.message.reply_text("You must provide your Full Name before saving other details.")
            return await ask_for_full_name(update, context)

        # Check if the user uploaded a photo
        if update.message.photo:
            # Store the file_id of the photo
            file_id = update.message.photo[-1].file_id
        else:
            await update.message.reply_text("Please upload a valid image as your profile picture.")
            return APPLICANT_PROFILE_PICTURE

        # Update only the profile picture (file_id) without altering other required fields
        cursor.execute('''
            UPDATE applicant_profiles
            SET profile_picture = %s
            WHERE applicant_id = %s
        ''', (file_id, user_id))

        conn.commit()
        await update.message.reply_text("Your profile picture has been saved successfully!")

        # Display the updated profile summary
        return await handle_edit_applicant_profile(update, context)

    except (Exception, psycopg2.DatabaseError) as error:
        logging.error(f"Error updating profile picture: {error}")
        await update.message.reply_text("An error occurred while saving your profile picture.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return await handle_edit_applicant_profile(update, context)

async def handle_download_profile_picture(update: Update, context: CallbackContext) -> None:
    """Handles downloading the profile picture based on the inline button."""
    query = update.callback_query
    user_id = query.data.split("_")[-1]  # Extract user_id from callback data

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch the profile picture path
        cursor.execute('''
            SELECT profile_picture
            FROM applicant_profiles
            WHERE applicant_id = %s
        ''', (user_id,))
        profile_picture_row = cursor.fetchone()

        if not profile_picture_row or not profile_picture_row[0]:
            await query.answer("No profile picture available for download.", show_alert=True)
            return

        profile_picture_path = profile_picture_row[0]

        # Send the profile picture as a downloadable file, replying to the profile summary message
        await context.bot.send_document(
            chat_id=query.message.chat_id,
            document=open(profile_picture_path, 'rb'),
            caption="Here is your profile picture.",
            reply_to_message_id=query.message.message_id  # Reply to the profile summary
        )
        await query.answer("Profile picture sent for download.")

    except Exception as e:
        logging.error(f"Error downloading profile picture: {e}")
        await query.message.reply_text("An error occurred while downloading the profile picture.")
    finally:
        if conn:
            cursor.close()
            conn.close()




import psycopg2
import logging
from telegram import Update
from telegram.ext import CallbackContext

logger = logging.getLogger(__name__)

def escape_markdown_v2(text):
    """Escape Markdown V2 special characters."""
    escape_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
    if text:
        for char in escape_chars:
            text = text.replace(char, f"\\{char}")
    return text

# Handler for Active Applications
async def handle_active_applications(update: Update, context: CallbackContext) -> int:
    user_id = update.effective_user.id  # Telegram user ID

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Query to fetch active applications for the user
        cursor.execute('''
            SELECT jp.job_title, jp.job_type, jp.job_site, jp.channel_username, jp.message_id, a.application_date
            FROM applications a
            JOIN job_posts jp ON a.job_id = jp.job_id
            WHERE a.user_id = (SELECT user_id FROM users WHERE contact = %s::TEXT)
              AND a.status IN ('pending', 'shortlisted', 'hired')
            ORDER BY a.application_date DESC
        ''', (str(user_id),))
        active_applications = cursor.fetchall()

        if not active_applications:
            await update.message.reply_text("You currently have no active applications.")
            return APPLICATIONS_MENU

        for job_title, job_type, job_site, channel_username, message_id, application_date in active_applications:
            clean_channel_username = channel_username.lstrip('@')
            formatted_application = (
                f"📌 *Job Title:* [{escape_markdown_v2(job_title)}](https://t.me/{clean_channel_username}/{message_id})\n"
                f"\n🛠 *Job Type:* {escape_markdown_v2(job_type)}\n"
                f"\n🌍 *Job Site:* {escape_markdown_v2(job_site)}\n"
                f"\n📅 *Applied On:* {escape_markdown_v2(application_date.strftime('%Y-%m-%d'))}"
            )

            await update.message.reply_text(
                formatted_application,
                parse_mode="MarkdownV2"
            )

    except Exception as e:
        logger.error(f"Error fetching active applications for user {user_id}: {e}")
        await update.message.reply_text("An error occurred while fetching your active applications.")
    finally:
        if conn:
            cursor.close()
            conn.close()

    return APPLICATIONS_MENU



import psycopg2
import logging
from telegram import Update
from telegram.ext import CallbackContext

logger = logging.getLogger(__name__)

def escape_markdown_v2(text):
    """Escape Markdown V2 special characters."""
    escape_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
    if text:
        for char in escape_chars:
            text = text.replace(char, f"\\{char}")
    return text

# Handler for Application Status
async def handle_application_status(update: Update, context: CallbackContext) -> int:
    user_id = update.effective_user.id  # Telegram user ID

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Query to fetch application status for the user
        cursor.execute('''
            SELECT jp.job_title, a.status, a.application_date, jp.channel_username, jp.message_id
            FROM applications a
            JOIN job_posts jp ON a.job_id = jp.job_id
            WHERE a.user_id = (SELECT user_id FROM users WHERE contact = %s::TEXT)
            ORDER BY a.application_date DESC
        ''', (str(user_id),))
        applications = cursor.fetchall()

        if not applications:
            await update.message.reply_text("You currently have no applications.")
            return APPLICATIONS_MENU

        for job_title, status, application_date, channel_username, message_id in applications:
            clean_channel_username = channel_username.lstrip('@')
            formatted_status = (
                f"📌 *Job Title:* [{escape_markdown_v2(job_title)}](https://t.me/{clean_channel_username}/{message_id})\n"
                f"\n📅 *Applied On:* {escape_markdown_v2(application_date.strftime('%Y-%m-%d'))}\n"
                f"\n📊 *Status:* {escape_markdown_v2(status.capitalize())}"
            )

            await update.message.reply_text(
                formatted_status,
                parse_mode="MarkdownV2"
            )

    except Exception as e:
        logger.error(f"Error fetching application status for user {user_id}: {e}")
        await update.message.reply_text("An error occurred while fetching your application statuses.")
    finally:
        if conn:
            cursor.close()
            conn.close()

    return APPLICATIONS_MENU



import psycopg2
import logging
from telegram import Update
from telegram.ext import CallbackContext

logger = logging.getLogger(__name__)

def escape_markdown_v2(text):
    """Escape Markdown V2 special characters."""
    escape_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
    if text:
        for char in escape_chars:
            text = text.replace(char, f"\\{char}")
    return text

# Handler for History of Applied Jobs
async def handle_history_of_applied_jobs(update: Update, context: CallbackContext) -> int:
    user_id = update.effective_user.id  # Telegram user ID

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Query to fetch history of applied jobs
        cursor.execute('''
            SELECT jp.job_title, a.application_date, a.status, jp.channel_username, jp.message_id
            FROM applications a
            JOIN job_posts jp ON a.job_id = jp.job_id
            WHERE a.user_id = (SELECT user_id FROM users WHERE contact = %s::TEXT)
            ORDER BY a.application_date DESC
        ''', (str(user_id),))
        applications = cursor.fetchall()

        if not applications:
            await update.message.reply_text("You have not applied for any jobs yet.")
            return APPLICATIONS_MENU

        for job_title, application_date, status, channel_username, message_id in applications:
            clean_channel_username = channel_username.lstrip('@')
            job_info = (
                f"📌 *Job Title:* [{escape_markdown_v2(job_title)}](https://t.me/{clean_channel_username}/{message_id})\n"
                f"\n📅 *Applied On:* {escape_markdown_v2(application_date.strftime('%Y-%m-%d'))}\n"
                f"\n📊 *Status:* {escape_markdown_v2(status.capitalize())}"
            )

            await update.message.reply_text(
                job_info,
                parse_mode="MarkdownV2"
            )

    except Exception as e:
        logger.error(f"Error fetching applied jobs history for user {user_id}: {e}")
        await update.message.reply_text("An error occurred while fetching your applied jobs history.")
    finally:
        if conn:
            cursor.close()
            conn.close()

    return APPLICATIONS_MENU


import psycopg2
import logging
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import CallbackContext, ConversationHandler
from telegram.constants import ParseMode

logger = logging.getLogger(__name__)

async def handle_saved_drafts(update: Update, context: CallbackContext) -> int:
    """Fetch and display all saved drafts for the applicant."""
    applicant_contact = update.effective_user.id

    # Determine whether the update is a callback query or a message
    if update.callback_query:
        message = update.callback_query.message
    elif update.message:
        message = update.message
    else:
        logger.error("No valid message or callback query in update.")
        return

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch saved drafts for the applicant
        cursor.execute('''
            SELECT d.job_id, jp.job_title, jp.channel_username, jp.message_id, 
                   d.application_message, d.portfolio_links, d.attachments
            FROM application_drafts d
            JOIN job_posts jp ON d.job_id = jp.job_id
            WHERE d.user_id = (SELECT user_id FROM users WHERE contact = %s)
        ''', (str(applicant_contact),))

        drafts = cursor.fetchall()

        if not drafts:
            await message.reply_text("You have no saved drafts.")
            return

        # Display the first draft as an example (other drafts can be added similarly)
        for job_id, job_title, channel_username, message_id, application_message, portfolio_links, attachments in drafts:
            # Ensure channel_username does not include '@' in the Telegram link
            if channel_username and message_id:
                clean_channel_username = channel_username.lstrip('@')
                job_title_link = f'<a href="https://t.me/{clean_channel_username}/{message_id}">{job_title}</a>'
            else:
                job_title_link = job_title

            # Update portfolio link display with the actual link
            if portfolio_links:
                portfolio_links_display = f'<a href="{portfolio_links}">Available</a>'
            else:
                portfolio_links_display = 'No links provided.'

            # Update attachments display
            attachments_display = 'Uploaded' if attachments else 'No attachments provided.'

            draft_text = (
                f"📌 <b>Job Title:</b> {job_title_link}\n"
                f"\n✉️ <b>Message:</b> {application_message or 'No message provided.'}\n"
                f"\n🔗 <b>Portfolio Links:</b> {portfolio_links_display}\n"
                f"\n📄 <b>Attachments:</b> {attachments_display}\n"
            )

            # Inline keyboard for each draft
            reply_markup = InlineKeyboardMarkup([
                [InlineKeyboardButton("Edit Draft", callback_data=f"edit_draft_{job_id}")],
                [InlineKeyboardButton("Submit Draft", callback_data=f"submit_draft_{job_id}")],
                [InlineKeyboardButton("Delete Draft", callback_data=f"delete_draft_{job_id}")]
            ])

            # Update the existing message or send a new message
            if update.callback_query:
                await update.callback_query.message.edit_text(
                    draft_text,
                    parse_mode=ParseMode.HTML,
                    reply_markup=reply_markup
                )
            else:
                await message.reply_text(
                    draft_text,
                    parse_mode=ParseMode.HTML,
                    reply_markup=reply_markup
                )
            break  # Display one draft only for simplicity, remove this to loop through all drafts

    except Exception as e:
        logger.error(f"Error fetching saved drafts: {e}")
        await message.reply_text("An error occurred while fetching your saved drafts.")
    finally:
        if conn:
            cursor.close()
            conn.close()

    return

async def handle_edit_draft(update: Update, context: CallbackContext):
    query = update.callback_query
    job_id = int(query.data.split("_")[-1])
    applicant_contact = query.from_user.id

    logger.info(f"Editing draft for job_id: {job_id}, user: {applicant_contact}")

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()
        cursor.execute('''
            SELECT application_message, portfolio_links, attachments, jp.job_title, jp.channel_username, jp.message_id
            FROM application_drafts d
            JOIN job_posts jp ON d.job_id = jp.job_id
            WHERE d.job_id = %s AND d.user_id = (SELECT user_id FROM users WHERE contact = %s)
        ''', (job_id, str(applicant_contact)))
        draft = cursor.fetchone()

        if not draft:
            await query.answer("Draft not found.", show_alert=True)
            return

        application_message, portfolio_links, attachments, job_title, channel_username, message_id = draft

        # Create a clickable job title link if channel and message details are available
        if channel_username and message_id:
            clean_channel_username = channel_username.lstrip('@')
            job_title_link = f'<a href="https://t.me/{clean_channel_username}/{message_id}">{job_title}</a>'
        else:
            job_title_link = job_title

        # Create a clickable link for portfolio links if they exist
        portfolio_text = "Available" if portfolio_links else "No links"
        if portfolio_links:
            portfolio_text = f'<a href="{portfolio_links}">Available</a>'

        # Display "Uploaded" if attachments are available
        attachments_text = "Uploaded" if attachments else "No attachments"

        context.user_data.update({
            'job_id': job_id,
            'application_message': application_message,
            'portfolio_links': portfolio_links,
            'attachments': attachments
        })

        await query.message.edit_text(
            f"Draft for 📌 <b>Job Title:</b> {job_title_link}\n"
            f"\n✉️ <b>Message:</b> {application_message or 'No message'}\n"
            f"\n🔗 <b>Portfolio Links:</b> {portfolio_text}\n"
            f"\n📄 <b>Attachments:</b> {attachments_text}\n\n"
            f"Select a section to edit:",
            parse_mode="HTML",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("Edit Message", callback_data=f"edit_message_{job_id}")],
                [InlineKeyboardButton("Edit Portfolio Links", callback_data=f"edit_portfolio_{job_id}")],
                [InlineKeyboardButton("Edit Attachments", callback_data=f"edit_attachments_{job_id}")],
                [InlineKeyboardButton("Back to Drafts", callback_data="back_to_drafts")]
            ])
        )
    except Exception as e:
        logger.error(f"Error fetching draft: {e}")
        await query.message.reply_text("An error occurred while editing the draft.")
    finally:
        if conn:
            cursor.close()
            conn.close()



async def handle_edit_message(update: Update, context: CallbackContext) -> int:
    """Prompt the user to edit their application message."""
    query = update.callback_query
    job_id = int(query.data.split("_")[-1])  # Extract job_id from callback data

    context.user_data['job_id'] = job_id  # Store job_id in context for later use

    await query.message.edit_text(
        "Please enter the updated message or use /cancel to discard changes:",
        parse_mode="Markdown"
    )
    await query.answer()  # Acknowledge the callback query

    return EDIT_MESSAGE_STATE  # Transition to the state for editing the message



async def handle_edit_portfolio(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    job_id = int(query.data.split("_")[-1])

    context.user_data['job_id'] = job_id
    await query.message.edit_text(
        "Please enter the updated portfolio links (comma-separated) or use /cancel to discard changes:",
        parse_mode="Markdown"
    )
    await query.answer()
    return EDIT_PORTFOLIO_STATE



from telegram import ReplyKeyboardMarkup, InlineKeyboardMarkup, InlineKeyboardButton

async def handle_edit_attachments(update: Update, context: CallbackContext) -> int:
    """Prompt the user to upload a new document attachment (PDF, DOCX, etc.)."""
    query = update.callback_query
    job_id = int(query.data.split("_")[-1])  # Extract job_id from callback data

    # Store job_id in context to use in the next state
    context.user_data['job_id'] = job_id

    # Edit the message to prompt the user to upload a document
    await query.message.edit_text(
        "Please upload a valid document file (e.g., PDF, DOCX) or press 🔙 Back to return to the summary.",
        parse_mode="Markdown"
    )

    # Send a reply keyboard for navigation, since inline keyboards cannot be used here
    await query.message.reply_text(
        "Please upload the document now or use the button below to navigate back:",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )

    # Acknowledge the callback query
    await query.answer()

    # Transition to the state where the bot expects a document to be uploaded
    return EDIT_ATTACHMENTS_STATE



async def save_edited_message(update: Update, context: CallbackContext) -> int:
    """Save the edited application message to the database and return to draft view."""

    # Extract the new message text from user input (text message)
    if update.message:
        new_message = update.message.text.strip()
    else:
        new_message = None

    # Retrieve job_id from context data (set when entering the edit state)
    job_id = context.user_data.get('job_id')
    user_id = update.effective_user.id  # Get the Telegram user ID

    # Validate input
    if not new_message:
        await update.message.reply_text("No valid input provided. Please enter the updated message.")
        return EDIT_MESSAGE_STATE  # Stay in the current state to re-prompt

    if not job_id:
        await update.message.reply_text("Job ID not found. Please try again.")
        return 

    try:
        # Establishing the database connection
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Update the application message in the database
        logger.info(f"Attempting to update message for job_id {job_id} and user_id {user_id}.")
        cursor.execute('''
            UPDATE application_drafts
            SET application_message = %s
            WHERE job_id = %s AND user_id = (SELECT user_id FROM users WHERE contact = %s)
        ''', (new_message, job_id, str(user_id)))

        # Check if the update query affected any rows
        row_count = cursor.rowcount
        if row_count == 0:
            logger.warning(f"No rows updated for job_id {job_id} and user_id {user_id}. Please check if the record exists.")
            await update.message.reply_text("No record was updated. The job draft might not exist, or you don't have permission.")
            return 
        else:
            logger.info("Message updated and committed successfully.")

        # Commit the update
        conn.commit()
        logger.info("Commit successful.")

        # Notify the user of success
        await update.message.reply_text("Message updated successfully. Displaying the updated draft...")

        # Explicitly call handle_edit_draft to show the updated draft
        # Since we're not in a callback context, manually set the required data in `context.user_data`
        context.user_data['job_id'] = job_id
        await display_edit_draft(update, context)

        return 

    except Exception as e:
        logger.error(f"Error updating message for job_id {job_id}: {e}")
        await update.message.reply_text("An error occurred while updating the message. Please try again.")
        return 

    finally:
        if conn:
            cursor.close()
            conn.close()


import psycopg2
import logging
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import CallbackContext
from telegram.constants import ParseMode

logger = logging.getLogger(__name__)


async def display_edit_draft(update: Update, context: CallbackContext) -> None:
    """Display the updated draft for editing without using callback data, handling both new messages and callback queries."""
    job_id = context.user_data.get('job_id')
    user_id = update.effective_user.id

    logger.info(f"Displaying draft for job_id: {job_id}, user: {user_id}")

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()
        cursor.execute('''
            SELECT jp.job_title, jp.channel_username, jp.message_id,
                   d.application_message, d.portfolio_links, d.attachments
            FROM application_drafts d
            JOIN job_posts jp ON d.job_id = jp.job_id
            WHERE d.job_id = %s AND d.user_id = (SELECT user_id FROM users WHERE contact = %s)
        ''', (job_id, str(user_id)))
        draft = cursor.fetchone()

        if not draft:
            await update.message.reply_text("Draft not found.")
            return

        job_title, channel_username, message_id, application_message, portfolio_links, attachments = draft

        # Make job title clickable
        if channel_username and message_id:
            clean_channel_username = channel_username.lstrip('@')
            job_title_link = f'<a href="https://t.me/{clean_channel_username}/{message_id}">{job_title}</a>'
        else:
            job_title_link = job_title

        # Portfolio Links - Show 'Available' if they exist and make it clickable
        if portfolio_links:
            portfolio_link_text = f'<a href="{portfolio_links}">Available</a>'
        else:
            portfolio_link_text = "No links"

        # Attachments - Show 'Uploaded' if they exist
        attachments_text = "Uploaded" if attachments else "No attachments"

        context.user_data.update({
            'job_id': job_id,
            'application_message': application_message,
            'portfolio_links': portfolio_links,
            'attachments': attachments
        })

        # Prepare the text to be displayed
        draft_text = (
            f"Draft for 📌 <b>Job Title:</b> {job_title_link}\n"
            f"\n✉️ <b>Message:</b> {application_message or 'No message'}\n"
            f"\n🔗 <b>Portfolio Links:</b> {portfolio_link_text}\n"
            f"\n📄 <b>Attachments:</b> {attachments_text}\n\n"
            f"Select a section to edit:"
        )

        # Create inline keyboard markup for editing options
        reply_markup = InlineKeyboardMarkup([
            [InlineKeyboardButton("Edit Message", callback_data=f"edit_message_{job_id}")],
            [InlineKeyboardButton("Edit Portfolio Links", callback_data=f"edit_portfolio_{job_id}")],
            [InlineKeyboardButton("Edit Attachments", callback_data=f"edit_attachments_{job_id}")],
            [InlineKeyboardButton("Back to Drafts", callback_data="back_to_drafts")]
        ])

        # Handle both callback queries and regular messages
        if update.callback_query:
            await update.callback_query.message.edit_text(
                draft_text,
                parse_mode=ParseMode.HTML,
                reply_markup=reply_markup
            )
        elif update.message:
            await update.message.reply_text(
                draft_text,
                parse_mode=ParseMode.HTML,
                reply_markup=reply_markup
            )
        else:
            logger.error("No valid message or callback query for displaying draft.")
            await update.message.reply_text("An error occurred while displaying the draft.")

    except Exception as e:
        logger.error(f"Error fetching draft: {e}")
        await update.message.reply_text("An error occurred while displaying the draft.")
    finally:
        if conn:
            cursor.close()
            conn.close()


async def save_edited_portfolio(update: Update, context: CallbackContext) -> int:
    """Save the edited portfolio links to the database and return to draft view."""

    # Extract the new portfolio links from the user's input
    new_portfolio = update.message.text.strip()
    job_id = context.user_data.get('job_id')
    user_id = update.effective_user.id

    # Validate input
    if not new_portfolio:
        await update.message.reply_text("No valid input provided. Please enter the updated portfolio links.")
        return EDIT_PORTFOLIO_STATE  # Stay in the current state to re-prompt

    if not job_id:
        await update.message.reply_text("Job ID not found. Please try again.")
        return 

    try:
        # Establishing the database connection
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Update the portfolio links in the database
        logger.info(f"Attempting to update portfolio links for job_id {job_id} and user_id {user_id}.")
        cursor.execute('''
            UPDATE application_drafts
            SET portfolio_links = %s
            WHERE job_id = %s AND user_id = (SELECT user_id FROM users WHERE contact = %s)
        ''', (new_portfolio, job_id, str(user_id)))

        # Check if the update query affected any rows
        row_count = cursor.rowcount
        if row_count == 0:
            logger.warning(f"No rows updated for job_id {job_id} and user_id {user_id}. Please check if the record exists.")
            await update.message.reply_text("No record was updated. The job draft might not exist, or you don't have permission.")
            return
        else:
            logger.info("Portfolio links updated and committed successfully.")

        # Commit the update
        conn.commit()
        logger.info("Commit successful.")

        # Notify the user of success
        await update.message.reply_text("Portfolio links updated successfully. Displaying the updated draft...")

        # Explicitly call function to display the updated draft without using callback data
        await display_edit_draft(update, context)

        # Properly end the conversation
        return

    except Exception as e:
        logger.error(f"Error updating portfolio links for job_id {job_id}: {e}")
        await update.message.reply_text("An error occurred while updating the portfolio links. Please try again.")
        return

    finally:
        if conn:
            cursor.close()
            conn.close()

import psycopg2
import logging
from telegram import ReplyKeyboardMarkup, Update
from telegram.ext import CallbackContext, ConversationHandler

logger = logging.getLogger(__name__)

async def save_edited_attachments(update: Update, context: CallbackContext) -> int:
    """Save the edited attachments (e.g., PDF, DOCX) to the database and return to draft view."""

    if update.message.document:
        # Extract the file ID of the uploaded document
        file_id = update.message.document.file_id
        context.user_data['attachments'] = file_id  # Store file ID in user context

        # Retrieve job_id and user_id from context data
        job_id = context.user_data.get('job_id')
        user_id = update.effective_user.id

        if not job_id:
            await update.message.reply_text("Job ID not found. Please try again.")
            return

        try:
            # Establishing the database connection
            conn = psycopg2.connect(
                dbname="my_project_db",
                user="postgres",
                password="1201",
                host="localhost",
                port="5432"
            )
            cursor = conn.cursor()

            # Update the attachments in the application_drafts table
            logger.info(f"Attempting to update attachments for job_id {job_id} and user_id {user_id}.")
            cursor.execute('''
                UPDATE application_drafts
                SET attachments = %s
                WHERE job_id = %s AND user_id = (SELECT user_id FROM users WHERE contact = %s)
            ''', (file_id, job_id, str(user_id)))

            # Check if the update query affected any rows in application_drafts
            row_count = cursor.rowcount
            if row_count == 0:
                logger.warning(f"No rows updated in application_drafts for job_id {job_id} and user_id {user_id}. Please check if the record exists.")
                await update.message.reply_text("No record was updated. The job draft might not exist, or you don't have permission.")
                return
            else:
                logger.info("Attachments updated successfully in application_drafts.")

            # Update the resume in the applicant_profiles table
            logger.info(f"Attempting to update resume for user_id {user_id}.")
            cursor.execute('''
                UPDATE applicant_profiles
                SET resume = %s
                WHERE user_id = (SELECT user_id FROM users WHERE contact = %s)
            ''', (file_id, str(user_id)))

            # Commit the updates
            conn.commit()
            logger.info("Commit successful for both application_drafts and applicant_profiles.")

            # Notify the user of success
            await update.message.reply_text("Attachments updated successfully. Displaying the updated draft...")

            # Explicitly call function to display the updated draft without using callback data
            await display_edit_draft(update, context)

            # Properly end the conversation
            return

        except psycopg2.Error as e:
            logger.error(f"Database error: {e}")
            await update.message.reply_text("A database error occurred while updating your attachments.")
            return

        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            await update.message.reply_text("An unexpected error occurred while updating your attachments.")
            return

        finally:
            if conn:
                cursor.close()
                conn.close()

    # If no document is attached, prompt user again
    await update.message.reply_text(
        "Please upload a valid document file (e.g., PDF, DOCX) or press 🔙 Back to return to the summary.",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return EDIT_ATTACHMENTS_STATE



import psycopg2
import logging
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import CallbackContext, ConversationHandler

logger = logging.getLogger(__name__)

async def handle_submit_draft(update: Update, context: CallbackContext) -> int:
    """Submit the saved draft as an application and notify the employer."""
    query = update.callback_query
    job_id = int(query.data.split("_")[-1])  # Extract job_id
    applicant_contact = query.from_user.id

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve user_id and user details
        cursor.execute('SELECT user_id, first_name, last_name, gender FROM users WHERE contact = %s', (str(applicant_contact),))
        user_row = cursor.fetchone()
        if not user_row:
            await query.message.reply_text("User not found in the database.")
            return

        user_id, first_name, last_name, gender = user_row
        full_name = f"{first_name} {last_name}"
        gender_icon = "👨🏾" if gender.lower() == "male" else "👩🏾"

        # Retrieve draft details
        cursor.execute('''
            SELECT application_message, portfolio_links, attachments
            FROM application_drafts
            WHERE job_id = %s AND user_id = %s
        ''', (job_id, user_id))

        draft = cursor.fetchone()
        if not draft:
            await query.message.reply_text("Draft not found. Please check and try again.")
            return

        application_message, portfolio_links, attachments = draft
        logger.info(f"Draft details retrieved - attachments: {attachments}")

        # If attachments is explicitly None, get it from applicant_profiles
        if attachments is None:
            cursor.execute('SELECT resume FROM applicant_profiles WHERE user_id = %s', (user_id,))
            resume_row = cursor.fetchone()
            attachments = resume_row[0] if resume_row and resume_row[0] else None
            logger.info(f"Fallback attachments retrieved from applicant_profiles - attachments: {attachments}")

        # Submit as application
        cursor.execute('''
            INSERT INTO applications (job_id, user_id, application_date, application_message, portfolio_links)
            VALUES (%s, %s, NOW(), %s, %s) RETURNING application_id
        ''', (job_id, user_id, application_message, portfolio_links))

        application_id = cursor.fetchone()[0]

        # Store the last submitted application ID
        context.user_data['last_submitted_application_id'] = application_id

        # Delete the draft after submission
        cursor.execute('''
            DELETE FROM application_drafts WHERE job_id = %s AND user_id = %s
        ''', (job_id, user_id))

        # Commit all changes
        conn.commit()

        # Notify employer
        cursor.execute('SELECT job_title, channel_username, message_id FROM job_posts WHERE job_id = %s', (job_id,))
        job_post_row = cursor.fetchone()
        job_title = job_post_row[0] if job_post_row else "Unknown Job Title"
        channel_username = job_post_row[1].lstrip('@') if job_post_row[1] else None  # Remove @ for the link
        message_id = job_post_row[2] if job_post_row else None

        # Create a clickable job title link using HTML
        if channel_username and message_id:
            job_title_link = f'<a href="https://t.me/{channel_username}/{message_id}">{job_title}</a>'
        else:
            job_title_link = job_title

        message_text = (
            f"📥 <b>New Application Received!</b>\n\n"
            f"{gender_icon} <b>Name:</b> {full_name}\n"
            f"📌 <b>Job Title:</b> {job_title_link}\n"
        )

        if application_message:
            message_text += f"✉️ <b>Message:</b> {application_message[:30]}{'...' if len(application_message) > 30 else ''}\n"
        if portfolio_links:
            message_text += f"🔗 <b>Portfolio:</b> <a href='{portfolio_links}'>View Portfolio</a>\n"
        if attachments:
            message_text += f"📄 <b>Attachments:</b> Uploaded\n"

        # Inline buttons for employer
        keyboard = [
            [InlineKeyboardButton("View Application", callback_data=f"view_application_{application_id}")],
            [InlineKeyboardButton("View Profile", callback_data=f"view_profile_{application_id}")],
        ]

        if attachments:
            keyboard.append([InlineKeyboardButton("Download CV", callback_data=f"download_resume_{application_id}")])

        keyboard.append([InlineKeyboardButton("Shortlist", callback_data=f"shortlists_{application_id}")])
        keyboard.append([InlineKeyboardButton("Chat", callback_data=f"start_chat_{application_id}")])

        employer_contact = get_employer_contact(job_id)
        await context.bot.send_message(
            chat_id=employer_contact,
            text=message_text,
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

        # Update the existing draft message inline and stay in the same session
        portfolio_links_display = f'<a href="{portfolio_links}">Available</a>' if portfolio_links else 'No links provided.'
        attachments_display = 'Uploaded' if attachments else 'No attachments provided.'

        await query.message.edit_text(
            f"✅ <b>Draft Submitted Successfully!</b>\n\n"
            f"\n📌 <b>Job Title:</b> {job_title_link}\n"
            f"\n✉️ <b>Message:</b> {application_message or 'No message provided.'}\n"
            f"\n🔗 <b>Portfolio Links:</b> {portfolio_links_display}\n"
            f"\n📄 <b>Attachments:</b> {attachments_display}\n",
            parse_mode='HTML'
        )

    except psycopg2.Error as db_error:
        await query.message.reply_text("A database error occurred. Please try again later.")
    except Exception as e:
        await query.message.reply_text("An unexpected error occurred. Please try again later.")
    finally:
        if conn:
            cursor.close()
            conn.close()

    # Stay in the current session
    return




async def handle_view_single_application(update: Update, context: CallbackContext) -> int:
    """Display details of the single application that was just submitted from a draft."""
    query = update.callback_query
    applicant_contact = query.from_user.id

    # Extract the application_id from the context
    application_id = context.user_data.get('last_submitted_application_id')

    if not application_id:
        await query.message.reply_text("No application found. Please try again.")
        return

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch the specific application details
        cursor.execute('''
            SELECT j.job_title, a.application_message, a.portfolio_links, p.resume
            FROM applications a
            JOIN job_posts j ON a.job_id = j.job_id
            JOIN applicant_profiles p ON a.user_id = p.user_id
            WHERE a.application_id = %s AND a.user_id = (SELECT user_id FROM users WHERE contact = %s)
        ''', (application_id, str(applicant_contact)))

        application = cursor.fetchone()

        if not application:
            await query.message.reply_text("Application not found. Please try again.")
            return

        job_title, application_message, portfolio_links, resume_file_id = application

        # Build the application details message
        application_text = (
            f"📌 *Job Title:* {job_title}\n"
        )
        if application_message:
            application_text += f"✉️ *Message:* {application_message}\n"
        if portfolio_links:
            application_text += f"🔗 *Portfolio:* [View Portfolio]({portfolio_links})\n"
        if resume_file_id:
            application_text += f"📄 *Resume:* Available for download\n"

        # Build reply markup for actions
        keyboard = []
        if resume_file_id:
            keyboard.append([InlineKeyboardButton("Download CV", callback_data=f"download_resume_{application_id}")])
        keyboard.append([InlineKeyboardButton("Back to Menu", callback_data="applicant_main_menu")])

        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.message.edit_text(
            application_text,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )

    except psycopg2.Error as db_error:
        logger.error(f"Database error while fetching application: {db_error}")
        await query.message.reply_text("An error occurred while fetching your application.")
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        await query.message.reply_text("An unexpected error occurred.")
    finally:
        if conn:
            cursor.close()
            conn.close()

    return


async def handle_delete_draft(update: Update, context: CallbackContext) -> int:
    """Handle the deletion of a saved draft."""
    query = update.callback_query
    await query.answer()

    # Extract the job_id from the callback data
    job_id = int(query.data.split("_")[-1])
    applicant_contact = query.from_user.id

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Delete the draft from the database
        cursor.execute('''
            DELETE FROM application_drafts
            WHERE job_id = %s AND user_id = (SELECT user_id FROM users WHERE contact = %s)
        ''', (job_id, str(applicant_contact)))

        # Check if any rows were affected
        if cursor.rowcount == 0:
            await query.message.reply_text("No draft was found to delete, or you don't have permission.")
        else:
            conn.commit()
            await query.message.reply_text("✅ Draft deleted successfully.")

        # Optionally, delete the message from the chat
        await query.message.delete()

    except psycopg2.Error as e:
        logger.error(f"Database error while deleting draft: {e}")
        await query.message.reply_text("A database error occurred while deleting the draft.")
    except Exception as e:
        logger.error(f"Unexpected error while deleting draft: {e}")
        await query.message.reply_text("An unexpected error occurred while deleting the draft.")
    finally:
        if conn:
            cursor.close()
            conn.close()

    # End the conversation after deletion
    return


import re
import psycopg2
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import CallbackContext

# Function to escape text for MarkdownV2
def escape_markdown_v2(text):
    if text is None:
        text = ""
    return re.sub(r'([_\*\[\]\(\)~`>#+\-=|{}.!])', r'\\\1', text)


# Helper to convert normalized values to display-friendly names
def get_display_value(option):
    return option

# Helper function to fetch specific criteria from the database
def fetch_criteria(query, params=None):
    conn = psycopg2.connect(dbname="my_project_db", user="postgres", password="1201", host="localhost", port="5432")
    cursor = conn.cursor()
    cursor.execute(query, params or ())
    result = cursor.fetchall()
    cursor.close()
    conn.close()
    return [str(item[0]) if item[0] is not None else "" for item in result] if result else []

# Helper function to combine selections, ensuring both inputs are lists
def get_combined_selections(db_selections, session_selections):
    # Ensure both inputs are lists
    db_selections = db_selections if isinstance(db_selections, list) else [db_selections]
    session_selections = session_selections if isinstance(session_selections, list) else [session_selections]
    return list(set(db_selections + session_selections))

async def handle_set_job_alerts(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id if update.message else update.callback_query.message.chat_id

    conn = psycopg2.connect(dbname="my_project_db", user="postgres", password="1201", host="localhost", port="5432")
    cursor = conn.cursor()
    cursor.execute("SELECT user_id FROM users WHERE contact = %s", (str(user_chat_id),))
    user_id = cursor.fetchone()[0]
    cursor.close()
    conn.close()

    # Retrieve and store job type selections
    stored_job_types = fetch_criteria("SELECT unnest(job_types) FROM user_job_alerts WHERE user_id = %s", (user_id,))
    context.user_data['selected_job_types'] = stored_job_types


    stored_job_sectors = fetch_criteria("SELECT unnest(selected_sectors) FROM user_job_alerts WHERE user_id = %s",(user_id,))
    context.user_data['selected_job_sectors'] = stored_job_sectors  # Store job sectors in context

    stored_work_country = fetch_criteria("SELECT work_country FROM user_job_alerts WHERE user_id = %s", (user_id,))
    context.user_data['selected_work_country'] = stored_work_country[0] if stored_work_country else None

    stored_work_cities = fetch_criteria("SELECT unnest(work_cities) FROM user_job_alerts WHERE user_id = %s",(user_id,))
    context.user_data['selected_work_cities'] = stored_work_cities

    # Fetch stored education qualifications from the database and store in context.user_data
    stored_education_qualifications = fetch_criteria(
        "SELECT unnest(education_qualifications) FROM user_job_alerts WHERE user_id = %s", (user_id,))
    context.user_data[
        'selected_education_qualification'] = stored_education_qualifications if stored_education_qualifications else []

    # Retrieve selected experience levels from database
    stored_experience_levels = fetch_criteria(
        "SELECT unnest(experience_levels) FROM user_job_alerts WHERE user_id = %s", (user_id,))
    context.user_data['selected_experience_level'] = stored_experience_levels if stored_experience_levels else []

    # Fetch stored salary amounts from the database and store in context.user_data
    stored_salary_amounts = fetch_criteria("SELECT unnest(salary_ranges) FROM user_job_alerts WHERE user_id = %s",
                                           (user_id,))
    context.user_data['selected_salary_amount'] = stored_salary_amounts if stored_salary_amounts else []

    # Fetch stored compensation types from the database and store in context.user_data
    stored_compensation_types = fetch_criteria(
        "SELECT unnest(compensation_types) FROM user_job_alerts WHERE user_id = %s", (user_id,))
    context.user_data['selected_compensation_type'] = stored_compensation_types if stored_compensation_types else []

    # Fetch stored currency type from the database and store in context.user_data
    stored_currency_type = fetch_criteria("SELECT currency_type FROM user_job_alerts WHERE user_id = %s", (user_id,))
    context.user_data['selected_currency_type'] = stored_currency_type[0] if stored_currency_type else None

    # Fetch stored vacancy number from the database and store in context.user_data
    stored_vacancy_number = fetch_criteria("SELECT vacancy_number FROM user_job_alerts WHERE user_id = %s", (user_id,))
    context.user_data['selected_vacancy_number'] = stored_vacancy_number[0] if stored_vacancy_number else None

    # Fetch stored gender from the database and store in context.user_data
    stored_gender = fetch_criteria("SELECT unnest(gender) FROM user_job_alerts WHERE user_id = %s", (user_id,))
    context.user_data['selected_gender'] = stored_gender if stored_gender else []

    # Fetch stored job sites from the database and store in context.user_data
    stored_job_sites = fetch_criteria("SELECT unnest(job_sites) FROM user_job_alerts WHERE user_id = %s", (user_id,))
    context.user_data['selected_job_sites'] = stored_job_sites if stored_job_sites else []

    # Combine stored selections with current session updates
    combined_job_types = get_combined_selections(stored_job_types, context.user_data.get('selected_job_types', []))

    combined_job_sectors = get_combined_selections(stored_job_sectors, context.user_data.get('selected_job_sectors', []))
    combined_work_country = get_combined_selections(stored_work_country, context.user_data.get('selected_work_country', []))
    combined_work_cities = get_combined_selections(stored_work_cities, context.user_data.get('selected_work_cities', []))
    combined_education_qualifications = get_combined_selections(stored_education_qualifications, context.user_data.get('selected_education_qualification', []))
    combined_experience_levels = get_combined_selections(stored_experience_levels, context.user_data.get('selected_experience_level', []))
    combined_salary_amounts = get_combined_selections(stored_salary_amounts, context.user_data.get('selected_salary_amount', []))
    combined_compensation_types = get_combined_selections(stored_compensation_types, context.user_data.get('selected_compensation_type', []))
    combined_currency_type = get_combined_selections(stored_currency_type, context.user_data.get('selected_currency_type', []))
    combined_vacancy_number = get_combined_selections(stored_vacancy_number, context.user_data.get('selected_vacancy_number', []))
    combined_gender = get_combined_selections(stored_gender, context.user_data.get('selected_gender', []))
    combined_job_sites = get_combined_selections(stored_job_sites, context.user_data.get('selected_job_site', []))

    # Introductory message about job alerts
    from telegram.helpers import escape_markdown

    intro_text = (
        "✨ <b>Welcome to Your Personalized Job Alert Setup</b> ✨\n\n"
        "Tired of endlessly scrolling through channels to find the perfect job opportunity? We've got you covered! "
        "With this setup, you can receive tailored job notifications that match your preferences, saving you time and effort.\n\n"
        "📢 <b>How It Works:</b>\n"
        "Once you configure your job preferences, our bot will automatically send you job posts based on your criteria, including:\n\n"
        "⚡ <b>Sector:</b> Choose up to 3 sectors\n\n"
        "⚡ <b>Experience Level:</b> Select up to 2 levels\n\n"
        "⚡ <b>Job Site:</b> Pick only one job site\n\n"
        "⚡ <b>Job Type:</b> Select any number of types (Full-time, Freelance, etc.)\n\n"
        "⚡ <b>Country:</b> Specify one preferred country\n\n"
        "⚡ <b>Cities:</b> Select up to 2 cities within your chosen country\n\n"
        "⚡ <b>Education Qualification:</b> Choose up to 2 qualifications\n\n"
        "⚡ <b>Salary Range:</b> Select up to 2 salary ranges\n\n"
        "🎯 <i>Take control of your job search today</i> by specifying the criteria for your job alerts below. "
        "Let the opportunities come to you effortlessly!"
    )

    # Combine message parts
    job_types_text = (
        "\n\n<b>Job Types:</b>\n" + "\n".join(
            [f"✔️ {job_type}" for job_type in combined_job_types]
        ) if combined_job_types else ""
    )

    job_sectors_text = (
        "\n\n<b>Job Sectors:</b>\n" + "\n".join(
            [f"✔️ {sector}" for sector in combined_job_sectors]
        ) if combined_job_sectors else ""
    )

    work_country_text = (
        f"\n\n<b>Work Country:</b>\n✔️ {get_display_value(context.user_data['selected_work_country'])}"
        if context.user_data.get('selected_work_country') else ""
    )

    work_cities_text = (
        "\n\n<b>Work Cities:</b>\n" + "\n".join(
            [f"✔️ {get_display_value(city)}" for city in combined_work_cities]
        ) if combined_work_cities else ""
    )

    education_qualification_text = (
        "\n\n<b>Education Qualifications:</b>\n" + "\n".join(
            [f"✔️ {get_display_value(qualification)}" for qualification in combined_education_qualifications]
        ) if combined_education_qualifications else ""
    )

    experience_level_text = (
        "\n\n<b>Experience Levels:</b>\n" + "\n".join(
            [f"✔️ {get_display_value(level)}" for level in combined_experience_levels]
        ) if combined_experience_levels else ""
    )

    salary_amount_text = (
        "\n\n<b>Salary Amounts:</b>\n" + "\n".join(
            [f"✔️ {get_display_value(salary)}" for salary in combined_salary_amounts]
        ) if combined_salary_amounts else ""
    )

    compensation_type_text = (
        "\n\n<b>Compensation Types:</b>\n" + "\n".join(
            [f"✔️ {get_display_value(comp_type)}" for comp_type in combined_compensation_types]
        ) if combined_compensation_types else ""
    )

    currency_type_text = (
        f"\n\n<b>Currency Type:</b>\n✔️ {get_display_value(combined_currency_type[0])}"
        if combined_currency_type and combined_currency_type[0] else ""
    )

    vacancy_number_text = (
        f"\n\n<b>Vacancy Number:</b>\n✔️ {get_display_value(combined_vacancy_number[0])}"
        if combined_vacancy_number and combined_vacancy_number[0] else ""
    )

    gender_text = (
        "\n\n<b>Gender:</b>\n" + "\n".join(
            [f"✔️ {get_display_value(gender)}" for gender in combined_gender]
        ) if combined_gender else ""
    )

    job_site_text = (
        "\n\n<b>Job Site:</b>\n" + "\n".join(
            [f"✔️ {get_display_value(site)}" for site in combined_job_sites]
        ) if combined_job_sites else ""
    )

    # Combine all sections into the final message
    combined_message = (
            intro_text
            + job_types_text
            + job_sectors_text
            + work_country_text
            + work_cities_text
            + education_qualification_text
            + experience_level_text
            + salary_amount_text
            + compensation_type_text
            + currency_type_text
            + vacancy_number_text
            + gender_text
            + job_site_text
    )

    # Define inline buttons
    keyboard = [
        [InlineKeyboardButton("Job Type", callback_data='alert:job_type'),
         InlineKeyboardButton("Job Sector", callback_data='alert:job_sector')],
        [InlineKeyboardButton("Work Country", callback_data='alert:work_country'),
         InlineKeyboardButton("Work City", callback_data='alert:work_city')],
        [InlineKeyboardButton("Education Qualification", callback_data='alert:education_qualification'),
         InlineKeyboardButton("Experience Level", callback_data='alert:experience_level')],
        [InlineKeyboardButton("Salary Amount", callback_data='alert:salary_amount'),
         InlineKeyboardButton("Compensation Type", callback_data='alert:compensation_type')],
        [InlineKeyboardButton("Currency Type", callback_data='alert:currency_type'),
         InlineKeyboardButton("Vacancy Number", callback_data='alert:vacancy_number')],
        [InlineKeyboardButton("Gender", callback_data='alert:gender'),
         InlineKeyboardButton("Job Site", callback_data='alert:job_site')],
        [InlineKeyboardButton("Confirm", callback_data='alert:confirm')],

    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    if update.callback_query:
        await update.callback_query.edit_message_text(combined_message, parse_mode='HTML', reply_markup=reply_markup)
    elif update.message:
        await update.message.reply_text(combined_message, parse_mode='HTML', reply_markup=reply_markup)

    return SET_JOB_ALERTS

async def handle_invalid_job_alert_input(update: Update, context: CallbackContext) -> int:
    """Handles invalid text input and reminds users to use buttons."""
    await update.message.reply_text(
        "⚠️ Invalid input. Please use the buttons provided to configure your job alerts."
    )
    return SET_JOB_ALERTS  # Remain in the same state


from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import CallbackContext

# Database connection settings
DB_CONFIG = {
    "dbname": "my_project_db",
    "user": "postgres",
    "password": "1201",
    "host": "localhost",
    "port": "5432",
}

# Function to fetch data from a table
def fetch_data_from_table(table_name: str, column_name: str) -> list:
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()
        query = f"SELECT {column_name} FROM {table_name} ORDER BY {column_name} ASC;"
        cursor.execute(query)
        result = [row[0] for row in cursor.fetchall()]
        cursor.close()
        conn.close()
        return result
    except Exception as e:
        print(f"Error fetching data from {table_name}: {e}")
        return []

MAX_SECTOR_SELECTIONS = 2  # Limit the number of selectable job sectors
MAX_CITY_SELECTIONS = 2  # Limit the number of selectable cities
MAX_EDUCATION_SELECTIONS = 2  # Limit the number of selectable education qualifications
MAX_EXPERIENCE_SELECTIONS = 3  # Limit the number of selectable experience levels
MAX_SALARY_SELECTIONS = 2  # Maximum salary amounts that can be selected
MAX_COMPENSATION_SELECTIONS = 2  # Maximum compensation types that can be selected
# Define job type options and job sector options
# Define job type options with exact values

# Fetch job type options dynamically
job_type_options = fetch_data_from_table("job_types", "job_type_name")

# Fetch job sector options dynamically
job_sector_options = fetch_data_from_table("job_categories", "category_name")


# Define work country options with exact values
work_country_options = fetch_data_from_table("countries", "country_name")


# Fetch work city options dynamically
work_city_options = fetch_data_from_table("locations", "city_name")

# Fetch education qualification options dynamically
education_qualification_options = fetch_data_from_table("education_levels", "education_level_name")


# Define experience level options with exact values
experience_level_options = fetch_data_from_table("experience_levels", "experience_level_name")



# Define salary amount options with exact values
salary_amount_options = ["1000-50000","5000-10000", "10000-20000", "20000-40000", "40000-60000", "60000-80000", "80000-150000", "150000-300000"]

# Define compensation type options with exact values
compensation_type_options = fetch_data_from_table("compensation_types", "compensation_type_name")

# Define currency type options
currency_type_options = fetch_data_from_table("currency_types", "currency_code")


# Define vacancy number options
vacancy_number_options = ["1", "2", "5", "10", "≥10"]

# Define gender options
gender_options = ["Male", "Female", "Both"]


# Define job site options
job_site_options = fetch_data_from_table("job_sites", "job_site_name")

# Process job type, sector, work country/city, education qualification, experience level, salary amount, and currency type selection
async def process_alert_criteria_selection(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()  # Acknowledge the callback query







    # Get the selected alert criterion from callback data
    criterion = query.data.split(':')[1]

    # Check if the "Confirm" button was pressed
    if criterion == "confirm":
        # Call the confirmation function to save the data
        await handle_final_job_alert_confirmation(update, context)
        return

    # Handle job site selection display
    if criterion == "job_site":
        # Print debug information to verify stored user data
        print("Current selected job site:", context.user_data.get('selected_job_site'))

        # Create keyboard for job site selection using exact matching
        job_site_keyboard = [
            [InlineKeyboardButton(
                f"✅ {option}" if option == context.user_data.get('selected_job_site') else option,
                callback_data=f'alert:job_site_{option.lower().replace("-", "_")}'
            )]
            for option in job_site_options
        ]
        job_site_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Display the job site options
        reply_markup = InlineKeyboardMarkup(job_site_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle job site-specific selection (e.g., job_site_on_site)
    elif criterion.startswith("job_site_"):
        # Extract and format selected job site directly from callback data
        selected_site = criterion.split("_", 2)[2].replace("_", "-").title()
        if selected_site == "On-site":
            selected_site = "On-Site"  # Adjust capitalization for consistent display

        # Toggle the selection of the job site (single selection)
        current_selection = context.user_data.get('selected_job_site')
        if current_selection == selected_site:
            context.user_data['selected_job_site'] = None  # Deselect if already selected
        else:
            context.user_data['selected_job_site'] = selected_site  # Select

        # Print debug information to verify new selection
        print("Updated selected job site:", context.user_data['selected_job_site'])

        # Rebuild the keyboard with the selected job site check marked
        job_site_keyboard = [
            [InlineKeyboardButton(
                f"✅ {option}" if option == context.user_data.get('selected_job_site') else option,
                callback_data=f'alert:job_site_{option.lower().replace("-", "_")}'
            )]
            for option in job_site_options
        ]
        job_site_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Update the message to reflect selected job site without changing the message text
        reply_markup = InlineKeyboardMarkup(job_site_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle "Done" button selection for job site
    elif criterion == "done":
        await handle_done_selection(update, context)
        return

    # Handle gender selection display
    if criterion == "gender":
        # Ensure 'selected_gender' is initialized in user_data
        if 'selected_gender' not in context.user_data:
            context.user_data['selected_gender'] = []

        # Create keyboard for gender selection with check marks for selected options
        gender_keyboard = [
            [InlineKeyboardButton(
                f"✅ {option}" if option in context.user_data['selected_gender'] else option,
                callback_data=f'alert:gender_{option.lower()}'
            )]
            for option in gender_options
        ]
        gender_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Display the gender options
        reply_markup = InlineKeyboardMarkup(gender_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle gender-specific selection (e.g., gender_male)
    elif criterion.startswith("gender_"):
        # Extract the selected gender from callback data
        selected_gender = criterion.split("_", 1)[1].capitalize()

        # Toggle selection with a maximum of 2 options
        current_gender_selections = context.user_data.get('selected_gender', [])

        if selected_gender in current_gender_selections:
            current_gender_selections.remove(selected_gender)  # Deselect if already selected
        else:
            if len(current_gender_selections) >= 2:
                await query.message.reply_text(
                    "You can select up to 2 gender options only. Please deselect an option to add a new one."
                )
                return
            current_gender_selections.append(selected_gender)  # Select new option

        # Update the selected gender options in user data
        context.user_data['selected_gender'] = current_gender_selections

        # Rebuild the keyboard with the selected gender options check-marked
        gender_keyboard = [
            [InlineKeyboardButton(
                f"✅ {option}" if option in current_gender_selections else option,
                callback_data=f'alert:gender_{option.lower()}'
            )]
            for option in gender_options
        ]
        gender_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Update the message to reflect selected gender options without changing the message text
        reply_markup = InlineKeyboardMarkup(gender_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle "Done" button selection for gender
    elif criterion == "done":
        await handle_done_selection(update, context)  # Save and go back to the main alert settings
        return

    # Handle vacancy number selection display
    if criterion == "vacancy_number":
        # Ensure 'selected_vacancy_number' is set in user_data
        if 'selected_vacancy_number' not in context.user_data:
            context.user_data['selected_vacancy_number'] = None

        # Create keyboard for vacancy number selection with a check mark for the selected option
        vacancy_number_keyboard = [
            [InlineKeyboardButton(
                f"✅ {option}" if option == context.user_data['selected_vacancy_number'] else option,
                callback_data=f'alert:vacancy_number_{option}'
            )]
            for option in vacancy_number_options
        ]
        vacancy_number_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Display the vacancy number options
        reply_markup = InlineKeyboardMarkup(vacancy_number_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle vacancy number-specific selection (e.g., vacancy_number_1)
    elif criterion.startswith("vacancy_number_"):
        # Extract the selected vacancy number from callback data
        selected_vacancy = criterion.split("_", 2)[2]

        # Toggle the selection of the vacancy number (single selection)
        context.user_data['selected_vacancy_number'] = (
            None if context.user_data['selected_vacancy_number'] == selected_vacancy else selected_vacancy
        )

        # Rebuild the keyboard with the selected vacancy number check marked
        vacancy_number_keyboard = [
            [InlineKeyboardButton(
                f"✅ {option}" if option == context.user_data['selected_vacancy_number'] else option,
                callback_data=f'alert:vacancy_number_{option}'
            )]
            for option in vacancy_number_options
        ]
        vacancy_number_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Update the message to reflect the selected vacancy number without changing the message text
        reply_markup = InlineKeyboardMarkup(vacancy_number_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle "Done" button selection for vacancy number
    elif criterion == "done":
        await handle_done_selection(update, context)  # Save and go back to the main alert settings
        return

    # Handle salary amount selection display
    if criterion == "salary_amount":
        # Debug: Print the current selections in user data
        print("Current selected salary amounts:", context.user_data.get('selected_salary_amount', []))

        # Create the selection keyboard with check marks for items in user data
        salary_amount_keyboard = [
            [InlineKeyboardButton(
                f"✅ {option}" if option in context.user_data.get('selected_salary_amount', []) else option,
                callback_data=f'alert:salary_amount_{salary_amount_options.index(option)}'
                # Use index for direct mapping
            )]
            for option in salary_amount_options
        ]
        salary_amount_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Send or update the message with the keyboard
        reply_markup = InlineKeyboardMarkup(salary_amount_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle salary amount-specific selection
    elif criterion.startswith("salary_amount_"):
        # Get the index of the selected salary amount from callback data
        selected_index = int(criterion.split("_")[-1])
        selected_salary = salary_amount_options[selected_index]

        # Toggle the selection in context.user_data
        selected_salary_amounts = context.user_data.get('selected_salary_amount', [])

        if selected_salary in selected_salary_amounts:
            selected_salary_amounts.remove(selected_salary)  # Deselect
        else:
            if len(selected_salary_amounts) >= 2:  # Enforce a maximum of 2 selections
                await query.message.reply_text(
                    "You can select up to 2 salary ranges only. Please deselect an option to add a new one."
                )
                return
            selected_salary_amounts.append(selected_salary)  # Select

        # Update context with the new selection
        context.user_data['selected_salary_amount'] = selected_salary_amounts
        print("Updated selected salary amounts:", context.user_data['selected_salary_amount'])  # Debug

        # Rebuild the keyboard to reflect updated selections
        salary_amount_keyboard = [
            [InlineKeyboardButton(
                f"✅ {option}" if option in selected_salary_amounts else option,
                callback_data=f'alert:salary_amount_{salary_amount_options.index(option)}'
            )]
            for option in salary_amount_options
        ]
        salary_amount_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Update the message with the new keyboard
        reply_markup = InlineKeyboardMarkup(salary_amount_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle "Done" button to save selections and return to main menu
    elif criterion == "done":
        # Print final selected salary amounts for debugging
        print("Final selections saved for salary amounts:", context.user_data.get('selected_salary_amount'))
        await handle_done_selection(update, context)  # Save selections and return to main alert settings
        return

    # Handle compensation type selection display
    if criterion == "compensation_type":
        # Debug: Print current selections for compensation types
        print("Current selected compensation types:", context.user_data.get('selected_compensation_type', []))

        # Build keyboard for compensation type selection
        compensation_type_keyboard = [
            [InlineKeyboardButton(
                f"✅ {option}" if option in context.user_data.get('selected_compensation_type', []) else option,
                callback_data=f'alert:compensation_type_{compensation_type_options.index(option)}'
                # Use index for direct mapping
            )]
            for option in compensation_type_options
        ]
        compensation_type_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Send or update the message with the keyboard
        reply_markup = InlineKeyboardMarkup(compensation_type_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle compensation type-specific selection
    elif criterion.startswith("compensation_type_"):
        # Get the index of the selected compensation type from callback data
        selected_index = int(criterion.split("_")[-1])
        selected_type = compensation_type_options[selected_index]

        # Toggle the selection in context.user_data
        selected_compensation_types = context.user_data.get('selected_compensation_type', [])

        if selected_type in selected_compensation_types:
            selected_compensation_types.remove(selected_type)  # Deselect
        else:
            if len(selected_compensation_types) >= 2:  # Enforce a maximum of 2 selections
                await query.message.reply_text(
                    "You can select up to 2 compensation types only. Please deselect an option to add a new one."
                )
                return
            selected_compensation_types.append(selected_type)  # Select

        # Update context with the new selection
        context.user_data['selected_compensation_type'] = selected_compensation_types
        print("Updated selected compensation types:", context.user_data['selected_compensation_type'])  # Debug

        # Rebuild the keyboard to reflect updated selections
        compensation_type_keyboard = [
            [InlineKeyboardButton(
                f"✅ {option}" if option in selected_compensation_types else option,
                callback_data=f'alert:compensation_type_{compensation_type_options.index(option)}'
            )]
            for option in compensation_type_options
        ]
        compensation_type_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Update the message with the new keyboard
        reply_markup = InlineKeyboardMarkup(compensation_type_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle "Done" button to save selections and return to main menu
    elif criterion == "done":
        print("Final selections saved for compensation types:",
              context.user_data.get('selected_compensation_type', []))  # Debug
        await handle_done_selection(update, context)  # Save selections and return to main alert settings
        return

    # Handle currency type selection display
    if criterion == "currency_type":
        # Ensure 'selected_currency_type' is set in user_data
        if 'selected_currency_type' not in context.user_data:
            context.user_data['selected_currency_type'] = None

        # Create keyboard for currency type selection with check mark for the selected option
        currency_type_keyboard = [
            [InlineKeyboardButton(
                f"✅ {type_}" if type_ == context.user_data['selected_currency_type'] else type_,
                callback_data=f'alert:currency_type_{type_}'
            )]
            for type_ in currency_type_options
        ]
        currency_type_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Display the currency type options
        reply_markup = InlineKeyboardMarkup(currency_type_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle currency type-specific selection (e.g., currency_type_ETB)
    elif criterion.startswith("currency_type_"):
        # Extract the selected currency from callback data
        selected_currency = criterion.split("_", 2)[2]

        # Toggle the selection of the currency type (single selection)
        context.user_data['selected_currency_type'] = (
            None if context.user_data['selected_currency_type'] == selected_currency else selected_currency
        )

        # Rebuild the keyboard with the selected currency type check marked
        currency_type_keyboard = [
            [InlineKeyboardButton(
                f"✅ {type_}" if type_ == context.user_data['selected_currency_type'] else type_,
                callback_data=f'alert:currency_type_{type_}'
            )]
            for type_ in currency_type_options
        ]
        currency_type_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Update the message to reflect the selected currency type without changing the message text
        reply_markup = InlineKeyboardMarkup(currency_type_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle "Done" button selection for currency type
    elif criterion == "done":
        await handle_done_selection(update, context)  # Save and go back to the main alert settings
        return

    # Handle job type selection display
    if criterion == "job_type":
        # Debug: Print current selections for job types
        print("Current selected job types:", context.user_data.get('selected_job_types', []))

        # Build keyboard for job type selection
        job_type_keyboard = [
            [InlineKeyboardButton(
                f"✅ {option}" if option in context.user_data.get('selected_job_types', []) else option,
                callback_data=f'alert:job_type_{job_type_options.index(option)}'
                # Use index for direct mapping
            )]
            for option in job_type_options
        ]
        job_type_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Send or update the message with the keyboard
        reply_markup = InlineKeyboardMarkup(job_type_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle job type-specific selection
    elif criterion.startswith("job_type_"):
        # Get the index of the selected job type from callback data
        selected_index = int(criterion.split("_")[-1])
        selected_type = job_type_options[selected_index]

        # Toggle the selection in context.user_data
        selected_job_types = context.user_data.get('selected_job_types', [])

        if selected_type in selected_job_types:
            selected_job_types.remove(selected_type)  # Deselect
        else:
            if len(selected_job_types) >= 3:  # Limit selection to 3 options
                await query.message.reply_text(
                    "You can select up to 3 job types only. Please deselect an option to add a new one."
                )
                return
            selected_job_types.append(selected_type)  # Select new option

        # Update context with the new selection
        context.user_data['selected_job_types'] = selected_job_types
        print("Updated selected job types:", context.user_data['selected_job_types'])  # Debug

        # Rebuild the keyboard to reflect updated selections
        job_type_keyboard = [
            [InlineKeyboardButton(
                f"✅ {option}" if option in selected_job_types else option,
                callback_data=f'alert:job_type_{job_type_options.index(option)}'
            )]
            for option in job_type_options
        ]
        job_type_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Update the message with the new keyboard
        reply_markup = InlineKeyboardMarkup(job_type_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle "Done" button to save selections and return to main menu
    elif criterion == "done":
        print("Final selections saved for job types:", context.user_data.get('selected_job_types', []))  # Debug
        await handle_done_selection(update, context)  # Save selections and return to main alert settings
        return
    # Handle job sector selection display
    if criterion == "job_sector":
        # Print current selections for job sectors
        print("Current selected job sectors:", context.user_data.get('selected_job_sectors', []))

        # Build the job sector selection keyboard with check marks for selected options
        job_sector_keyboard = [
            [InlineKeyboardButton(
                f"✅ {option}" if option in context.user_data.get('selected_job_sectors', []) else option,
                callback_data=f'alert:job_sector_{job_sector_options.index(option)}'
            )]
            for option in job_sector_options
        ]
        job_sector_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Display the job sector options
        reply_markup = InlineKeyboardMarkup(job_sector_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

        # Job Sector-specific Selection (e.g., job_sector_0)
    elif criterion.startswith("job_sector_"):
        # Get the index of the selected job sector from callback data
        selected_index = int(criterion.split("_")[-1])
        selected_sector = job_sector_options[selected_index]

        # Toggle selection in context.user_data
        selected_job_sectors = context.user_data.get('selected_job_sectors', [])
        if selected_sector in selected_job_sectors:
            selected_job_sectors.remove(selected_sector)  # Deselect
        else:
            if len(selected_job_sectors) >= 3:  # Limit selection to 3 options
                await query.message.reply_text(
                    "You can select up to 3 job sectors only. Please deselect an option to add a new one."
                )
                return
            selected_job_sectors.append(selected_sector)  # Select

        # Update context with the new selection
        context.user_data['selected_job_sectors'] = selected_job_sectors
        print("Updated selected job sectors:", context.user_data['selected_job_sectors'])  # Debug

        # Rebuild the keyboard to reflect updated selections
        job_sector_keyboard = [
            [InlineKeyboardButton(
                f"✅ {option}" if option in selected_job_sectors else option,
                callback_data=f'alert:job_sector_{job_sector_options.index(option)}'
            )]
            for option in job_sector_options
        ]
        job_sector_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Update the message with the new keyboard
        reply_markup = InlineKeyboardMarkup(job_sector_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle "Done" button selection for job sector
    elif criterion == "done":
        await handle_done_selection(update, context)
        return

    # Step 1: Display the qualification selection menu
    if criterion == "education_qualification":
        # Debug: Print the current selections from user data
        print("Initial selected education qualifications:",
              context.user_data.get('selected_education_qualification', []))

        # Create the selection keyboard with check marks for items in user data
        education_qualification_keyboard = [
            [InlineKeyboardButton(
                f"✅ {option}" if option in context.user_data.get('selected_education_qualification', []) else option,
                callback_data=f'alert:education_qualification_{education_qualification_options.index(option)}'
                # Use index for direct mapping
            )]
            for option in education_qualification_options
        ]
        education_qualification_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Send or update the message with the keyboard
        reply_markup = InlineKeyboardMarkup(education_qualification_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Step 2: Handle specific qualification selection using the index from callback_data
    elif criterion.startswith("education_qualification_"):
        # Get the index of the selected qualification from callback data
        selected_index = int(criterion.split("_")[-1])
        selected_qualification = education_qualification_options[selected_index]

        # Toggle the selection in context.user_data
        selected_education_qualifications = context.user_data.get('selected_education_qualification', [])

        # Toggle selection
        if selected_qualification in selected_education_qualifications:
            selected_education_qualifications.remove(selected_qualification)  # Deselect
        else:
            if len(selected_education_qualifications) >= 2:  # Limit selection to 2 options
                await query.message.reply_text(
                    "You can select up to 2 education qualifications only. Please deselect an option to add a new one."
                )
                return
            selected_education_qualifications.append(selected_qualification)  # Select
        # Update the user data with the new selection
        context.user_data['selected_education_qualification'] = selected_education_qualifications
        print("Updated selected education qualifications:",
              context.user_data['selected_education_qualification'])  # Debug

        # Rebuild the keyboard to reflect updated selections
        education_qualification_keyboard = [
            [InlineKeyboardButton(
                f"✅ {option}" if option in selected_education_qualifications else option,
                callback_data=f'alert:education_qualification_{education_qualification_options.index(option)}'
            )]
            for option in education_qualification_options
        ]
        education_qualification_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Update the message with the new keyboard
        reply_markup = InlineKeyboardMarkup(education_qualification_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Step 3: Handle "Done" button to save selections and return to main menu
    elif criterion == "done":
        # Print final selected qualifications for debugging
        print("Final selections saved for education qualifications:",
              context.user_data.get('selected_education_qualification'))
        await handle_done_selection(update, context)  # Save selections and return to main alert settings
        return

    # Handle experience level selection display
    if criterion == "experience_level":
        # Print debug information to verify stored user data
        print("Current selected experience levels:", context.user_data.get('selected_experience_level'))

        # Create keyboard for experience level selection with exact values
        experience_level_keyboard = [
            [InlineKeyboardButton(
                f"✅ {option}" if option in context.user_data.get('selected_experience_level', []) else option,
                callback_data=f'alert:experience_level_{option.lower().replace(" ", "_")}'
            )]
            for option in experience_level_options
        ]
        experience_level_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Display the experience level options
        reply_markup = InlineKeyboardMarkup(experience_level_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle experience level-specific selection (e.g., experience_level_entry_level)
    elif criterion.startswith("experience_level_"):
        # Extract and format selected level directly from callback data without altering format
        selected_level = criterion.split("_", 2)[2].replace("_", " ").title()

        # Toggle the selection of the experience level (multiple selections allowed)
        selected_experience_levels = context.user_data.get('selected_experience_level', [])

        if selected_level in selected_experience_levels:
            selected_experience_levels.remove(selected_level)  # Deselect
        else:
            if len(selected_experience_levels) >= 2:  # Limit selection to 2 options
                await query.message.reply_text(
                    "You can select up to 2 experience levels only. Please deselect an option to add a new one."
                )
                return
            selected_experience_levels.append(selected_level)  # Select new option

        # Update the selected experience levels in user data
        context.user_data['selected_experience_level'] = selected_experience_levels

        # Print debug information to verify new selection
        print("Updated selected experience levels:", context.user_data['selected_experience_level'])

        # Rebuild the keyboard with the selected experience level check marked
        experience_level_keyboard = [
            [InlineKeyboardButton(
                f"✅ {option}" if option in selected_experience_levels else option,
                callback_data=f'alert:experience_level_{option.lower().replace(" ", "_")}'
            )]
            for option in experience_level_options
        ]
        experience_level_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Update the message to reflect selected experience levels without changing the message text
        reply_markup = InlineKeyboardMarkup(experience_level_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle work city selection display
    if criterion == "work_city":
        # Print debug information to verify stored user data
        print("Current selected work cities:", context.user_data.get('selected_work_cities', []))

        # Create keyboard for work city selection using normalized callback data
        work_city_keyboard = [
            [InlineKeyboardButton(
                f"✅ {city}" if city in context.user_data.get('selected_work_cities', []) else city,
                callback_data=f'alert:work_city_{city.lower().replace(" ", "_")}'
            )]
            for city in work_city_options
        ]
        work_city_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Display the work city options
        reply_markup = InlineKeyboardMarkup(work_city_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle work city-specific selection (e.g., work_city_addis_ababa)
    elif criterion.startswith("work_city_"):
        # Extract the selected city from the callback data
        selected_city = criterion.split("_", 2)[2].replace("_", " ").title()

        # Toggle the selection of the work city (multiple selections allowed, up to 2)
        selected_work_cities = context.user_data.get('selected_work_cities', [])

        if selected_city in selected_work_cities:
            selected_work_cities.remove(selected_city)  # Deselect
        else:
            if len(selected_work_cities) >= 2:
                await query.message.reply_text(
                    "You can select up to 2 cities only. Please deselect a city to add a new one.")
                return
            selected_work_cities.append(selected_city)  # Select

        # Update the selected work cities in user data
        context.user_data['selected_work_cities'] = selected_work_cities

        # Print debug information to verify new selection
        print("Updated selected work cities:", context.user_data['selected_work_cities'])

        # Rebuild the keyboard with the selected work cities check marked
        work_city_keyboard = [
            [InlineKeyboardButton(
                f"✅ {city}" if city in selected_work_cities else city,
                callback_data=f'alert:work_city_{city.lower().replace(" ", "_")}'
            )]
            for city in work_city_options
        ]
        work_city_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Update the message to reflect selected work cities without changing the message text
        reply_markup = InlineKeyboardMarkup(work_city_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle "Done" button selection
    elif criterion == "done":
        await handle_done_selection(update, context)  # Save selections and return to main alert settings
        return

    # Display work country selection
    if criterion == "work_country":
        # Print debug information to verify stored user data
        print("Current selected work country:", context.user_data.get('selected_work_country', 'No country selected'))

        # Build keyboard with check mark for the selected work country
        work_country_keyboard = [
            [InlineKeyboardButton(
                f"✅ {country}" if country == context.user_data.get('selected_work_country') else country,
                callback_data=f'alert:work_country_{country.lower()}'
            )]
            for country in work_country_options
        ]
        work_country_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Display the work country options
        reply_markup = InlineKeyboardMarkup(work_country_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Handle specific work country selection (e.g., work_country_ethiopia)
    elif criterion.startswith("work_country_"):
        # Extract and format selected country from callback data
        selected_country = criterion.split("_", 2)[2].capitalize()

        # Toggle selection: deselect if already selected
        if context.user_data.get('selected_work_country') == selected_country:
            context.user_data['selected_work_country'] = None  # Deselect
        else:
            context.user_data['selected_work_country'] = selected_country  # Select

        # Print debug information
        print("Updated selected work country:", context.user_data['selected_work_country'] or "No country selected")

        # Rebuild keyboard with updated selection
        work_country_keyboard = [
            [InlineKeyboardButton(
                f"✅ {country}" if country == context.user_data.get('selected_work_country') else country,
                callback_data=f'alert:work_country_{country.lower()}'
            )]
            for country in work_country_options
        ]
        work_country_keyboard.append([InlineKeyboardButton("Done", callback_data='alert:done')])

        # Update message to reflect selected work country without changing the text
        reply_markup = InlineKeyboardMarkup(work_country_keyboard)
        if query.message.reply_markup != reply_markup:
            await query.edit_message_reply_markup(reply_markup=reply_markup)
        return

    # Save on "Done" and return to main settings
    elif criterion == "done":
        await handle_done_selection(update, context)  # Save and go back to the main alert settings
        return


async def process_job_type_selection(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()  # Acknowledge the callback query

    job_type = query.data.split(':')[1]  # Extract job type from callback data

    # Initialize the job type selection list if it doesn't exist
    if 'selected_job_types' not in context.user_data:
        context.user_data['selected_job_types'] = []

    # Add the job type to the selection list if it is not already included
    if job_type not in context.user_data['selected_job_types']:
        context.user_data['selected_job_types'].append(job_type)
        await query.edit_message_text(f"You selected the job type: {job_type}. You can select more or confirm your selection.")
    else:
        await query.edit_message_text(f"You already selected the job type: {job_type}. Select another or confirm your selection.")

    # Provide an option to confirm or continue selecting
    confirmation_keyboard = [
        [InlineKeyboardButton("Confirm Selection", callback_data='alert:confirm_selection')],
        [InlineKeyboardButton("Back", callback_data='alert:back')]
    ]
    reply_markup = InlineKeyboardMarkup(confirmation_keyboard)
    await update.message.reply_text("What would you like to do next?", reply_markup=reply_markup)


async def confirm_job_type_selection(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()  # Acknowledge the callback query

    selected_types = context.user_data.get('selected_job_types', [])

    if selected_types:
        selected_types_str = ", ".join(selected_types)
        await query.edit_message_text(f"You have confirmed the following job types: {selected_types_str}.")

        # Here you can proceed to save these selections or set alerts based on them
        context.user_data['confirmed_job_types'] = selected_types  # Save confirmed selections

        # Return to the job alerts menu or continue with your logic
        return JOB_ALERTS_MENU  # Adjust as necessary
    else:
        await query.edit_message_text("No job types selected. Please select at least one job type.")


async def process_job_alert_input(update: Update, context: CallbackContext) -> int:
    user_alert_criteria = update.message.text.strip()  # Capture user input for job alerts

    # Logic to save the user's alert preferences to the database
    try:
        # Connect to the PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Example logic to save job alert preferences
        user_chat_id = update.effective_chat.id
        cursor.execute('''
            INSERT INTO job_alerts (user_id, alert_criteria)
            VALUES ((SELECT user_id FROM users WHERE contact = %s), %s)
            ON CONFLICT (user_id) DO UPDATE SET alert_criteria = %s;
        ''', (str(user_chat_id), user_alert_criteria, user_alert_criteria))

        conn.commit()  # Commit the transaction

        await update.message.reply_text("Your job alert preferences have been set successfully!")

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error: {error}")
        await update.message.reply_text("An error occurred while setting your job alerts. Please try again later.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return JOB_ALERTS_MENU  # Return to the job alerts menu


async def handle_job_sector_selection(update: Update, context: CallbackContext):
    # Process the user's sector selection
    selected_sector = ...  # Logic to capture the selection

    # Store selection in context.user_data (example)
    if 'selected_job_sectors' not in context.user_data:
        context.user_data['selected_job_sectors'] = []
    context.user_data['selected_job_sectors'].append(selected_sector)

    # Auto-save after each selection
    user_id = context.user_data.get('user_id')
    applicant_id = context.user_data.get('applicant_id')
    save_job_alerts_to_db(
        user_id=user_id,
        applicant_id=applicant_id,
        selected_sectors=context.user_data.get('selected_job_sectors', []),
        experience_levels=context.user_data.get('selected_experience_level', []),
        job_sites=context.user_data.get('selected_job_sites', []),
        job_types=context.user_data.get('selected_job_types', []),
        work_country=context.user_data.get('selected_work_country'),
        work_cities=context.user_data.get('selected_work_cities', []),
        education_qualifications=context.user_data.get('selected_education_qualification', []),
        salary_ranges=context.user_data.get('selected_salary_amount', []),
        compensation_types=context.user_data.get('selected_compensation_type', []),
        currency_type=context.user_data.get('selected_currency_type'),
        vacancy_number=context.user_data.get('selected_vacancy_number'),
        gender=context.user_data.get('selected_gender', [])
    )

    await update.message.reply_text("Selection saved!")


import psycopg2
from psycopg2.extras import execute_values

def save_job_alerts_to_db(user_id, applicant_id, selected_sectors, experience_levels, job_sites, job_types,
                          work_country, work_cities, education_qualifications, salary_ranges,
                          compensation_types, currency_type, vacancy_number, gender):
    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        query = """
        INSERT INTO user_job_alerts (
            user_id, applicant_id, selected_sectors, experience_levels, job_sites, job_types,
            work_country, work_cities, education_qualifications, salary_ranges,
            compensation_types, currency_type, vacancy_number, gender
        ) VALUES (
            %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s
        )
        ON CONFLICT (user_id) DO UPDATE SET
            selected_sectors = EXCLUDED.selected_sectors,
            experience_levels = EXCLUDED.experience_levels,
            job_sites = EXCLUDED.job_sites,
            job_types = EXCLUDED.job_types,
            work_country = EXCLUDED.work_country,
            work_cities = EXCLUDED.work_cities,
            education_qualifications = EXCLUDED.education_qualifications,
            salary_ranges = EXCLUDED.salary_ranges,
            compensation_types = EXCLUDED.compensation_types,
            currency_type = EXCLUDED.currency_type,
            vacancy_number = EXCLUDED.vacancy_number,
            gender = EXCLUDED.gender,
            updated_at = NOW()
        """

        cursor.execute(query, (
            user_id, applicant_id, selected_sectors, experience_levels, job_sites, job_types,
            work_country, work_cities, education_qualifications, salary_ranges,
            compensation_types, currency_type, vacancy_number, gender
        ))
        conn.commit()
        print("Data saved successfully.")

    except Exception as e:
        print("Error inserting data:", e)

    finally:
        cursor.close()
        conn.close()


import psycopg2
from telegram import Update
from telegram.ext import CallbackContext

async def handle_final_job_alert_confirmation(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.callback_query.from_user.id
    await update.callback_query.answer()

    try:
        # Connect to the PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve `user_id` and `applicant_id`
        cursor.execute('''
            SELECT u.user_id, a.applicant_id
            FROM users u
            LEFT JOIN applicant_profiles a ON u.user_id = a.user_id
            WHERE u.contact = %s
        ''', (str(user_chat_id),))
        user_data = cursor.fetchone()

        if not user_data:
            await update.callback_query.message.reply_text("You are not registered. Please register first.")
            print(f"No user found for contact: {user_chat_id}")
            return

        user_id, applicant_id = user_data
        print(f"Fetched user_id: {user_id}, applicant_id: {applicant_id}")

        # Load existing selections from `user_job_alerts`
        cursor.execute('''
            SELECT selected_sectors, experience_levels, job_sites, job_types,
                   work_country, work_cities, education_qualifications, salary_ranges,
                   compensation_types, currency_type, vacancy_number, gender
            FROM user_job_alerts WHERE user_id = %s
        ''', (user_id,))
        stored_alerts = cursor.fetchone()

        # If no stored alerts exist, set `stored_alerts` to default values to prevent NoneType errors
        if not stored_alerts:
            stored_alerts = ([], [], [], [], None, [], [], [], [], None, None, [])

        # Merge existing database selections with current session selections
        combined_sectors = get_combined_selections(stored_alerts[0] or [], context.user_data.get('selected_job_sectors', []))
        combined_experience_levels = get_combined_selections(stored_alerts[1] or [], context.user_data.get('selected_experience_level', []))
        combined_job_sites = get_combined_selections(stored_alerts[2] or [], context.user_data.get('selected_job_sites', []))
        combined_job_types = get_combined_selections(stored_alerts[3] or [], context.user_data.get('selected_job_types', []))
        combined_work_country = stored_alerts[4] if not context.user_data.get('selected_work_country') else context.user_data.get('selected_work_country')
        combined_work_cities = get_combined_selections(stored_alerts[5] or [], context.user_data.get('selected_work_cities', []))
        combined_education_qualifications = get_combined_selections(stored_alerts[6] or [], context.user_data.get('selected_education_qualification', []))
        combined_salary_ranges = get_combined_selections(stored_alerts[7] or [], context.user_data.get('selected_salary_amount', []))
        combined_compensation_types = get_combined_selections(stored_alerts[8] or [], context.user_data.get('selected_compensation_type', []))
        combined_currency_type = stored_alerts[9] if not context.user_data.get('selected_currency_type') else context.user_data.get('selected_currency_type')
        combined_vacancy_number = stored_alerts[10] if not context.user_data.get('selected_vacancy_number') else context.user_data.get('selected_vacancy_number')
        combined_gender = get_combined_selections(stored_alerts[11] or [], context.user_data.get('selected_gender', []))

        # Insert or update job alert preferences in `user_job_alerts`
        cursor.execute('''
            INSERT INTO user_job_alerts (
                user_id, applicant_id, selected_sectors, experience_levels, job_sites, job_types,
                work_country, work_cities, education_qualifications, salary_ranges,
                compensation_types, currency_type, vacancy_number, gender
            ) VALUES (
                %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s
            )
            ON CONFLICT (user_id) DO UPDATE SET
                selected_sectors = EXCLUDED.selected_sectors,
                experience_levels = EXCLUDED.experience_levels,
                job_sites = EXCLUDED.job_sites,
                job_types = EXCLUDED.job_types,
                work_country = EXCLUDED.work_country,
                work_cities = EXCLUDED.work_cities,
                education_qualifications = EXCLUDED.education_qualifications,
                salary_ranges = EXCLUDED.salary_ranges,
                compensation_types = EXCLUDED.compensation_types,
                currency_type = EXCLUDED.currency_type,
                vacancy_number = EXCLUDED.vacancy_number,
                gender = EXCLUDED.gender,
                updated_at = NOW()
        ''', (
            user_id, applicant_id, combined_sectors, combined_experience_levels, combined_job_sites, combined_job_types,
            combined_work_country, combined_work_cities, combined_education_qualifications, combined_salary_ranges,
            combined_compensation_types, combined_currency_type, combined_vacancy_number, combined_gender
        ))

        conn.commit()
        await update.callback_query.message.reply_text("Your job alert preferences have been saved successfully.")

    except (Exception, psycopg2.DatabaseError) as error:
        print(f"Error saving job alerts: {error}")
        await update.callback_query.message.reply_text(
            "An error occurred while saving your job alerts. Please try again later.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return



# Function to escape text for MarkdownV2
def escape_markdown_v2(text):
    # Escape special characters for Telegram's MarkdownV2
    return re.sub(r'([_\*\[\]\(\)~`>#+\-=|{}.!])', r'\\\1', text)

async def load_saved_job_alerts(user_id, context):
    # Logic to load saved job alerts from the database and update context.user_data
    try:
        conn = psycopg2.connect(dbname="my_project_db", user="postgres", password="1201", host="localhost", port="5432")
        cursor = conn.cursor()

        cursor.execute("SELECT selected_sectors, experience_levels, job_sites, job_types, work_country, work_cities, "
                       "education_qualifications, salary_ranges, compensation_types, currency_type, vacancy_number, gender "
                       "FROM user_job_alerts WHERE user_id = %s", (user_id,))
        row = cursor.fetchone()

        if row:
            # Mapping the data to context.user_data keys
            context.user_data['selected_job_sectors'] = row[0] or []
            context.user_data['selected_experience_level'] = row[1] or []
            context.user_data['selected_job_sites'] = row[2] or []
            context.user_data['selected_job_types'] = row[3] or []
            context.user_data['selected_work_country'] = row[4]
            context.user_data['selected_work_cities'] = row[5] or []
            context.user_data['selected_education_qualification'] = row[6] or []
            context.user_data['selected_salary_amount'] = row[7] or []
            context.user_data['selected_compensation_type'] = row[8] or []
            context.user_data['selected_currency_type'] = row[9]
            context.user_data['selected_vacancy_number'] = row[10]
            context.user_data['selected_gender'] = row[11] or []

    except Exception as e:
        print(f"Error loading saved job alerts: {e}")

    finally:
        cursor.close()
        conn.close()


# Function to save user selections to the database when "Done" is pressed and return to `handle_set_job_alerts`
async def handle_done_selection(update: Update, context: CallbackContext) -> None:
    user_chat_id = update.callback_query.from_user.id
    await update.callback_query.answer()

    try:
        # Connect to the PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve user_id for the job alert update
        cursor.execute("SELECT user_id FROM users WHERE contact = %s", (str(user_chat_id),))
        user_data = cursor.fetchone()
        if not user_data:
            await update.callback_query.message.reply_text("User not found. Please register first.")
            return

        user_id = user_data[0]

        # Fetch updated selections from context.user_data
        updated_job_types = context.user_data.get('selected_job_types', [])
        updated_job_sectors = context.user_data.get('selected_job_sectors', [])
        selected_work_country = context.user_data.get('selected_work_country')
        selected_work_cities = context.user_data.get('selected_work_cities', [])

        # Standardize and remove duplicates for various fields
        selected_education_qualifications = list(set(context.user_data.get('selected_education_qualification', [])))
        # Example in handle_done_selection
        selected_experience_levels = list(set(context.user_data.get('selected_experience_level', [])))

        selected_salary_amounts = list(set(context.user_data.get('selected_salary_amount', [])))
        selected_compensation_types = list(set(context.user_data.get('selected_compensation_type', [])))
        selected_currency_type = context.user_data.get('selected_currency_type')
        selected_vacancy_number = context.user_data.get('selected_vacancy_number')
        selected_gender = list(set(context.user_data.get('selected_gender', [])))
        selected_job_site = [context.user_data.get('selected_job_site')] if context.user_data.get('selected_job_site') else []

        # Ensure that single values are formatted as arrays
        selected_job_site = selected_job_site if isinstance(selected_job_site, list) else [selected_job_site]

        # Save all standardized values to the database
        cursor.execute('''
            INSERT INTO user_job_alerts (
                user_id, job_types, selected_sectors, work_country, work_cities, education_qualifications, 
                experience_levels, salary_ranges, compensation_types, currency_type, vacancy_number, gender, job_sites
            ) VALUES (
                %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s
            )
            ON CONFLICT (user_id) DO UPDATE SET
                job_types = EXCLUDED.job_types,
                selected_sectors = EXCLUDED.selected_sectors,
                work_country = EXCLUDED.work_country,
                work_cities = EXCLUDED.work_cities,
                education_qualifications = EXCLUDED.education_qualifications,
                experience_levels = EXCLUDED.experience_levels,
                salary_ranges = EXCLUDED.salary_ranges,
                compensation_types = EXCLUDED.compensation_types,
                currency_type = EXCLUDED.currency_type,
                vacancy_number = EXCLUDED.vacancy_number,
                gender = EXCLUDED.gender,
                job_sites = EXCLUDED.job_sites
        ''', (
            user_id, updated_job_types, updated_job_sectors, selected_work_country, selected_work_cities,
            selected_education_qualifications, selected_experience_levels, selected_salary_amounts,
            selected_compensation_types, selected_currency_type, selected_vacancy_number, selected_gender, selected_job_site
        ))

        conn.commit()

        # Call handle_set_job_alerts to display the updated selections
        await handle_set_job_alerts(update, context)

    except Exception as error:
        print(f"Error saving selections: {error}")
        await update.callback_query.message.reply_text("An error occurred. Please try again.")

    finally:
        cursor.close()
        conn.close()


from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import CallbackContext
import psycopg2


from datetime import datetime

async def toggle_alert_status(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()

    chat_id = query.message.chat_id
    conn = psycopg2.connect(**DB_PARAMS)
    cursor = conn.cursor()
    cursor.execute(
        "SELECT user_id, status FROM user_job_alerts WHERE user_id = (SELECT user_id FROM users WHERE contact = %s)",
        (str(chat_id),))
    result = cursor.fetchone()

    if result:
        user_id, current_status = result
        new_status = not current_status
        toggle_time = datetime.now()

        if new_status:
            cursor.execute(
                "UPDATE user_job_alerts SET status = %s, last_alert_toggle_on = %s, last_alert_toggle_off = NULL WHERE user_id = %s",
                (new_status, toggle_time, user_id)
            )
        else:
            cursor.execute(
                "UPDATE user_job_alerts SET status = %s, last_alert_toggle_off = %s WHERE user_id = %s",
                (new_status, toggle_time, user_id)
            )
        conn.commit()

        status_text = "ON" if new_status else "OFF"
        button_text = "Turn Alerts OFF" if new_status else "Turn Alerts ON"
        await query.edit_message_text(
            text=(
                f"📢 *Job Alert Status*\n\n"
                f"📬 Job Alerts are currently *{status_text}*.\n\n"
                f"⚡ If your Job Alerts are *ON*, matching job opportunities based on your preferences will be sent to you "
                f"as soon as they are posted. Stay ahead by ensuring your preferences are up-to-date to receive only relevant notifications.\n\n"
                f"⚡ If your Job Alerts are *OFF*, no matching job opportunities will be sent to you. "
                f"You will need to manually browse job postings to find suitable opportunities.\n\n"
                f"👇🏾 To change your Job Alert status, use the button below.\n\n"
                f"⚡ *Stay informed and take control of your job search experience!*"
            ),
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(
                [[InlineKeyboardButton(button_text, callback_data="toggle_alert_status")]])
        )
    else:
        await query.edit_message_text("User alert settings not found.")

    cursor.close()
    conn.close()



# Handler to manage job alerts toggle
async def handle_manage_job_alerts(update: Update, context: CallbackContext) -> int:
    chat_id = update.effective_chat.id
    conn = psycopg2.connect(**DB_PARAMS)
    cursor = conn.cursor()

    # Get the user_id associated with the chat
    cursor.execute("SELECT user_id FROM users WHERE contact = %s;", (str(chat_id),))
    result = cursor.fetchone()
    cursor.close()
    conn.close()

    if not result:
        await update.message.reply_text("User not found.")
        return JOB_ALERTS_MENU

    user_id = result[0]

    # Check the current alert status and provide a toggle option
    conn = psycopg2.connect(**DB_PARAMS)
    cursor = conn.cursor()
    cursor.execute("SELECT status FROM user_job_alerts WHERE user_id = %s;", (user_id,))
    alert_status_result = cursor.fetchone()
    cursor.close()
    conn.close()

    if alert_status_result:
        alert_status = alert_status_result[0]
        status_text = "ON" if alert_status else "OFF"
        toggle_button_text = "Turn Alerts OFF" if alert_status else "Turn Alerts ON"
        toggle_callback_data = "toggle_alert_status"

        # Provide a toggle button and display current status
        keyboard = [[InlineKeyboardButton(toggle_button_text, callback_data=toggle_callback_data)]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            text=(
                f"📢 *Job Alert Status*\n\n"
                f"📬 Job Alerts are currently *{status_text}*.\n\n"
                f"⚡ If your Job Alerts are *ON*, matching job opportunities based on your preferences will be sent to you "
                f"as soon as they are posted. Stay ahead by ensuring your preferences are up-to-date to receive only relevant notifications.\n\n"
                f"⚡ If your Job Alerts are *OFF*, no matching job opportunities will be sent to you. "
                f"You will need to manually browse job postings to find suitable opportunities.\n\n"
                f"👇🏾 To change your Job Alert status, use the button below.\n\n"
                f"⚡ *Stay informed and take control of your job search experience!*"
            ),
            parse_mode="Markdown",
            reply_markup=reply_markup
        )
    else:
        await update.message.reply_text("No job alerts are currently set up.")

    return JOB_ALERTS_MENU


# Callback to handle the toggle action
async def handle_toggle_alert_status(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()
    chat_id = query.message.chat_id

    # Get the user_id based on chat_id
    conn = psycopg2.connect(**DB_PARAMS)
    cursor = conn.cursor()
    cursor.execute("SELECT user_id FROM users WHERE contact = %s;", (str(chat_id),))
    result = cursor.fetchone()
    cursor.close()
    conn.close()

    if not result:
        await query.edit_message_text("User not found.")
        return

    user_id = result[0]

    # Toggle the alert status
    new_status = await toggle_alert_status(user_id)
    if new_status is not None:
        status_text = "ON" if new_status else "OFF"
        toggle_button_text = "Turn Alerts OFF" if new_status else "Turn Alerts ON"

        # Update the message with new status and button
        keyboard = [[InlineKeyboardButton(toggle_button_text, callback_data="toggle_alert_status")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            f"Job Alerts are now *{status_text}*.",
            parse_mode="Markdown",
            reply_markup=reply_markup
        )
    else:
        await query.edit_message_text("Failed to toggle alerts. No job alerts are set up.")


import psycopg2
from telegram import Update
from telegram.ext import CallbackContext

# Database connection parameters
DB_PARAMS = {
    "dbname": "my_project_db",
    "user": "postgres",
    "password": "1201",
    "host": "localhost",
    "port": "5432"
}

from telegram import InlineKeyboardButton, InlineKeyboardMarkup

# Handler to view job alert history with "Remove" button functionality
async def handle_view_alert_history(update: Update, context: CallbackContext) -> int:
    chat_id = update.effective_chat.id
    conn = psycopg2.connect(**DB_PARAMS)
    cursor = conn.cursor()

    # Fetch user_id based on chat_id
    cursor.execute("SELECT user_id FROM users WHERE contact = %s", (str(chat_id),))
    result = cursor.fetchone()
    if result:
        user_id = result[0]
        print(f"Fetching job alert history for user_id: {user_id}")

        # Fetch job alert history for the user, excluding removed jobs
        cursor.execute("""
            SELECT jp.job_title, jp.job_description, jp.job_site, jp.job_type,
                   jp.job_sector, jp.education_qualification, jp.experience_level,
                   jp.location_country, jp.location_city, jp.compensation_type,
                   jp.salary_compensation, jp.currency_type, jp.vacancy_number,
                   jp.applicant_gender, jp.job_application_deadline, jn.notified_at, jp.job_id
            FROM job_notifications jn
            JOIN job_posts jp ON jn.job_id = jp.job_id
            WHERE jn.user_id = %s AND jn.removed = FALSE
            ORDER BY jn.notified_at DESC
            LIMIT 10;
        """, (user_id,))

        alerts = cursor.fetchall()
        cursor.close()
        conn.close()

        if alerts:
            for alert in alerts:
                (job_title, job_description, job_site, job_type, job_sector,
                 education_qualification, experience_level, location_country,
                 location_city, compensation_type, salary_compensation,
                 currency_type, vacancy_number, applicant_gender,
                 job_application_deadline, notified_at, job_id) = alert

                # Format salary/compensation summary
                salary_compensation_summary = (
                    f"{salary_compensation} {currency_type} {compensation_type}" if salary_compensation
                    else f"{currency_type} {compensation_type}"
                )

                # Choose gender icon
                gender_icon = (
                    "⚥" if applicant_gender not in ["Male", "Female"]
                    else "♂️" if applicant_gender == "Male"
                    else "♀️"
                )

                # Construct job summary
                job_summary = (
                    f"🏷️ *Job Title:* {job_title}\n\n"
                    f"🕒 *Job Type:* {job_site}, {job_type}\n\n"
                    f"🏢 *Job Sector:* {job_sector}\n\n"
                    f"📍 *Work Location:* {location_city}, {location_country}\n\n"
                    f"🎓 *Education Qualification:* {education_qualification}\n\n"
                    f"🎖️ *Experience Level:* {experience_level}\n\n"
                    f"💰 *Salary/Compensation:* {salary_compensation_summary}\n\n"
                    f"👥 *Vacancy Number:* {vacancy_number}\n\n"
                    f"{gender_icon} *Applicant Gender:* {applicant_gender}\n\n"
                    f"⏳ *Job Application Deadline:* {job_application_deadline}\n\n"
                    f"📄 *Job Description:*\n{job_description}"
                )

                # Inline buttons with "Remove" button added
                keyboard = [
                    [
                        InlineKeyboardButton("Apply", callback_data=f"apply:{job_id}"),
                        InlineKeyboardButton("Save", callback_data=f"save:{job_id}"),
                        InlineKeyboardButton("Remove", callback_data=f"alert_remove:{job_id}")
                    ]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)

                # Send job summary with buttons
                await update.message.reply_text(job_summary, parse_mode="Markdown", reply_markup=reply_markup)
        else:
            await update.message.reply_text("You have no job alerts in your history.")
    else:
        await update.message.reply_text("User not found in the system.")

    return JOB_ALERTS_MENU



# Handler to remove job from job_notifications when "Remove Alert" button is clicked
async def handle_remove_alert(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()

    if query.data.startswith("alert_remove:"):
        _, job_id = query.data.split(":")
        chat_id = query.message.chat_id

        conn = psycopg2.connect(**DB_PARAMS)
        cursor = conn.cursor()
        cursor.execute("SELECT user_id FROM users WHERE contact = %s", (str(chat_id),))
        result = cursor.fetchone()

        if result:
            user_id = result[0]

            # Mark the notification as removed
            cursor.execute(
                "UPDATE job_notifications SET removed = TRUE WHERE user_id = %s AND job_id = %s",
                (user_id, job_id)
            )
            conn.commit()
            await query.edit_message_text(f"The job alert has been successfully removed from your history.")
        else:
            await query.edit_message_text("Failed to remove job alert. User not found.")

        cursor.close()
        conn.close()


# Handler for Applicant to Chat with Admin
async def contact_admin_applicant(update: Update, context: CallbackContext) -> int:
    """
    Displays the chat history between the applicant and the admin with distinct formatting
    to differentiate admin and applicant messages.
    """
    chat_id = update.message.chat_id

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Verify applicant and get gender
        cursor.execute("""
            SELECT user_id, gender FROM users WHERE contact = %s AND user_type = 'Applicant'
        """, (str(chat_id),))
        result = cursor.fetchone()

        if not result:
            await update.message.reply_text("⚠️ Unable to identify your applicant account. Please contact support.")
            return

        applicant_id, gender = result

        # Determine the icon based on gender
        user_icon = "👨🏾" if gender == "Male" else "👩🏾"

        # Send the Back button first
        await update.message.reply_text(
            "Loading Chats...",
            reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
        )

        # Fetch chat history
        cursor.execute("""
            SELECT sender, message, timestamp FROM applicant_admin_chats
            WHERE applicant_id = %s ORDER BY timestamp ASC
        """, (applicant_id,))
        chat_history = cursor.fetchall()

        # Send each message in the chat history with distinct formatting
        if chat_history:
            for sender, message, timestamp in chat_history:
                formatted_time = timestamp.strftime("%Y-%m-%d %H:%M:%S")
                if sender == "Applicant":
                    # Applicant message (box-style for distinction)
                    text = (
                        f"<b>{user_icon} You:</b>\n"
                        f"<pre>╭──────────────────╮\n"
                        f"│ {message}\n"
                        f"╰──────────────────╯</pre>\n"
                        f"<i>{formatted_time}</i>"
                    )
                else:
                    # Admin message (box-style with distinct header)
                    text = (
                        f"🧑🏿‍💻 <b>Support:</b>\n"
                        f"<pre>╭──────────────────╮\n"
                        f"│ {message}\n"
                        f"╰──────────────────╯</pre>\n"
                        f"<i>{formatted_time}</i>"
                    )

                await update.message.reply_html(text)
        else:
            await update.message.reply_text("No previous messages.")

        # Persist the Back button after loading chat
        await update.message.reply_text(
            "🔙 Back to main menu",
            reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
        )

        # Store applicant ID in context
        context.user_data["chat_with_admin_applicant_id"] = applicant_id

        return CHAT_WITH_ADMIN_APPLICANT

    except Exception as e:
        logger.error(f"Error in contact_admin_applicant: {e}")
        await update.message.reply_text("⚠️ An error occurred. Please try again later.")
        return

    finally:
        if conn:
            cursor.close()
            conn.close()


# Handle Applicant Message
async def handle_applicant_message(update: Update, context: CallbackContext) -> int:
    """
    Logs messages from the applicant, forwards a notification to the admin, and keeps the applicant informed silently.
    """
    applicant_message = update.message.text.strip()
    chat_id = update.message.chat_id

    # Handle "End Chat"
    if applicant_message.lower() == "🔙 back":
        return await end_chat_with_admin_applicant(update, context)

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch applicant ID and details
        applicant_id = context.user_data.get("chat_with_admin_applicant_id")
        if not applicant_id:
            logger.error("Applicant ID not found in context.")
            await update.message.reply_text("⚠️ An error occurred. Please restart the chat session.")
            return

        cursor.execute(
            """
            SELECT first_name, last_name, user_id, phone_number FROM users WHERE user_id = %s
            """,
            (applicant_id,)
        )
        user_details = cursor.fetchone()

        if not user_details:
            logger.error("Applicant details not found in the database.")
            await update.message.reply_text("⚠️ Unable to fetch your details. Please try again.")
            return

        first_name, last_name, user_id, phone_number = user_details
        full_name = f"{first_name} {last_name}".strip()

        # Ensure the phone number includes a "+" sign
        formatted_phone_number = f"+{phone_number}" if not phone_number.startswith("+") else phone_number

        # Provide default admin ID if not dynamic
        admin_id = 896853541  # Replace with dynamic fetching if needed

        # Log the applicant's message into the database
        cursor.execute(
            """
            INSERT INTO applicant_admin_chats (chat_id, applicant_id, admin_id, sender, message, timestamp)
            VALUES (DEFAULT, %s, %s, %s, %s, NOW())
            """,
            (applicant_id, admin_id, "Applicant", applicant_message)
        )
        conn.commit()

        # Send a push notification to the admin
        notification_message = (
            "📢 <b>New Applicant Message Received</b>\n\n"
            f"👤 <b>From:</b> {full_name} (ID: {user_id})\n\n"
            f"📞 <b>Phone:</b> {formatted_phone_number}\n\n"
            f"📩 <b>Message:</b> {applicant_message}"
        )
        await context.bot.send_message(
            chat_id=admin_id,  # Admin's chat ID
            text=notification_message,
            parse_mode="HTML"
        )

        # Notify the applicant about the successful message
        await update.message.reply_text(
            "✔️ Your message has been successfully sent to the admin.\n\n"
            "📩 The admin will review your message and respond within <b>12 hours</b>. "
            "Please revisit this section later to view their response.\n\n"
            "Thank you for your patience and understanding!",
            parse_mode="HTML"
        )

        # Keep the applicant in the chat state
        return CHAT_WITH_ADMIN_APPLICANT

    except Exception as e:
        logger.error(f"Error in handle_applicant_message: {e}")
        await update.message.reply_text("⚠️ An error occurred. Please try again.")
        return CHAT_WITH_ADMIN_APPLICANT

    finally:
        if conn:
            cursor.close()
            conn.close()



async def end_chat_with_admin_applicant(update: Update, context: CallbackContext) -> int:
    """
    Ends the chat session with the admin for the applicant and displays the Messages Menu.
    """
    applicant_id = context.user_data.pop("chat_with_admin_applicant_id", None)

    try:
        # Display the Messages Menu
        await update.message.reply_text(
            "Messages Menu - Select an option:",
            reply_markup=ReplyKeyboardMarkup([
                ["💬 Contact Admin", "🔙 Back to Main Menu"],
            ], resize_keyboard=True)
        )
        return MESSAGES_MENU

    except Exception as e:
        logger.error(f"Error ending chat session for applicant: {e}")
        await update.message.reply_text("⚠️ An error occurred. Please try again.")
        return MESSAGES_MENU



# Handler for Interview Invitations
async def handle_interview_invitations(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text("Here are your interview invitations (placeholder).")
    return MESSAGES_MENU

# Handler for Application Inquiries
async def handle_application_inquiries(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text("Here are your application inquiries (placeholder).")
    return MESSAGES_MENU

import psycopg2
import logging
from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import CallbackContext

# Handler to display all jobs the applicant has been hired for
async def handle_take_new_assessment(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id if update.message else update.callback_query.message.chat_id

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id based on the chat_id
        cursor.execute("SELECT user_id FROM users WHERE contact = %s", (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register first.")
            return SKILL_ASSESSMENTS_MENU

        user_id = user_row[0]

        # Fetch jobs the user has been hired for along with additional details
        cursor.execute('''
           SELECT 
                jp.job_title, 
                cp.company_name, 
                jp.location_city, 
                jp.salary_compensation, 
                jp.currency_type, 
                a.application_message, 
                a.portfolio_links, 
                a.application_date, 
                a.hired_date
            FROM 
                job_posts jp
            JOIN 
                applications a ON jp.job_id = a.job_id
            JOIN 
                company_profiles cp ON jp.user_id = cp.user_id
            WHERE 
                a.user_id = %s 
                AND a.status = 'hired';
        ''', (user_id,))
        hired_jobs = cursor.fetchall()

        if not hired_jobs:
            await update.message.reply_text("You have not been hired for any jobs yet.")
            return SKILL_ASSESSMENTS_MENU

        # Send each hired job as a separate message
        for job in hired_jobs:
            job_title, company_name, location_city, salary, currency, app_message, portfolio_links, app_date, hired_date = job
            message = f"🏢 <b>Job Title:</b> {job_title}\n"
            if company_name:  # Check if company_name exists
                message += f"🏭 <b>Company:</b> {company_name}\n"
            message += f"📍 <b>Location:</b> {location_city}\n"
            if salary:  # Check if salary exists
                message += f"💰 <b>Salary:</b> {salary} {currency}\n"
            if app_message:  # Check if application_message exists
                message += f"✉️ <b>Application Message:</b> {app_message}\n"
            if portfolio_links:  # Check if portfolio_links exists
                message += f"🔗 <b>Portfolio Links:</b> {portfolio_links}\n"
            if app_date:  # Check if application_date exists
                message += f"🗓️ <b>Application Date:</b> {app_date.strftime('%Y-%m-%d %H:%M:%S')}\n"
            if hired_date:  # Check if hired_date exists
                message += f"🤝🏾 <b>Hired Date:</b> {hired_date.strftime('%Y-%m-%d %H:%M:%S')}\n"

            # Send the individual message
            await update.message.reply_text(
                message,
                parse_mode="HTML"
            )



    except (Exception, psycopg2.DatabaseError) as error:
        logging.error(f"Error fetching hired jobs: {error}")
        await update.message.reply_text("An error occurred while fetching your hired jobs.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return SKILL_ASSESSMENTS_MENU



# Handler to display all jobs the applicant has been shortlisted for
async def handle_view_completed_assessments(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id if update.message else update.callback_query.message.chat_id

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id based on the chat_id
        cursor.execute("SELECT user_id FROM users WHERE contact = %s", (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register first.")
            return SKILL_ASSESSMENTS_MENU

        user_id = user_row[0]

        # Fetch jobs the user has been shortlisted for along with additional details
        cursor.execute('''
           SELECT 
                jp.job_title, 
                cp.company_name, 
                jp.location_city, 
                jp.salary_compensation, 
                jp.currency_type, 
                a.application_message, 
                a.portfolio_links, 
                a.application_date
            FROM 
                job_posts jp
            JOIN 
                applications a ON jp.job_id = a.job_id
            JOIN 
                company_profiles cp ON jp.user_id = cp.user_id
            WHERE 
                a.user_id = %s 
                AND a.status = 'shortlisted';
        ''', (user_id,))
        shortlisted_jobs = cursor.fetchall()

        if not shortlisted_jobs:
            await update.message.reply_text("You have not been shortlisted for any jobs yet.")
            return SKILL_ASSESSMENTS_MENU

        # Send each shortlisted job as a separate message
        for job in shortlisted_jobs:
            job_title, company_name, location_city, salary, currency, app_message, portfolio_links, app_date = job
            message = f"🏢 <b>Job Title:</b> {job_title}\n"
            if company_name:  # Check if company_name exists
                message += f"🏭 <b>Company:</b> {company_name}\n"
            message += f"📍 <b>Location:</b> {location_city}\n"
            if salary:  # Check if salary exists
                message += f"💰 <b>Salary:</b> {salary} {currency}\n"
            if app_message:  # Check if application_message exists
                message += f"✉️ <b>Application Message:</b> {app_message}\n"
            if portfolio_links:  # Check if portfolio_links exists
                message += f"🔗 <b>Portfolio Links:</b> {portfolio_links}\n"
            if app_date:  # Check if application_date exists
                message += f"🗓️ <b>Application Date:</b> {app_date.strftime('%Y-%m-%d %H:%M:%S')}\n"

            # Send the individual message
            await update.message.reply_text(
                message,
                parse_mode="HTML"
            )



    except (Exception, psycopg2.DatabaseError) as error:
        logging.error(f"Error fetching shortlisted jobs: {error}")
        await update.message.reply_text("An error occurred while fetching your shortlisted jobs.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return SKILL_ASSESSMENTS_MENU



# Handler to display all jobs the applicant has been rejected for
async def handle_view_badges_certifications(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id if update.message else update.callback_query.message.chat_id

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id based on the chat_id
        cursor.execute("SELECT user_id FROM users WHERE contact = %s", (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register first.")
            return SKILL_ASSESSMENTS_MENU

        user_id = user_row[0]

        # Fetch jobs the user has been rejected for along with additional details
        cursor.execute('''
           SELECT 
                jp.job_title, 
                cp.company_name, 
                jp.location_city, 
                jp.salary_compensation, 
                jp.currency_type, 
                a.application_message, 
                a.portfolio_links, 
                a.application_date, 
                a.rejected_date
            FROM 
                job_posts jp
            JOIN 
                applications a ON jp.job_id = a.job_id
            JOIN 
                company_profiles cp ON jp.user_id = cp.user_id
            WHERE 
                a.user_id = %s 
                AND a.status = 'rejected';
        ''', (user_id,))
        rejected_jobs = cursor.fetchall()

        if not rejected_jobs:
            await update.message.reply_text("You have not been rejected for any jobs yet.")
            return SKILL_ASSESSMENTS_MENU

        # Send each rejected job as a separate message
        for job in rejected_jobs:
            job_title, company_name, location_city, salary, currency, app_message, portfolio_links, app_date, rej_date = job
            message = f"🏢 <b>Job Title:</b> {job_title}\n"
            if company_name:  # Check if company_name exists
                message += f"🏭 <b>Company:</b> {company_name}\n"
            message += f"📍 <b>Location:</b> {location_city}\n"
            if salary:  # Check if salary exists
                message += f"💰 <b>Salary:</b> {salary} {currency}\n"
            if app_message:  # Check if application_message exists
                message += f"✉️ <b>Application Message:</b> {app_message}\n"
            if portfolio_links:  # Check if portfolio_links exists
                message += f"🔗 <b>Portfolio Links:</b> {portfolio_links}\n"
            if app_date:  # Check if application_date exists
                message += f"🗓️ <b>Application Date:</b> {app_date.strftime('%Y-%m-%d %H:%M:%S')}\n"
            if rej_date:  # Check if rejected_date exists
                message += f"🙅🏿‍♂️ <b>Rejected Date:</b> {rej_date.strftime('%Y-%m-%d %H:%M:%S')}\n"

            # Send the individual message
            await update.message.reply_text(
                message,
                parse_mode="HTML"
            )


    except (Exception, psycopg2.DatabaseError) as error:
        logging.error(f"Error fetching rejected jobs: {error}")
        await update.message.reply_text("An error occurred while fetching your rejected jobs.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return SKILL_ASSESSMENTS_MENU


# Handler for View Badges & Certifications
async def handle_view_badges(update: Update, context: CallbackContext) -> int:
    # Placeholder logic for viewing badges and certifications
    await update.message.reply_text("Here are your badges and certifications (placeholder).")

    # Return to the appropriate menu (e.g., SKILL_ASSESSMENTS_MENU)
    return SKILL_ASSESSMENTS_MENU

# Handler for Notification Preferences
async def handle_notification_preferences(update: Update, context: CallbackContext) -> int:
    # Placeholder logic for notification preferences
    await update.message.reply_text("Here you can manage your notification preferences (placeholder).")

    # Return to the appropriate menu (e.g., SETTINGS_MENU)
    return SETTINGS_MENU


async def handle_privacy_settings(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id if update.message else update.callback_query.message.chat_id

    try:
        # Connect to the database to fetch the applicant's current privacy setting
        conn = get_db_connection()
        cursor = conn.cursor()

        cursor.execute(
            "SELECT opt_out_search FROM applicant_profiles WHERE user_id = (SELECT user_id FROM users WHERE contact = %s)",
            (str(user_chat_id),))
        opt_out_status = cursor.fetchone()

        # Default to False if no setting exists
        if not opt_out_status:
            opt_out_status = [False]

        # Prepare the toggle button text based on current status
        toggle_status = "Turn ON Search Visibility" if opt_out_status[0] else "Turn OFF Search Visibility"

        # Message and buttons
        message = (
            "🔒 <b>Privacy Settings</b>\n\n"
            "Manage your privacy settings here. You can control whether employers can search for your profile.\n\n"
            f"🔍 <b>Search Visibility:</b> {'Enabled' if not opt_out_status[0] else 'Disabled'}\n"
        )

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(toggle_status, callback_data="toggle_search_visibility")],

        ])

        if update.callback_query:
            await update.callback_query.edit_message_text(message, parse_mode="HTML", reply_markup=keyboard)
        else:
            await update.message.reply_text(message, parse_mode="HTML", reply_markup=keyboard)

    except Exception as e:
        await update.message.reply_text("An error occurred while fetching privacy settings.")
        logging.error(f"Error: {e}")
    finally:
        if conn:
            cursor.close()
            conn.close()

    return SETTINGS_MENU


async def toggle_search_visibility(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.callback_query.message.chat_id

    try:
        # Connect to the database
        conn = get_db_connection()
        cursor = conn.cursor()

        # Fetch the current opt-out status
        cursor.execute("SELECT opt_out_search FROM applicant_profiles WHERE user_id = (SELECT user_id FROM users WHERE contact = %s)", (str(user_chat_id),))
        current_status = cursor.fetchone()

        # Default to False if no record exists
        if not current_status:
            current_status = [False]

        # Toggle the opt-out status
        new_status = not current_status[0]
        cursor.execute("UPDATE applicant_profiles SET opt_out_search = %s WHERE user_id = (SELECT user_id FROM users WHERE contact = %s)", (new_status, str(user_chat_id)))
        conn.commit()

        # Confirmation message
        status_text = "enabled" if not new_status else "disabled"
        await update.callback_query.answer(f"Search visibility has been {status_text}.", show_alert=True)

        # Refresh the privacy settings menu
        return await handle_privacy_settings(update, context)

    except Exception as e:
        await update.callback_query.answer("An error occurred while updating your privacy setting.", show_alert=True)
        logging.error(f"Error: {e}")
    finally:
        if conn:
            cursor.close()
            conn.close()

    return SETTINGS_MENU


# Handler for Language Preferences
async def handle_language_preferences(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text("Here you can manage your language preferences (placeholder).")
    return SETTINGS_MENU

# Handler for FAQs
async def handle_faqs(update: Update, context: CallbackContext) -> int:
    """
    Display the link to the FAQs hosted on Telegra.ph.
    """
    await update.message.reply_text(
        "📖 Please refer to our FAQs page to find answers to common questions:\n\n"
        "👉🏾 [FAQs](https://telegra.ph/Faqs-12-27)",
        parse_mode="Markdown",

    )

    # Return to the appropriate menu (e.g., HELP_SUPPORT_MENU)
    return HELP_SUPPORT_MENU


# Handler for Contact Support
async def handle_contact_support(update: Update, context: CallbackContext) -> int:
    # Display Contact Support information
    contact_support_text = (
        "📞 *Contact Support*\n\n"
        "For further assistance, please feel free to contact us directly:\n\n"
        "📌 *Company Name*: Afro Joblink\n\n"
        "📞 *Support Phone*: +251-911-123-456\n\n"
        "📧 *Support Email*: support@afrojoblink.com\n\n"
        "We're here to help you with any queries or issues!"
    )

    # Send the Contact Support text
    await update.message.reply_text(
        contact_support_text,
        parse_mode='Markdown'
    )

    return HELP_SUPPORT_MENU

# Handler for User Guide
async def handle_user_guide(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text("Here is the user guide (placeholder).")
    return HELP_SUPPORT_MENU



# Function to handle job searching logic
async def handle_job_search(update: Update, context: CallbackContext) -> int:
    search_query = update.message.text

    # Placeholder logic: you can implement the actual search logic later
    await update.message.reply_text(f"Searching for jobs with the keyword: {search_query}")

    # For now, return to the applicant main menu after displaying a placeholder message
    return await show_applicant_main_menu(update, context)


async def show_employer_menu(update: Update, context: CallbackContext) -> int:
    contact = str(update.message.chat_id)
    log_debug(f"Attempting to display Employer Menu for user: {contact}")

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Check if the user is banned
        cursor.execute('SELECT status, first_name FROM users WHERE contact = %s', (contact,))
        result = cursor.fetchone()

        if result:
            status, first_name = result

            if status == "banned":
                # Notify banned user and terminate the flow
                await update.message.reply_text(
                    f"🚫 Dear {first_name},\n\n"
                    "Your access to the platform has been restricted due to a violation of our policies.\n\n"
                    "If you believe this is a mistake, please contact support:\n"
                    "📧 support@example.com\n📞 +1 800 123 4567",
                    parse_mode="HTML"
                )
                return

        # Valid menu options
        valid_choices = {
            "🗂️ Job Management",
            "📄 Applications",
            "🔍 Search & Filter",
            "🪪 Profile",
            "💳 Billing & Payments",
            "📢 Notifications",
            "⚙️ Performance",
            "📞 Support",
        }

        # Display the Employer Menu
        await update.message.reply_text(
            "<b>🏢 Employer Menu</b>\n\n"
            "Welcome to your Employer Dashboard! Select an option below to manage your account and postings efficiently:\n\n"
            "🗂️ <b>Job Management:</b> Create, manage, and track your job postings.\n\n"
            "📄 <b>Applications:</b> View, shortlist, and manage applicants.\n\n"
            "🔍 <b>Search & Filter:</b> Search for candidates and filter results to match your requirements.\n\n"
            "🪪 <b>Profile:</b> Update your company profile and personal details.\n\n"
            "💳 <b>Billing & Payments:</b> Manage your subscription and payment details.\n\n"
            "📢 <b>Notifications:</b> Configure alerts and notifications for job applications and updates.\n\n"
            "⚙️ <b>Performance:</b> Analyze your job postings' performance and applicant insights.\n\n"
            "📞 <b>Support:</b> Reach out for assistance or feedback.\n\n"
            "Choose an action to proceed:",
            reply_markup=ReplyKeyboardMarkup([
                ["🗂️ Job Management", "📄 Applications"],
                ["🔍 Search & Filter", "🪪 Profile"],
                ["💳 Billing & Payments", "📢 Notifications"],
                ["⚙️ Performance", "📞 Support"]
            ], resize_keyboard=True),
            parse_mode="HTML"
        )
        return EMPLOYER_MENU  # Main employer menu state


    except Exception as e:
        log_error(f"Database error while checking banned status for {contact}: {e}")
        await update.message.reply_text("An error occurred. Please try again later.")
        return

    finally:
        if conn:
            cursor.close()
            conn.close()


# Step 2: Handle Employer Menu Selection
async def handle_employer_menu_selection(update: Update, context: CallbackContext) -> int:
    choice = update.message.text

    # Handle the /menu command regardless of the current state
    if choice == '/exit':
        return await exit(update, context)  # Return the appropriate main menu

    if choice == "🗂️ Job Management":
        await update.message.reply_text(
            "<b>🗂️ Job Management</b>\n\n"
            "Manage your job postings effortlessly using the options below:\n\n"
            "📝 <b>Post a New Job:</b> Create a brand-new job listing.\n\n"
            "📂 <b>Opened Jobs:</b> View and manage jobs that are currently active and accepting applications.\n\n"
            "🕒 <b>Pending Jobs:</b> Review jobs that are awaiting approval or activation.\n\n"
            "🔒 <b>Closed Jobs:</b> Access jobs that are no longer open for applications.\n\n"
            "🔁 <b>Repost Jobs:</b> Bring back previously posted jobs to the active list.\n\n"
            "💾 <b>Saved Jobs:</b> Manage job drafts or jobs saved for later posting.\n\n"
            "Select an action to proceed:",
            reply_markup=ReplyKeyboardMarkup([
                ["📝 Post a New Job", "📂 Opened Jobs"],
                ["🕒 Pending Jobs", "🔒 Closed Jobs"],
                ["🔁 Repost Jobs", "💾 Saved Jobs"],
                ["🔙 Back"]
            ], resize_keyboard=True),
            parse_mode="HTML"
        )
        return JOB_MANAGEMENT



    elif choice == "📄 Applications":
        await update.message.reply_text(
            "<b>📄 Applications Management</b>\n\n"
            "Manage all your job applications efficiently with the options below:\n\n"
            "🔍 <b>View Applicants:</b> Check out all the candidates who have applied for your job posts.\n\n"
            "📋 <b>Shortlisted:</b> Review the applicants you've shortlisted for further evaluation.\n\n"
            "⚖️ <b>Hired Applicants:</b> Keep track of applicants you've successfully hired.\n\n"
            "📞 <b>Contact Applicants:</b> Reach out to applicants directly for interviews or discussions.\n\n"
            "Choose an action to manage your job applications effectively!",
            reply_markup=ReplyKeyboardMarkup([
                ["🔍 View Applicants", "📋 Shortlisted"],
                ["⚖️ Hired Applicants", "📞 Contact Applicants"],
                ["🔙 Back"]
            ], resize_keyboard=True),
            parse_mode="HTML"
        )
        return APPLICATIONS


    elif choice == "🔍 Search & Filter":
        await update.message.reply_text(
            "<b>🔍 Search & Filter Applicants</b>\n\n"
            "Easily find and filter applicants based on your preferences. Choose from the options below to get started:\n\n"
            "🔍 <b>Search Applicants:</b> Input specific keywords to locate applicants from the entire Afro Joblink platform.\n\n"
            "🔬 <b>Filter Applicants:</b> Refine your search with detailed criteria like skills, location, experience level, and more.\n\n"
            "Find the perfect candidates quickly and efficiently!",
            reply_markup=ReplyKeyboardMarkup([
                ["🔍 Search Applicants", "🔬 Filter Applicants"],
                ["🔙 Back"]
            ], resize_keyboard=True),
            parse_mode="HTML"
        )
        return SEARCH_FILTER


    elif choice == "🪪 Profile":
        await update.message.reply_text(
            "<b>🪪 Profile Management</b>\n\n"
            "Manage your profile and company details with ease. Select an option below to update or view your information:\n\n"
            "➕🪪 <b>Add Profile:</b> Create or update your personal profile with the latest details.\n\n"
            "🏢 <b>Company Profile:</b> View your company information, including key details and verification status.\n\n"
            "➕📞 <b>Add Contact:</b> Add or update your contact details to stay connected.\n\n"
            "Keep your information up-to-date to ensure smooth communication!",
            reply_markup=ReplyKeyboardMarkup([
                ["➕🪪 Add Profile", "🏢 Company Profile"],
                ["➕📞 Add Contact", "🔙 Back"]

            ], resize_keyboard=True),
            parse_mode="HTML"
        )
        return PROFILE_MANAGEMENT


    elif choice == "💳 Billing & Payments":
        await update.message.reply_text(
            "<b>💳 Billing & Payments</b>\n\n"
            "Efficiently manage all your payment-related activities and explore premium options. "
            "Select from the actions below to proceed:\n\n"
            "📄 <b>Make Payments:</b> Complete payments for job postings to go live.\n\n"
            "🕑 <b>Payment History:</b> Review your past payment records and receipts.\n\n"
            "⭐ <b>Upgrade to Premium:</b> Unlock advanced features with premium packages tailored for your needs.\n\n"
            "📈 <b>Payment Statistics:</b> Track your expenses and view package details.\n\n"
            "Choose an option below to continue:",
            reply_markup=ReplyKeyboardMarkup([
                ["💳 Make Payments", "📜 Payment History"],
                ["⭐ Upgrade to Premium", "📈 Payment Stat"],
                [ "🔙 Back"]
            ], resize_keyboard=True),
            parse_mode="HTML"
        )
        return BILLING_PAYMENTS


    elif choice == "📢 Notifications":

        await update.message.reply_text(
            "<b>📢 Notifications Settings</b>\n\n"
            "Stay updated with alerts tailored to your preferences. Choose from the options below to manage how you receive notifications:\n\n"
            "📬 <b>Application Alerts:</b> Get notified whenever a new application is submitted for your job posts. You can choose between normal or silent alerts.\n\n"
            "⏳ <b>Post Expiry Alerts:</b> Receive reminders about job posts nearing their deadline. Stay informed to take timely actions.\n\n"
            "Customize your notifications and never miss out on important updates!",
            reply_markup=ReplyKeyboardMarkup([
                ["📢 Application Alerts", "⏳ Post Expiry Alerts"],
                ["🔙 Back"]
            ], resize_keyboard=True),
            parse_mode="HTML"
        )
        return NOTIFICATIONS


    elif choice == "⚙️ Performance":
        await update.message.reply_text(
            "⚡ <b>Track Your Job Post Performance</b>\n\n"
            "📈 <i>Stay ahead with detailed analytics on your job posts.</i>\n\n"
            "🔍 <b>Features:</b>\n\n"
            "•📩  <b>Applications Received:</b> Monitor the number of applicants.\n\n"
            "•✔️  <b>Shortlisted Candidates:</b> Track your talent pipeline.\n\n"
            "•🤝🏾  <b>Hires:</b> See how many applicants have been hired.\n\n"
            "•🕒  <b>Pending Applications:</b> Follow up on undecided candidates.\n\n"
            "📍 <i>Gain insights into top applicant locations and demographics.</i>\n\n"
            "👇🏾 <b>Select an option below to get started:</b>",
            reply_markup=ReplyKeyboardMarkup([
                ["⚡ Opened Jobs", "🔒 Closed Jobs"],
                ["🔙 Back"]
            ], resize_keyboard=True),
            parse_mode="HTML"
        )
        return SETTINGS


    elif choice == "📞 Support":

        await update.message.reply_text(
            "<b>📞 Support Center</b>\n\n"
            "Need assistance or have questions? Our support team is here to help you. Explore the options below:\n\n"
            "•🧑🏾‍💻  <b>Contact Admin:</b> Reach out directly to our support team for personalized assistance.\n\n"
            "•💁🏾‍♂️  <b>Help Center:</b> Find detailed information on how to navigate the platform and use its features.\n\n"
            "•❓  <b>FAQs:</b> Access answers to common questions to resolve issues quickly on your own.\n\n"
            "We are committed to providing you with the best experience possible. Choose an option below to proceed.",
            reply_markup=ReplyKeyboardMarkup([
                ["💬 Contact Admin", "🛠️ Help Center"],
                ["❓ FAQs", "🔙 Back"]
            ], resize_keyboard=True),
            parse_mode="HTML"
        )
        return SUPPORT

    else:
        # Global fallback to the main menu on invalid input
        await update.message.reply_text("⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button.")
        return await show_employer_menu(update, context)  # Return to the employer menu state

# Step 3: Handle Submenu Selection (e.g., Job Management Submenu)
async def handle_job_management_menu(update: Update, context: CallbackContext) -> int:
    # List of valid choices
    valid_choices = [
        "📝 Post a New Job",
        "📂 Opened Jobs",
        "🕒 Pending Jobs",
        "🔒 Closed Jobs",
        "🔁 Repost Jobs",
        "💾 Saved Jobs",
        "🔙 Back",
    ]

    # Retrieve the user's choice
    choice = update.message.text

    # Validate input
    if choice not in valid_choices:
        # Inform the user to select only from the buttons
        await update.message.reply_text(
            "⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button.",
            reply_markup=ReplyKeyboardMarkup(
                [
                    ["📝 Post a New Job", "📂 Opened Jobs"],
                    ["🕒 Pending Jobs", "🔒 Closed Jobs"],
                    ["🔁 Repost Jobs", "💾 Saved Jobs"],
                    ["🔙 Back"]
                ],
                resize_keyboard=True
            )
        )
        return JOB_MANAGEMENT

    # Handle each valid choice
    if choice == "📝 Post a New Job":
        return await start_job_filling(update, context)
    elif choice == "📂 Opened Jobs":
        return await view_opened_jobs(update, context)
    elif choice == "🕒 Pending Jobs":
        return await view_pending_jobs(update, context)
    elif choice == "🔒 Closed Jobs":
        return await closed_jobs(update, context)
    elif choice == "🔁 Repost Jobs":
        return await repost_closed_jobs(update, context)
    elif choice == "💾 Saved Jobs":
        return await view_drafted_jobs(update, context)
    elif choice == "🔙 Back":
        return await show_employer_menu(update, context)

# Handle Applications Menu
async def handle_applications_menu(update: Update, context: CallbackContext) -> int:
    # Define valid choices for the Applications Menu
    valid_choices = {
        "🔍 View Applicants",
        "📋 Shortlisted",
        "⚖️ Hired Applicants",
        "📞 Contact Applicants",
        "🔙 Back",
    }

    # Retrieve user input
    choice = update.message.text

    # Validate user input
    if choice not in valid_choices:
        # Re-prompt the user with the Applications Menu
        await update.message.reply_text(
            "⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button.",
            reply_markup=ReplyKeyboardMarkup([
                ["🔍 View Applicants", "📋 Shortlisted"],
                ["⚖️ Hired Applicants", "📞 Contact Applicants"],
               ["🔙 Back"]
            ], resize_keyboard=True)
        )
        return APPLICATIONS

    # Handle valid choices
    log_debug(f"User selected: {choice}")
    if choice == "🔍 View Applicants":
        return await view_applicants(update, context)  # Call the function directly
    elif choice == "📋 Shortlisted":
        return await view_shortlisted_applicants(update, context)
    elif choice == "⚖️ Hired Applicants":
        return await hired_applicants(update, context)
    elif choice == "📞 Contact Applicants":
        return await contact_applicants(update, context)
    elif choice == "🔙 Back":
        return await show_employer_menu(update, context)



# Handle Search & Filter Menu
async def handle_search_filter_menu(update: Update, context: CallbackContext) -> int:
    # Define valid choices for the Search & Filter Menu
    valid_choices = {
        "🔍 Search Applicants",
        "🔬 Filter Applicants",
        "🔙 Back",
    }

    # Retrieve user input
    choice = update.message.text

    # Validate user input
    if choice not in valid_choices:
        # Re-prompt the user with the Search & Filter Menu
        await update.message.reply_text(
            "⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button.",
            reply_markup=ReplyKeyboardMarkup([
                ["🔍 Search Applicants", "🔬 Filter Applicants"],
                ["🔙 Back"]
            ], resize_keyboard=True)
        )
        return SEARCH_FILTER

    # Handle valid choices
    log_debug(f"User selected: {choice}")
    if choice == "🔍 Search Applicants":
        return await search_applicants(update, context)
    elif choice == "🔬 Filter Applicants":
        return await start_filtering(update, context)
    elif choice == "🔙 Back":
        return await show_employer_menu(update, context)

# Handle Profile Management Menu
async def handle_profile_management_menu(update: Update, context: CallbackContext) -> int:
    # Define valid choices for the Profile Management Menu
    valid_choices = {
        "➕🪪 Add Profile",
        "🏢 Company Profile",
        "➕📞 Add Contact",
        "🔙 Back",
    }

    # Retrieve user input
    choice = update.message.text

    # Validate user input
    if choice not in valid_choices:
        # Re-prompt the user with the Profile Management Menu
        await update.message.reply_text(
            "⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button.",
            reply_markup=ReplyKeyboardMarkup([
                ["➕🪪 Add Profile", "🏢 Company Profile"],
                ["➕📞 Add Contact", "🔙 Back"],

            ], resize_keyboard=True)
        )
        return PROFILE_MANAGEMENT

    # Handle valid choices
    log_debug(f"User selected: {choice}")
    if choice == "➕🪪 Add Profile":
        return await edit_employer_profile(update, context)
    elif choice == "🏢 Company Profile":
        return await show_employer_profile(update, context)
    elif choice == "➕📞 Add Contact":
        return await add_company_contact_information(update, context)
    elif choice == "🔙 Back":
        return await show_employer_menu(update, context)



# Handle Billing & Payments Menu
async def handle_billing_payments_menu(update: Update, context: CallbackContext) -> int:
    # Define valid choices for the Billing & Payments Menu
    valid_choices = {
        "💳 Make Payments",
        "📜 Payment History",
        "⭐ Upgrade to Premium",
        "📈 Payment Stat",
        "🔙 Back",
    }

    # Retrieve user input
    choice = update.message.text

    # Validate user input
    if choice not in valid_choices:
        # Re-prompt the user with the Billing & Payments Menu
        await update.message.reply_text(
            "⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button.",
            reply_markup=ReplyKeyboardMarkup([
                ["💳 Make Payments", "📜 Payment History"],
                ["⭐ Upgrade to Premium", "📈 Payment Stat"],
                ["🔙 Back"]
            ], resize_keyboard=True)
        )
        return BILLING_PAYMENTS

    # Handle valid choices
    log_debug(f"User selected: {choice}")
    if choice == "💳 Make Payments":
        return await handle_manage_job_payments(update, context)
    elif choice == "📜 Payment History":
        return await handle_view_payment_history(update, context)
    elif choice == "⭐ Upgrade to Premium":
        return await show_premium_packages(update, context)
    elif choice == "📈 Payment Stat":
        return await handle_payment_stat(update, context)
    elif choice == "🔙 Back":
        return await show_employer_menu(update, context)

# Handle Notifications Menu
async def handle_notifications_menu(update: Update, context: CallbackContext) -> int:
    # Define valid choices for the Notifications Menu
    valid_choices = {
        "📢 Application Alerts",
        "⏳ Post Expiry Alerts",
        "🔙 Back",
    }

    # Retrieve user input
    choice = update.message.text

    # Validate user input
    if choice not in valid_choices:
        # Re-prompt the user with the Notifications Menu
        await update.message.reply_text(
            "⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button.",
            reply_markup=ReplyKeyboardMarkup([
                ["📢 Application Alerts", "⏳ Post Expiry Alerts"],
                ["🔙 Back"]
            ], resize_keyboard=True)
        )
        return NOTIFICATIONS

    # Handle valid choices
    log_debug(f"User selected: {choice}")
    if choice == "📢 Application Alerts":
        return await job_application_alerts(update, context)
    elif choice == "⏳ Post Expiry Alerts":
        return await post_expiry_alerts(update, context)
    elif choice == "🔙 Back":
        return await show_employer_menu(update, context)

# Handle Settings Menu
async def handle_settings_menu(update: Update, context: CallbackContext) -> int:
    # Define valid choices for the Settings Menu
    valid_choices = {
        "⚡ Opened Jobs",
        "🔒 Closed Jobs",

        "🔙 Back",
    }

    # Retrieve user input
    choice = update.message.text

    # Validate user input
    if choice not in valid_choices:
        # Re-prompt the user with the Settings Menu
        await update.message.reply_text(
            "⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button.",
            reply_markup=ReplyKeyboardMarkup([
                ["⚡ Opened Jobs", "🔒 Closed Jobs"],

                ["🔙 Back"]
            ], resize_keyboard=True)
        )
        return SETTINGS

    # Handle valid choices
    log_debug(f"User selected: {choice}")
    if choice == "⚡ Opened Jobs":
        return await handle_job_post_performance(update, context)
    elif choice == "🔒 Closed Jobs":
        return await handle_closed_job_posts(update, context)

    elif choice == "🔙 Back":
        return await show_employer_menu(update, context)


# Handle Support Menu
async def handle_support_menu(update: Update, context: CallbackContext) -> int:
    # Define valid choices for the Support Menu
    valid_choices = {
        "💬 Contact Admin",
        "🛠️ Help Center",
        "❓ FAQs",
        "🔙 Back",
    }

    # Retrieve user input
    choice = update.message.text

    # Validate user input
    if choice not in valid_choices:
        # Re-prompt the user with the Support Menu
        await update.message.reply_text(
            "⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button.",
            reply_markup=ReplyKeyboardMarkup([
                ["💬 Contact Admin", "🛠️ Help Center"],
                ["❓ FAQs", "🔙 Back"]
            ], resize_keyboard=True)
        )
        return SUPPORT

    # Handle valid choices
    log_debug(f"User selected: {choice}")
    if choice == "💬 Contact Admin":
        return await contact_admin(update, context)
    elif choice == "🛠️ Help Center":
        return await help_center(update, context)
    elif choice == "❓ FAQs":
        return await faqs(update, context)
    elif choice == "🔙 Back":
        return await show_employer_menu(update, context)

async def show_profile_management_menu(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Profile Management: Please choose an action.",
        reply_markup=ReplyKeyboardMarkup([
            ["➕🪪 Add Profile", "🏢 Company Profile"],
            ["➕📞 Add Contact", "🔙 Back"]

        ], resize_keyboard=True)
    )
    return PROFILE_MANAGEMENT



# Step 1.1: Handle the "Post a Job" button
async def post_a_new_job(update: Update, context: CallbackContext) -> int:
    # This function will guide the user to the post a job process
    await update.message.reply_text(
        "Welcome to the Post a Job Menu. Please select an option.",
        reply_markup=ReplyKeyboardMarkup([
            ["New Job", "Templates"],
            ["Guidelines", "Back"]
        ], resize_keyboard=True)
    )
    return POST_JOB_MENU  # Assuming this leads to a new state called POST_JOB_MENU



from telegram import InlineKeyboardButton, InlineKeyboardMarkup
import re
from datetime import date
import psycopg2
from telegram import Update
from telegram.ext import CallbackContext

# Function to escape special characters for MarkdownV2
def escape_markdown_v2(text):
    return re.sub(r'([_\*\[\]\(\)~`>#+\-=|{}.!])', r'\\\1', str(text))

# Function to format the deadline with a suffix (e.g., "20th")
def format_deadline_with_suffix(deadline_date):
    try:
        if isinstance(deadline_date, date):
            day_suffix = "th" if 11 <= deadline_date.day <= 13 else {1: "st", 2: "nd", 3: "rd"}.get(deadline_date.day % 10, "th")
            return deadline_date.strftime(f"%B {deadline_date.day}{day_suffix}, %Y")
        return deadline_date
    except Exception as e:
        logger.error(f"Error formatting deadline: {e}")
        return deadline_date

# Function to handle viewing opened jobs with the option to close them
async def view_opened_jobs(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id  # Telegram chat_id

    conn = None
    cursor = None

    try:
        # Step 1: Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 2: Map chat_id to user_id in the users table
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return JOB_MANAGEMENT

        user_id = user_row[0]

        # Step 3: Fetch the 'opened' status_id from the job_status table
        cursor.execute('SELECT status_id FROM job_status WHERE status_name = %s', ('opened',))
        opened_status_row = cursor.fetchone()

        if not opened_status_row:
            await update.message.reply_text("Could not find 'opened' status. Please contact support.")
            return JOB_MANAGEMENT

        opened_status_id = opened_status_row[0]

        # Step 4: Fetch jobs with 'opened' status for the user, ordered by creation date
        cursor.execute('''
            SELECT jp.job_id, jp.job_title, jp.job_description, jp.job_site, jp.job_type, 
                   jp.job_sector, jp.education_qualification, jp.experience_level, 
                   jp.location_country, jp.location_city, jp.compensation_type, 
                   jp.salary_compensation, jp.currency_type, jp.vacancy_number,
                   jp.applicant_gender, jp.job_application_deadline, jp.user_id, jp.created_at
            FROM job_posts jp
            WHERE jp.user_id = %s AND jp.status_id = %s
            ORDER BY jp.created_at ASC
        ''', (user_id, opened_status_id))

        opened_jobs = cursor.fetchall()

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error: {error}")
        await update.message.reply_text("An error occurred while retrieving opened jobs.")
        return JOB_MANAGEMENT

    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

    # Step 5: Display the full job summaries with a close button
    if opened_jobs:
        for job in opened_jobs:
            job_id, job_title, job_description, job_site, job_type, job_sector, education_qualification, \
            experience_level, location_country, location_city, compensation_type, salary_compensation, \
            currency_type, vacancy_number, applicant_gender, job_application_deadline, company_user_id, created_at = job

            # Format the application deadline
            if isinstance(job_application_deadline, date):
                job_application_deadline = format_deadline_with_suffix(job_application_deadline)

            # Gender icon logic
            gender_icon = "⚥" if applicant_gender not in ["Male", "Female"] else "♂️" if applicant_gender == "Male" else "♀️"

            # Format salary/compensation summary
            if salary_compensation:
                salary_compensation = int(salary_compensation) if float(salary_compensation).is_integer() else salary_compensation
                salary_compensation_summary = f"{salary_compensation} {currency_type} {compensation_type}"
            else:
                salary_compensation_summary = f"{currency_type} {compensation_type}"

            # Fetch company profile details for the current job
            try:
                conn = psycopg2.connect(
                    dbname="my_project_db",
                    user="postgres",
                    password="1201",
                    host="localhost",
                    port="5432"
                )
                cursor = conn.cursor()

                cursor.execute('''
                    SELECT cp.company_name, cp.is_verified
                    FROM company_profiles cp
                    WHERE cp.user_id = %s
                ''', (company_user_id,))

                company_profile = cursor.fetchone()
                if company_profile and company_profile[1]:  # Verified company
                    company_name = company_profile[0]
                    verified_company_section = (
                        f"\n\n{'\\_' * 30}\n\n*{escape_markdown_v2(company_name)}*\n✅ Verified Company\n\u200B\n\n"
                    )
                else:  # Unverified or missing profile
                    company_name = "Private Client"
                    verified_company_section = (
                        f"\n\n{'\\_' * 30}\n\n*{escape_markdown_v2(company_name)}*\n\u200B\n\n"
                    )

            except (Exception, psycopg2.DatabaseError) as error:
                logger.error(f"Error fetching company profile: {error}")
                company_name = "Private Client"
                verified_company_section = (
                    f"\n\n{'\\_' * 30}\n\n*{escape_markdown_v2(company_name)}*\n\n"
                )

            finally:
                if cursor:
                    cursor.close()
                if conn:
                    conn.close()

            # Job summary for display
            job_summary = (
                f"🏷️ *Job Title:* {escape_markdown_v2(job_title)}\n\n"
                f"🕒 *Job Type:* {escape_markdown_v2(job_site)}, {escape_markdown_v2(job_type)}\n\n"
                f"🏢 *Job Sector:* {escape_markdown_v2(job_sector)}\n\n"
                f"📍 *Work Location:* {escape_markdown_v2(location_city)}, {escape_markdown_v2(location_country)}\n\n"
                f"🎓 *Education Qualification:* {escape_markdown_v2(education_qualification)}\n\n"
                f"🎖️ *Experience Level:* {escape_markdown_v2(experience_level)}\n\n"
                f"💰 *Salary/Compensation:* {escape_markdown_v2(salary_compensation_summary)}\n\n"
                f"👥 *Vacancy Number:* {escape_markdown_v2(str(vacancy_number))}\n\n"
                f"{gender_icon} *Applicant Gender:* {escape_markdown_v2(applicant_gender)}\n\n"
                f"⏳ *Job Application Deadline:* {escape_markdown_v2(job_application_deadline)}\n\n"
                f"📄 *Job Description:* {escape_markdown_v2(job_description)}"
            ) + verified_company_section

            # Add an inline button to close the job
            inline_keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("🔒 Close Job", callback_data=f"close_job:{job_id}")]
            ])

            await update.message.reply_text(text=job_summary, parse_mode='MarkdownV2', reply_markup=inline_keyboard)
    else:
        await update.message.reply_text("You have no opened jobs at the moment.")

    return JOB_MANAGEMENT




async def close_job(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    job_id = query.data.split(":")[1]  # Extract job_id from callback data

    try:
        # Step 1: Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 2: Update the job status to 'closed'
        cursor.execute('''
            UPDATE job_posts
            SET status_id = (SELECT status_id FROM job_status WHERE status_name = 'closed')
            WHERE job_id = %s
        ''', (job_id,))
        conn.commit()

        # Step 3: Retrieve full job details including message_id and channel_username
        cursor.execute('''
            SELECT jp.message_id, jp.channel_username, jp.job_title, jp.job_description, 
                   jp.job_site, jp.job_type, jp.job_sector, jp.education_qualification, 
                   jp.experience_level, jp.location_country, jp.location_city, jp.compensation_type, 
                   jp.salary_compensation, jp.currency_type, jp.vacancy_number, jp.applicant_gender, 
                   jp.job_application_deadline, cp.company_name, cp.is_verified, 
                   (SELECT COUNT(*) FROM job_posts WHERE user_id = jp.user_id) AS total_posts,
                   (SELECT SUM(repost_count) FROM job_posts WHERE user_id = jp.user_id) AS total_reposts,
                   jp.repost_count
            FROM job_posts jp
            LEFT JOIN company_profiles cp ON jp.user_id = cp.user_id
            WHERE jp.job_id = %s
        ''', (job_id,))
        job_data = cursor.fetchone()

        if not job_data:
            await query.answer(text="Job details not found.", show_alert=True)
            return

        (
            message_id, channel_username, job_title, job_description, job_site, job_type,
            job_sector, education_qualification, experience_level, location_country,
            location_city, compensation_type, salary_compensation, currency_type,
            vacancy_number, applicant_gender, job_application_deadline, company_name,
            is_verified, total_posts, total_reposts, specific_repost_count
        ) = job_data

        # Ensure company name or set to "Private Client" if not verified
        company_name = company_name if is_verified else "Private Client"

        # Salary/compensation summary
        salary_compensation_summary = (
            f"{int(salary_compensation) if salary_compensation.is_integer() else salary_compensation} {currency_type} {compensation_type}"
            if salary_compensation else
            f"{currency_type} {compensation_type}"
        )

        # Gender icon
        gender_icon = {"Male": "♂️", "Female": "♀️"}.get(applicant_gender, "⚥")

        # Dynamically construct repost section
        repost_section = ""
        if total_reposts > 0:
            repost_section += f"♻️ *Total Reposts (All Jobs):* {total_reposts}\n\n"
        if specific_repost_count > 0:
            repost_section += f"🔂 *Reposts for This Job:* {specific_repost_count}\n"

        # Construct the company details section
        if is_verified:
            verified_company_section = (
                f"*{company_name}*\n"
                f"Verified Company ✅\n\n"
                f"📁 *Total Jobs Posted:* {total_posts}\n\n"
                f"{repost_section}"  # Include dynamic repost section if available
            )
        else:
            verified_company_section = (
                f"*Private Client*\n\n"
                f"📁 *Total Jobs Posted:* {total_posts}\n\n"
                f"{repost_section}"  # Include dynamic repost section if available
            )

        # Full job summary with "Job Closed" added at the bottom
        job_summary = (
            f"🏷️ *Job Title:* {job_title}\n\n"
            f"🕒 *Job Type:* {job_site}, {job_type}\n\n"
            f"🏢 *Job Sector:* {job_sector}\n\n"
            f"📍 *Work Location:* {location_city}, {location_country}\n\n"
            f"🎓 *Education Qualification:* {education_qualification}\n\n"
            f"🎖️ *Experience Level:* {experience_level}\n\n"
            f"💰 *Salary/Compensation:* {salary_compensation_summary}\n\n"
            f"👥 *Vacancy Number:* {vacancy_number}\n\n"
            f"{gender_icon} *Applicant Gender:* {applicant_gender}\n\n"
            f"⏳ *Job Application Deadline:* {job_application_deadline}\n\n"
            f"📄 *Job Description:*\n{job_description}\n"
            f"{'\\_' * 30}\n\n"
            f"{verified_company_section}"
            f"{'\\_' * 30}\n\n"
            f"🚫 *Job Closed*\n"
        )

        # Remove '@' from channel_username if present
        channel_username = channel_username.lstrip('@')

        # Step 4: Edit the channel message
        apply_button = InlineKeyboardButton("Apply", url=f"https://t.me/{context.bot.username}?start=apply_{job_id}")
        reply_markup = InlineKeyboardMarkup([[apply_button]])

        await context.bot.edit_message_text(
            chat_id=f"@{channel_username}",
            message_id=message_id,
            text=job_summary,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )

        # Notify the user that the job was closed
        await query.answer(text="Job has been closed successfully.")
        await query.message.edit_reply_markup(reply_markup=None)  # Remove inline buttons

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error: {error}")
        await query.answer(text="An error occurred while closing the job.")

    finally:
        if conn:
            cursor.close()
            conn.close()





from telegram import InlineKeyboardButton, InlineKeyboardMarkup
import psycopg2
import re
from datetime import date
import logging

logger = logging.getLogger(__name__)

# Function to escape special characters for MarkdownV2
def escape_markdown_v2(text):
    return re.sub(r'([_\*\[\]\(\)~`>#+\-=|{}.!])', r'\\\1', str(text))

# Function to format the deadline with a suffix (e.g., "20th")
def format_deadline_with_suffix(deadline_date):
    try:
        if isinstance(deadline_date, date):
            day_suffix = "th" if 11 <= deadline_date.day <= 13 else {1: "st", 2: "nd", 3: "rd"}.get(deadline_date.day % 10, "th")
            return deadline_date.strftime(f"%B {deadline_date.day}{day_suffix}, %Y")
        return deadline_date
    except Exception as e:
        logger.error(f"Error formatting deadline: {e}")
        return deadline_date

# Function to handle viewing pending jobs with a dynamic company verification section
async def view_pending_jobs(update, context):
    user_chat_id = update.message.chat_id  # Telegram chat_id

    conn = None
    cursor = None

    try:
        # Step 1: Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 2: Map chat_id to user_id in the users table
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return JOB_MANAGEMENT

        user_id = user_row[0]

        # Step 3: Fetch the 'pending' status_id from the job_status table
        cursor.execute('SELECT status_id FROM job_status WHERE status_name = %s', ('pending',))
        pending_status_row = cursor.fetchone()

        if not pending_status_row:
            await update.message.reply_text("Could not find 'pending' status. Please contact support.")
            return JOB_MANAGEMENT

        pending_status_id = pending_status_row[0]

        # Step 4: Fetch jobs with 'pending' status for the user, ordered by creation date
        cursor.execute('''
            SELECT jp.job_id, jp.job_title, jp.job_description, jp.job_site, jp.job_type, 
                   jp.job_sector, jp.education_qualification, jp.experience_level, 
                   jp.location_country, jp.location_city, jp.compensation_type, 
                   jp.salary_compensation, jp.currency_type, jp.vacancy_number,
                   jp.applicant_gender, jp.job_application_deadline, jp.user_id, jp.created_at
            FROM job_posts jp
            WHERE jp.user_id = %s AND jp.status_id = %s
            ORDER BY jp.created_at ASC
        ''', (user_id, pending_status_id))

        pending_jobs = cursor.fetchall()

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error: {error}")
        await update.message.reply_text("An error occurred while retrieving pending jobs.")
        return JOB_MANAGEMENT

    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

    # Step 5: Display the full job summaries
    if pending_jobs:
        for job in pending_jobs:
            job_id, job_title, job_description, job_site, job_type, job_sector, education_qualification, \
            experience_level, location_country, location_city, compensation_type, salary_compensation, \
            currency_type, vacancy_number, applicant_gender, job_application_deadline, company_user_id, created_at = job

            # Format the application deadline
            if isinstance(job_application_deadline, date):
                job_application_deadline = format_deadline_with_suffix(job_application_deadline)

            # Gender icon logic
            gender_icon = "⚥" if applicant_gender not in ["Male", "Female"] else "♂️" if applicant_gender == "Male" else "♀️"

            # Format salary/compensation summary
            salary_compensation_summary = (
                f"{int(salary_compensation)} {currency_type} {compensation_type}" if salary_compensation else
                f"{currency_type} {compensation_type}"
            )

            # Fetch company profile details for the current job
            try:
                conn = psycopg2.connect(
                    dbname="my_project_db",
                    user="postgres",
                    password="1201",
                    host="localhost",
                    port="5432"
                )
                cursor = conn.cursor()

                cursor.execute('''
                    SELECT cp.company_name, cp.is_verified
                    FROM company_profiles cp
                    WHERE cp.user_id = %s
                ''', (company_user_id,))

                company_profile = cursor.fetchone()
                company_name = company_profile[0] if company_profile and company_profile[1] else "Private Client"
                is_verified = company_profile[1] if company_profile else False

            except (Exception, psycopg2.DatabaseError) as error:
                logger.error(f"Error fetching company profile: {error}")
                company_name = "Private Client"
                is_verified = False

            finally:
                if cursor:
                    cursor.close()
                if conn:
                    conn.close()

            # Job summary for display
            job_summary = (
                f"🏷️ *Job Title:* {escape_markdown_v2(job_title)}\n\n"
                f"🕒 *Job Type:* {escape_markdown_v2(job_site)}, {escape_markdown_v2(job_type)}\n\n"
                f"🏢 *Job Sector:* {escape_markdown_v2(job_sector)}\n\n"
                f"📍 *Work Location:* {escape_markdown_v2(location_city)}, {escape_markdown_v2(location_country)}\n\n"
                f"🎓 *Education Qualification:* {escape_markdown_v2(education_qualification)}\n\n"
                f"🎖️ *Experience Level:* {escape_markdown_v2(experience_level)}\n\n"
                f"💰 *Salary/Compensation:* {escape_markdown_v2(salary_compensation_summary)}\n\n"
                f"👥 *Vacancy Number:* {escape_markdown_v2(str(vacancy_number))}\n\n"
                f"{gender_icon} *Applicant Gender:* {escape_markdown_v2(applicant_gender)}\n\n"
                f"⏳ *Job Application Deadline:* {escape_markdown_v2(job_application_deadline)}\n\n"
                f"📄 *Job Description:* {escape_markdown_v2(job_description)}\n\n"
                f"{'\\_' * 30}\n\n"
                f"*{escape_markdown_v2(company_name)}*\n"
                f"{'✅ Verified Company' if is_verified else ''}\u200B\n"
            )

            # Add an inline button to close the job
            inline_keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("🔒 Close Job", callback_data=f"close_job:{job_id}")]
            ])

            await update.message.reply_text(text=job_summary, parse_mode='MarkdownV2', reply_markup=inline_keyboard)
    else:
        await update.message.reply_text("You have no pending jobs at the moment.")

    return JOB_MANAGEMENT


from telegram import InlineKeyboardButton, InlineKeyboardMarkup
import psycopg2
import re
from datetime import date
import logging

logger = logging.getLogger(__name__)

# Function to escape special characters for MarkdownV2
def escape_markdown_v2(text):
    return re.sub(r'([_\*\[\]\(\)~`>#+\-=|{}.!])', r'\\\1', str(text))

# Function to format the deadline with a suffix (e.g., "20th")
def format_deadline_with_suffix(deadline_date):
    try:
        if isinstance(deadline_date, date):
            day_suffix = "th" if 11 <= deadline_date.day <= 13 else {1: "st", 2: "nd", 3: "rd"}.get(deadline_date.day % 10, "th")
            return deadline_date.strftime(f"%B {deadline_date.day}{day_suffix}, %Y")
        return deadline_date
    except Exception as e:
        logger.error(f"Error formatting deadline: {e}")
        return deadline_date

# Function to handle viewing drafted jobs
async def view_drafted_jobs(update, context):
    user_chat_id = update.message.chat_id  # Telegram chat_id

    conn = None
    cursor = None

    try:
        # Step 1: Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 2: Map chat_id to user_id in the users table
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("❌ You are not registered. Please register.")
            return JOB_MANAGEMENT

        user_id = user_row[0]

        # Step 3: Fetch the 'drafted' status_id from the job_status table
        cursor.execute('SELECT status_id FROM job_status WHERE status_name = %s', ('drafted',))
        drafted_status_row = cursor.fetchone()

        if not drafted_status_row:
            await update.message.reply_text("❌ Could not find 'drafted' status. Please contact support.")
            return JOB_MANAGEMENT

        drafted_status_id = drafted_status_row[0]

        # Step 4: Fetch jobs with 'drafted' status for the user, ordered by creation date
        cursor.execute('''
            SELECT jp.job_id, jp.job_title, jp.job_description, jp.job_site, jp.job_type, 
                   jp.job_sector, jp.education_qualification, jp.experience_level, 
                   jp.location_country, jp.location_city, jp.compensation_type, 
                   jp.salary_compensation, jp.currency_type, jp.vacancy_number,
                   jp.applicant_gender, jp.job_application_deadline, jp.user_id, jp.created_at
            FROM job_posts jp
            WHERE jp.user_id = %s AND jp.status_id = %s
            ORDER BY jp.created_at ASC
        ''', (user_id, drafted_status_id))

        drafted_jobs = cursor.fetchall()

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error: {error}")
        await update.message.reply_text("❌ An error occurred while retrieving drafted jobs.")
        return JOB_MANAGEMENT

    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

    # Step 5: Display the full job summaries
    if drafted_jobs:
        for job in drafted_jobs:
            job_id, job_title, job_description, job_site, job_type, job_sector, education_qualification, \
            experience_level, location_country, location_city, compensation_type, salary_compensation, \
            currency_type, vacancy_number, applicant_gender, job_application_deadline, company_user_id, created_at = job

            # Format date fields if necessary
            if isinstance(job_application_deadline, date):
                job_application_deadline = format_deadline_with_suffix(job_application_deadline)

            # Gender icon logic
            gender_icon = {
                "Male": "♂️",
                "Female": "♀️",
                "Both": "🚻"
            }.get(applicant_gender, "⚥")

            # Format salary/compensation summary
            salary_parts = []
            if salary_compensation:
                salary_parts.append(str(int(salary_compensation)))
            if currency_type:
                salary_parts.append(currency_type)
            if compensation_type:
                salary_parts.append(compensation_type)

            salary_compensation_summary = " ".join(salary_parts) if salary_parts else None

            # Fetch company profile details for the current job
            try:
                conn = psycopg2.connect(
                    dbname="my_project_db",
                    user="postgres",
                    password="1201",
                    host="localhost",
                    port="5432"
                )
                cursor = conn.cursor()

                cursor.execute('''
                    SELECT cp.company_name, cp.is_verified
                    FROM company_profiles cp
                    WHERE cp.user_id = %s
                ''', (company_user_id,))

                company_profile = cursor.fetchone()
                company_name = company_profile[0] if company_profile else "Private Client"
                is_verified = company_profile[1] if company_profile else False

            except (Exception, psycopg2.DatabaseError) as error:
                logger.error(f"Error fetching company profile: {error}")
                company_name = "Private Client"
                is_verified = False

            finally:
                if cursor:
                    cursor.close()
                if conn:
                    conn.close()

            # Job summary for display with proper escaping
            job_summary = (
                f"🏷️ *Job Title:* {escape_markdown_v2(job_title)}\n\n"
                f"🕒 *Job Type:* {escape_markdown_v2(job_site)}, {escape_markdown_v2(job_type)}\n\n"
                f"🏢 *Job Sector:* {escape_markdown_v2(job_sector)}\n\n"
                f"📍 *Work Location:* {escape_markdown_v2(location_city)}, {escape_markdown_v2(location_country)}\n\n"
                f"🎓 *Education Qualification:* {escape_markdown_v2(education_qualification)}\n\n"
                f"🎖️ *Experience Level:* {escape_markdown_v2(experience_level)}\n\n"
                )

            if salary_compensation_summary:
                job_summary += f"💰 *Salary/Compensation:* {escape_markdown_v2(salary_compensation_summary)}\n\n"

            job_summary += (
                f"👥 *Vacancy Number:* {escape_markdown_v2(str(vacancy_number))}\n\n"
                f"{gender_icon} *Applicant Gender:* {escape_markdown_v2(applicant_gender)}\n\n"
                f"⏳ *Job Application Deadline:* {escape_markdown_v2(job_application_deadline)}\n\n"
                f"📄 *Job Description:*\n{escape_markdown_v2(job_description)}\n\n"
                f"{'\\_' * 30}\n\n"
                f"*{escape_markdown_v2(company_name)}*\n"
                f"{'✅ Verified Company' if is_verified else ''}\u200B\n"
            )

            # Add inline buttons to manage the drafted job
            inline_keyboard = InlineKeyboardMarkup([
                [
                    InlineKeyboardButton("✏️ Edit", callback_data=f"edit_draft_job:{job_id}"),
                    InlineKeyboardButton("🗑️ Delete", callback_data=f"delete_draft:{job_id}"),
                    InlineKeyboardButton("📤 Post Job", callback_data=f"post_draft:{job_id}")
                ]
            ])

            await update.message.reply_text(text=job_summary, parse_mode='MarkdownV2', reply_markup=inline_keyboard)
    else:
        await update.message.reply_text("You have no drafted jobs at the moment.")

    return JOB_MANAGEMENT


import psycopg2
from telegram import InlineKeyboardMarkup, InlineKeyboardButton
import logging

logger = logging.getLogger(__name__)

async def handle_delete_job_draft(update, context):
    """Handle the deletion of a drafted job post."""
    query = update.callback_query
    await query.answer()  # Acknowledge the callback

    # Extract the job_id from the callback data
    callback_data = query.data
    job_id = callback_data.split(":")[1]  # Extract job_id

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Delete the draft from the database
        cursor.execute('DELETE FROM job_posts WHERE job_id = %s AND status_id = %s', (job_id, 8))  # Status 8 = Drafted
        if cursor.rowcount == 0:
            logger.error(f"No drafted job found with job_id {job_id} to delete.")
            await query.message.reply_text("❌ Draft not found or already deleted.")
            return

        conn.commit()

        # Delete the message containing the job summary
        try:
            await query.message.delete()
        except Exception as e:
            logger.error(f"Failed to delete message: {e}")

        # Notify the user of successful deletion
        await query.message.reply_text("🗑️ Draft successfully deleted.")

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error while deleting job draft: {error}")
        await query.message.reply_text("❌ An error occurred while deleting the draft. Please try again.")

    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()




import psycopg2
from datetime import datetime
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
import logging

logger = logging.getLogger(__name__)

ADMIN_ID = '896853541'  # Admin chat ID

async def handle_post_job(update, context):
    """Handle the Post Job action triggered by the 📤 Post Job button."""
    query = update.callback_query
    await query.answer()  # Acknowledge the callback

    # Extract the job_id from the callback data
    callback_data = query.data
    job_id = callback_data.split(":")[1]  # Extract job_id

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch the job details from the database
        cursor.execute('SELECT user_id, job_application_deadline FROM job_posts WHERE job_id = %s', (job_id,))
        job_row = cursor.fetchone()

        if not job_row:
            logger.error(f"No job found with job_id {job_id}.")
            await query.message.reply_text("❌ Job not found. Please try again.")
            return

        user_id, job_application_deadline = job_row

        # Check the job post limit and package details
        cursor.execute('''
                    SELECT job_post_limit, package_name, package_expiration 
                    FROM package_usage 
                    WHERE user_id = %s AND package_expiration > NOW()
                ''', (user_id,))
        package_row = cursor.fetchone()

        job_post_limit = "Not Available"
        package_name = "Unknown"

        if package_row:
            job_post_limit, package_name, package_expiration = package_row
            if job_post_limit <= 0:
                await update.message.reply_text(
                    f"⚠️ You have reached the job post limit for your package '{package_name}'. "
                    "Your job post will still be sent to the admin for approval. Please consider upgrading your package."
                )
        else:
            await update.message.reply_text(
                "⚠️ You don't have an active package or your package has expired. "
                "Your job post will still be sent to the admin for approval. Please consider purchasing a package."
            )

        # Deduct job post limit if applicable
        if package_row and job_post_limit > 0:
            cursor.execute('''
                        UPDATE package_usage
                        SET job_post_limit = job_post_limit - 1
                        WHERE user_id = %s AND package_expiration > NOW()
                    ''', (user_id,))
            conn.commit()

        # Format the application deadline for display
        if job_application_deadline:
            day_suffix = "th" if 11 <= job_application_deadline.day <= 13 else {1: "st", 2: "nd", 3: "rd"}.get(
                job_application_deadline.day % 10, "th"
            )
            formatted_deadline_display = job_application_deadline.strftime(f"%B {job_application_deadline.day}{day_suffix}, %Y")
        else:
            formatted_deadline_display = "N/A"

        # Validate required fields in the database
        cursor.execute('''
            SELECT job_title, job_description, job_site, job_type, job_sector,
                   education_qualification, experience_level, location_country, location_city,
                   compensation_type, salary_compensation, currency_type, vacancy_number,
                   applicant_gender
            FROM job_posts WHERE job_id = %s
        ''', (job_id,))
        job_details = cursor.fetchone()

        if not job_details:
            logger.error(f"Required fields missing for job_id {job_id}.")
            await query.message.reply_text("❌ Missing required fields in the draft. Please edit the draft before posting.")
            return

        # Construct job summary for admin
        (job_title, job_description, job_site, job_type, job_sector,
         education_qualification, experience_level, location_country, location_city,
         compensation_type, salary_compensation, currency_type, vacancy_number,
         applicant_gender) = job_details


        # Fetch company details and total reposts
        cursor.execute('''
            SELECT company_name, is_verified FROM company_profiles WHERE user_id = %s
        ''', (user_id,))
        company_row = cursor.fetchone()
        company_name = company_row[0] if company_row else "Private Client"
        is_verified = company_row[1] if company_row else False

        cursor.execute('SELECT COUNT(*) FROM job_posts WHERE user_id = %s', (user_id,))
        total_posts = cursor.fetchone()[0]

        cursor.execute('SELECT SUM(repost_count) FROM job_posts WHERE user_id = %s', (user_id,))
        total_reposts_all_jobs = cursor.fetchone()[0] or 0

        # Construct the company details section
        repost_section = f"♻️ *Total Reposts (All Jobs):* {total_reposts_all_jobs}\n\n" if total_reposts_all_jobs > 0 else ""
        package_section = (
            f"📦 *Current Package:* {package_name}\n\n"
            f"📝 *Job Posts Remaining:* {job_post_limit}\n\n"
        )
        company_section = (
            f"*{company_name}*\n"
            f"{'Verified Company ✅' if is_verified else 'Private Client'}\n\n"
            f"📁 *Total Jobs Posted:* {total_posts}\n\n"
            f"{repost_section}{package_section}"
        )


        combined_job_type = f"{job_site}, {job_type}".strip(", ")
        work_location = f"{location_city}, {location_country}".strip(", ")
        salary_summary = f"{int(salary_compensation)} {currency_type} ({compensation_type})" if salary_compensation else "N/A"
        gender_icon = {"Male": "♂️", "Female": "♀️", "Both": "🚻"}.get(applicant_gender, "⚥")

        job_summary = (
            f"🏷️ *Job Title:* {job_title}\n\n"
            f"🕒 *Job Type:* {combined_job_type}\n\n"
            f"🏢 *Job Sector:* {job_sector}\n\n"
            f"📍 *Work Location:* {work_location}\n\n"
            f"🎓 *Education Qualification:* {education_qualification}\n\n"
            f"🎖️ *Experience Level:* {experience_level}\n\n"
            f"💰 *Salary/Compensation:* {salary_summary}\n\n"
            f"👥 *Vacancy Number:* {vacancy_number}\n\n"
            f"{gender_icon} *Applicant Gender:* {applicant_gender}\n\n"
            f"⏳ *Job Application Deadline:* {formatted_deadline_display}\n\n"
            f"📄 *Job Description:*\n{job_description}\n\n"
            f"{'_' * 30}\n\n{company_section}{'_' * 30}"
        )

        # Forward the job post to the admin
        admin_message = await context.bot.send_message(
            chat_id=ADMIN_ID,
            text=job_summary,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("Approve", callback_data=f"approve:{job_id}")],
                [InlineKeyboardButton("Deny", callback_data=f"deny:{job_id}")],
                [InlineKeyboardButton("Request Payment", callback_data=f"request_payment:{job_id}")]
            ])
        )

        # Update the job post with the admin message ID
        cursor.execute("UPDATE job_posts SET message_id = %s, status_id = %s WHERE job_id = %s", (admin_message.message_id, 1, job_id))
        conn.commit()

        # Notify the user of success
        await query.message.reply_text(
            "🎉 *Success!* Your job post has been forwarded to the admin for approval.\n\n"
            "📩 You will be notified once your job post is reviewed. Thank you!",
            parse_mode="Markdown"
        )

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error while posting job: {error}")
        await query.message.reply_text("❌ An error occurred while posting the job. Please try again.")

    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()




# Start editing draft
async def start_editing_job_draft(update: Update, context: CallbackContext):
    """Start the editing process for a job draft."""
    query = update.callback_query  # Handle callback queries
    await query.answer()  # Acknowledge the callback query

    # Extract job_id from the callback data
    job_id = query.data.split(":")[1]
    context.user_data["draft_job_id"] = job_id

    # Retrieve the draft details from the database
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()

        # Fetch the draft details where status_id = 8 (Drafted Jobs)
        cursor.execute(
            '''
            SELECT job_title, job_description, job_site, job_type, job_sector, education_qualification,
                   experience_level, location_country, location_city, compensation_type, salary_compensation,
                   currency_type, vacancy_number, applicant_gender, job_application_deadline
            FROM job_posts
            WHERE job_id = %s AND status_id = 8
            ''',
            (job_id,),
        )
        draft_data = cursor.fetchone()

        if draft_data:
            # Map database fields to keys for easier tracking
            keys = [
                "draft_job_title", "draft_job_description", "draft_job_site", "draft_job_type", "draft_job_sector",
                "draft_education_level", "draft_experience_level", "draft_location_country", "draft_location_city",
                "draft_compensation_type", "draft_salary_compensation", "draft_currency_type", "draft_vacancy_number",
                "draft_applicant_gender", "draft_application_deadline",
            ]
            context.user_data.update(dict(zip(keys, draft_data)))

            # Ensure all values are present; fallback to "Not provided" only if field is NULL
            for key, value in context.user_data.items():
                if value is None or value == "":
                    context.user_data[key] = "Not provided"
        else:
            await query.message.reply_text("❌ Could not find the draft. Please try again.")
            return

    except Exception as e:
        logger.error(f"Database error while fetching draft: {e}")
        await query.message.reply_text("❌ An error occurred. Please try again later.")
        return

    finally:
        if conn:
            cursor.close()
            conn.close()

    # Begin editing
    await query.message.reply_text(
        "Let's edit your draft. Select a section to update:",
        reply_markup=ReplyKeyboardMarkup(
            [
                ["🏷️ Job Title", "📄 Job Description"],
                ["🏭 Job Site", "🕒 Job Type"],
                ["🏢 Job Sector", "🎓 Education Qualification"],
                ["🎖️ Experience Level", "🌐 Location (Country)"],
                ["📍 Location (City)", "💰 Compensation Type"],
                ["💲 Salary", "💱 Currency Type"],
                ["👥 Vacancy Number", "🚻 Applicant Gender"],
                ["⏳ Application Deadline", "💾 Update Draft"],
                ["🔙 Back"],
            ],
            resize_keyboard=True,
        ),
    )
    return EDIT_DRAFT_SECTION



async def handle_draft_section_selection(update: Update, context: CallbackContext):
    """Handle selection of sections for editing the draft."""
    section = update.message.text.strip()
    context.user_data["current_section"] = section  # Track the current section

    if section == "🏷️ Job Title":
        # Temporarily hide the keyboard
        await update.message.reply_text(
            "Please enter the new Job Title:",
            reply_markup=ReplyKeyboardRemove()
        )
        return EDIT_DRAFT_TITLE



    elif section == "📄 Job Description":
        # Temporarily hide the keyboard for editing Job Description
        await update.message.reply_text(
            "Please enter the new Job Description:",
            reply_markup=ReplyKeyboardRemove()
        )
        return EDIT_DRAFT_DESCRIPTION

    elif section == "🏭 Job Site":
        return await fetch_and_show_draft_job_sites(update, context)

    elif section == "🕒 Job Type":
        return await fetch_and_show_draft_job_types(update, context)

    elif section == "🏢 Job Sector":
        return await fetch_and_show_draft_job_sectors(update, context)

    elif section == "🎓 Education Qualification":
        return await fetch_and_show_draft_education_levels(update, context)

    elif section == "🎖️ Experience Level":
        return await fetch_and_show_draft_experience_levels(update, context)

    elif section == "🌐 Location (Country)":
        return await fetch_and_show_draft_countries(update, context)

    elif section == "📍 Location (City)":
        return await fetch_and_show_draft_cities(update, context)

    elif section == "💰 Compensation Type":
        return await fetch_and_show_draft_compensation_types(update, context)

    elif section == "💲 Salary":
        # Temporarily hide the keyboard for editing Salary
        await update.message.reply_text(
            "Please enter the new Salary/Compensation Amount:",
            reply_markup=ReplyKeyboardRemove()
        )
        return EDIT_DRAFT_SALARY

    elif section == "💱 Currency Type":
        return await fetch_and_show_draft_currency_types(update, context)


    elif section == "👥 Vacancy Number":
        # Temporarily hide the keyboard for editing Vacancy Number
        await update.message.reply_text(
            "Please enter the new number of vacancies for this job:",
            reply_markup=ReplyKeyboardRemove()
        )
        return EDIT_DRAFT_VACANCY

    elif section == "🚻 Applicant Gender":
        await update.message.reply_text(
            "Please select the preferred gender for applicants:",
            reply_markup=ReplyKeyboardMarkup(
                [["Male", "Female", "Both"]],
                resize_keyboard=True,
            ),
        )
        return EDIT_DRAFT_GENDER

    elif section == "⏳ Application Deadline":
        await update.message.reply_text(
            "Please enter the new job application deadline (format: dd/mm/yyyy):",
            reply_markup=ReplyKeyboardMarkup([["Skip"]], resize_keyboard=True),
        )
        return EDIT_DRAFT_DEADLINE


    elif section == "💾 Update Draft":
       return await save_draft_updates(update, context)

    elif section == "🔙 Back":
        # Redirect back to the updated draft summary
        return await show_updated_draft_summary(update, context)

    elif section == "✅ Confirm":
        return await handle_draft_confirm(update, context)

    else:
        await update.message.reply_text("⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button.")
        return EDIT_DRAFT_SECTION


async def handle_draft_title(update: Update, context: CallbackContext):
    """Handle editing of the draft title."""
    new_title = update.message.text.strip()

    # Validate the new title
    if len(new_title) < 3 or len(new_title) > 50:
        await update.message.reply_text(
            "❌ Title must be between 3 and 50 characters. Please try again."
        )
        return EDIT_DRAFT_TITLE

    # Update context with the new title
    context.user_data["edited_draft_job_title"] = new_title

    # Debugging: Log the updated title
    logger.debug(f"Updated draft title to: {new_title}")

    # Ensure the original saved title is preserved if needed
    if "draft_job_title" not in context.user_data:
        context.user_data["draft_job_title"] = new_title

    # Show the updated draft summary
    await show_updated_draft_summary(update, context)
    return EDIT_DRAFT_SECTION



async def handle_draft_description(update: Update, context: CallbackContext):
    """Handle editing of the draft description."""
    new_description = update.message.text.strip()

    # Validate the new description
    if len(new_description) < 50:
        await update.message.reply_text(
            "❌ Description must be at least 50 characters. Please try again."
        )
        return EDIT_DRAFT_DESCRIPTION

    # Update context with the new description
    context.user_data["edited_draft_job_description"] = new_description

    # Debugging: Log the updated description
    logger.debug(f"Updated draft description to: {new_description}")

    # Ensure the original saved description is preserved if needed
    if "draft_job_description" not in context.user_data:
        context.user_data["draft_job_description"] = new_description

    # Show the updated draft summary
    await show_updated_draft_summary(update, context)
    return EDIT_DRAFT_SECTION




async def fetch_and_show_draft_job_sites(update: Update, context: CallbackContext):
    """Fetch and display job sites for the draft as keyboard buttons."""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()
        cursor.execute("SELECT job_site_name FROM job_sites WHERE is_active = TRUE")
        job_sites = cursor.fetchall()
        cursor.close()
        conn.close()

        # Save the valid job sites to context for validation
        valid_job_sites = [site[0] for site in job_sites]
        context.user_data["valid_draft_job_sites"] = valid_job_sites

        # Create keyboard buttons for job sites
        job_site_buttons = [[site] for site in valid_job_sites]  # Single column of buttons

        # Send the keyboard to the user
        await update.message.reply_text(
            "Select the Job Site for your draft:",
            reply_markup=ReplyKeyboardMarkup(job_site_buttons, resize_keyboard=True, one_time_keyboard=True),
        )
        return EDIT_DRAFT_SITE

    except (Exception, psycopg2.DatabaseError) as error:
        await update.message.reply_text("An error occurred while fetching job sites. Please try again later.")
        logger.error(f"Database error: {error}")
        return EDIT_DRAFT_SECTION

async def handle_draft_site_selection(update: Update, context: CallbackContext):
    """Handle editing of the draft job site."""
    new_site = update.message.text.strip()

    # Retrieve valid job sites from context
    valid_job_sites = context.user_data.get("valid_draft_job_sites", [])

    # Validate the new job site
    if not valid_job_sites or new_site not in valid_job_sites:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose a valid Job Site from the options provided."
        )
        return EDIT_DRAFT_SITE

    # Update context with the new job site
    context.user_data["edited_draft_job_site"] = new_site

    # Ensure the original saved site is preserved if needed
    if "draft_job_site" not in context.user_data:
        context.user_data["draft_job_site"] = new_site

    # Debugging: Log the updated job site
    logger.debug(f"Updated draft job site to: {new_site}")

    # Show the updated draft summary
    await show_updated_draft_summary(update, context)
    return EDIT_DRAFT_SECTION




async def fetch_and_show_draft_job_types(update: Update, context: CallbackContext):
    """Fetch and display job types for the draft as keyboard buttons."""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()
        cursor.execute("SELECT job_type_name FROM job_types WHERE is_active = TRUE")
        job_types = cursor.fetchall()
        cursor.close()
        conn.close()

        # Save the valid job types to context for validation
        valid_job_types = [job_type[0] for job_type in job_types]
        context.user_data["valid_draft_job_types"] = valid_job_types

        # Create keyboard buttons for job types
        job_type_buttons = [[job_type] for job_type in valid_job_types]  # Single column of buttons

        # Send the keyboard to the user
        await update.message.reply_text(
            "Select the Job Type for your draft:",
            reply_markup=ReplyKeyboardMarkup(job_type_buttons, resize_keyboard=True, one_time_keyboard=True),
        )
        return EDIT_DRAFT_TYPE

    except (Exception, psycopg2.DatabaseError) as error:
        await update.message.reply_text("An error occurred while fetching job types. Please try again later.")
        print(f"Database error: {error}")
        return EDIT_DRAFT_SECTION


async def handle_draft_type_selection(update: Update, context: CallbackContext):
    """Handle editing of the draft job type."""
    new_type = update.message.text.strip()

    # Retrieve valid job types from context
    valid_job_types = context.user_data.get("valid_draft_job_types", [])

    # Validate the new job type
    if not valid_job_types or new_type not in valid_job_types:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose a valid Job Type from the options provided."
        )
        return EDIT_DRAFT_TYPE

    # Update context with the new job type
    context.user_data["edited_draft_job_type"] = new_type

    # Ensure the original saved type is preserved if needed
    if "draft_job_type" not in context.user_data:
        context.user_data["draft_job_type"] = new_type

    # Debugging: Log the updated job type
    logger.debug(f"Updated draft job type to: {new_type}")

    # Show the updated draft summary
    await show_updated_draft_summary(update, context)
    return EDIT_DRAFT_SECTION



async def fetch_and_show_draft_job_sectors(update: Update, context: CallbackContext):
    """Fetch and display job sectors for the draft as keyboard buttons."""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()
        cursor.execute("SELECT category_name FROM job_categories WHERE is_active = TRUE ORDER BY category_name ASC;")
        job_sectors = cursor.fetchall()
        cursor.close()
        conn.close()

        # Save the valid job sectors to context for validation
        valid_job_sectors = [sector[0] for sector in job_sectors]
        context.user_data["valid_draft_job_sectors"] = valid_job_sectors

        # Create keyboard buttons for job sectors
        job_sector_buttons = [[sector] for sector in valid_job_sectors]  # Single column of buttons

        # Send the keyboard to the user
        await update.message.reply_text(
            "Select the Job Sector for your draft:",
            reply_markup=ReplyKeyboardMarkup(job_sector_buttons, resize_keyboard=True, one_time_keyboard=True),
        )
        return EDIT_DRAFT_SECTOR

    except (Exception, psycopg2.DatabaseError) as error:
        await update.message.reply_text("An error occurred while fetching job sectors. Please try again later.")
        print(f"Database error: {error}")
        return EDIT_DRAFT_SECTION


async def handle_draft_sector_selection(update: Update, context: CallbackContext):
    """Handle editing of the draft job sector."""
    new_sector = update.message.text.strip()

    # Retrieve valid job sectors from context
    valid_job_sectors = context.user_data.get("valid_draft_job_sectors", [])

    # Validate the new job sector
    if not valid_job_sectors or new_sector not in valid_job_sectors:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose a valid Job Sector from the options provided."
        )
        return EDIT_DRAFT_SECTOR

    # Update context with the new job sector
    context.user_data["edited_draft_job_sector"] = new_sector

    # Ensure the original saved sector is preserved if needed
    if "draft_job_sector" not in context.user_data:
        context.user_data["draft_job_sector"] = new_sector

    # Debugging: Log the updated job sector
    logger.debug(f"Updated draft job sector to: {new_sector}")

    # Show the updated draft summary
    await show_updated_draft_summary(update, context)
    return EDIT_DRAFT_SECTION



async def fetch_and_show_draft_education_levels(update: Update, context: CallbackContext):
    """Fetch and display education levels for the draft as keyboard buttons."""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()
        cursor.execute("SELECT education_level_name FROM education_levels WHERE is_active = TRUE ORDER BY education_level_name ASC;")
        education_levels = cursor.fetchall()
        cursor.close()
        conn.close()

        # Save valid education levels to context for validation
        valid_education_levels = [level[0] for level in education_levels]
        context.user_data["valid_draft_education_levels"] = valid_education_levels

        # Create keyboard buttons for education levels
        education_buttons = [[level] for level in valid_education_levels]  # Single column of buttons

        # Send the keyboard to the user
        await update.message.reply_text(
            "Select the minimum Education Qualification for your draft:",
            reply_markup=ReplyKeyboardMarkup(education_buttons, resize_keyboard=True, one_time_keyboard=True),
        )
        return EDIT_DRAFT_EDUCATION

    except (Exception, psycopg2.DatabaseError) as error:
        await update.message.reply_text("An error occurred while fetching education levels. Please try again later.")
        print(f"Database error: {error}")
        return EDIT_DRAFT_SECTION


async def handle_draft_education_selection(update: Update, context: CallbackContext):
    """Handle editing of the draft education qualification."""
    new_education = update.message.text.strip()

    # Retrieve valid education levels from context
    valid_education_levels = context.user_data.get("valid_draft_education_levels", [])

    # Validate the new education level
    if not valid_education_levels or new_education not in valid_education_levels:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose a valid Education Qualification from the options provided."
        )
        return EDIT_DRAFT_EDUCATION

    # Update context with the new education qualification
    context.user_data["edited_draft_education_level"] = new_education

    # Debugging: Log the updated education level
    logger.debug(f"Updated draft education qualification to: {new_education}")

    # Ensure the original saved education level is preserved if needed
    if "draft_education_level" not in context.user_data:
        context.user_data["draft_education_level"] = new_education

    # Show the updated draft summary
    await show_updated_draft_summary(update, context)
    return EDIT_DRAFT_SECTION



async def fetch_and_show_draft_experience_levels(update: Update, context: CallbackContext):
    """Fetch and display experience levels for the draft as keyboard buttons."""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()
        cursor.execute("SELECT experience_level_name FROM experience_levels WHERE is_active = TRUE ORDER BY experience_level_name ASC;")
        experience_levels = cursor.fetchall()
        cursor.close()
        conn.close()

        # Save valid experience levels to context for validation
        valid_experience_levels = [level[0] for level in experience_levels]
        context.user_data["valid_draft_experience_levels"] = valid_experience_levels

        # Create keyboard buttons for experience levels
        experience_buttons = [[level] for level in valid_experience_levels]  # Single column of buttons

        # Send the keyboard to the user
        await update.message.reply_text(
            "Select the required Experience Level for your draft:",
            reply_markup=ReplyKeyboardMarkup(experience_buttons, resize_keyboard=True, one_time_keyboard=True),
        )
        return EDIT_DRAFT_EXPERIENCE

    except (Exception, psycopg2.DatabaseError) as error:
        await update.message.reply_text("An error occurred while fetching experience levels. Please try again later.")
        print(f"Database error: {error}")
        return EDIT_DRAFT_SECTION

async def handle_draft_experience_selection(update: Update, context: CallbackContext):
    """Handle editing of the draft experience level."""
    new_experience = update.message.text.strip()

    # Retrieve valid experience levels from context
    valid_experience_levels = context.user_data.get("valid_draft_experience_levels", [])

    # Validate the new experience level
    if not valid_experience_levels or new_experience not in valid_experience_levels:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose a valid Experience Level from the options provided."
        )
        return EDIT_DRAFT_EXPERIENCE

    # Update context with the new experience level
    context.user_data["edited_draft_experience_level"] = new_experience

    # Debugging: Log the updated experience level
    logger.debug(f"Updated draft experience level to: {new_experience}")

    # Ensure the original saved experience level is preserved if needed
    if "draft_experience_level" not in context.user_data:
        context.user_data["draft_experience_level"] = new_experience

    # Show the updated draft summary
    await show_updated_draft_summary(update, context)
    return EDIT_DRAFT_SECTION



async def fetch_and_show_draft_countries(update: Update, context: CallbackContext):
    """Fetch and display countries for the draft as keyboard buttons."""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()
        cursor.execute(
            "SELECT country_name FROM countries WHERE is_active = TRUE ORDER BY country_name ASC;"
        )
        countries = cursor.fetchall()
        cursor.close()
        conn.close()

        # Save valid countries to context for validation
        valid_countries = [country[0] for country in countries]
        context.user_data["valid_draft_countries"] = valid_countries

        # Create keyboard buttons for countries
        country_buttons = [[country] for country in valid_countries]  # Single column of buttons

        # Send the keyboard to the user
        await update.message.reply_text(
            "Select the Country for your draft:",
            reply_markup=ReplyKeyboardMarkup(
                country_buttons, resize_keyboard=True, one_time_keyboard=True
            ),
        )
        return EDIT_DRAFT_COUNTRY

    except (Exception, psycopg2.DatabaseError) as error:
        await update.message.reply_text(
            "An error occurred while fetching countries. Please try again later."
        )
        print(f"Database error: {error}")
        return EDIT_DRAFT_SECTION


async def handle_draft_country_selection(update: Update, context: CallbackContext):
    """Handle editing of the draft country selection."""
    new_country = update.message.text.strip()

    # Retrieve valid countries from context
    valid_countries = context.user_data.get("valid_draft_countries", [])

    # Validate the new country
    if not valid_countries or new_country not in valid_countries:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose a valid Country from the options provided."
        )
        return EDIT_DRAFT_COUNTRY

    # Update context with the new country
    context.user_data["edited_draft_location_country"] = new_country

    # Debugging: Log the updated country
    logger.debug(f"Updated draft location country to: {new_country}")

    # Ensure the original saved country is preserved if needed
    if "draft_location_country" not in context.user_data:
        context.user_data["draft_location_country"] = new_country

    # Show the updated draft summary
    await show_updated_draft_summary(update, context)
    return EDIT_DRAFT_SECTION




async def fetch_and_show_draft_cities(update: Update, context: CallbackContext):
    """Fetch and display cities for the draft as keyboard buttons."""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()

        # Fetch all cities from the `locations` table
        cursor.execute(
            "SELECT city_name FROM locations ORDER BY city_name ASC;"
        )
        cities = cursor.fetchall()
        cursor.close()
        conn.close()

        # Save valid cities to context for validation
        valid_cities = [city[0] for city in cities]
        context.user_data["valid_draft_cities"] = valid_cities

        # Create keyboard buttons for cities
        city_buttons = [[city] for city in valid_cities]  # Single column of buttons

        # Send the keyboard to the user
        await update.message.reply_text(
            "Select the City for your draft:",
            reply_markup=ReplyKeyboardMarkup(
                city_buttons, resize_keyboard=True, one_time_keyboard=True
            ),
        )
        return EDIT_DRAFT_CITY

    except (Exception, psycopg2.DatabaseError) as error:
        await update.message.reply_text(
            "An error occurred while fetching cities. Please try again later."
        )
        logger.error(f"Database error: {error}")
        return EDIT_DRAFT_SECTION

async def handle_draft_city_selection(update: Update, context: CallbackContext):
    """Handle editing of the draft city selection."""
    new_city = update.message.text.strip()

    # Retrieve valid cities from context
    valid_cities = context.user_data.get("valid_draft_cities", [])

    # Validate the new city
    if not valid_cities or new_city not in valid_cities:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose a valid City from the options provided."
        )
        return EDIT_DRAFT_CITY

    # Update context with the new city
    context.user_data["edited_draft_location_city"] = new_city

    # Debugging: Log the updated city
    logger.debug(f"Updated draft location city to: {new_city}")

    # Ensure the original saved city is preserved if needed
    if "draft_location_city" not in context.user_data:
        context.user_data["draft_location_city"] = new_city

    # Show the updated draft summary
    await show_updated_draft_summary(update, context)
    return EDIT_DRAFT_SECTION


async def fetch_and_show_draft_compensation_types(update: Update, context: CallbackContext):
    """Fetch and display compensation types for the draft as keyboard buttons."""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()
        cursor.execute(
            "SELECT compensation_type_name FROM compensation_types WHERE is_active = TRUE ORDER BY compensation_type_name ASC;"
        )
        compensation_types = cursor.fetchall()
        cursor.close()
        conn.close()

        # Save valid compensation types to context for validation
        valid_compensation_types = [comp_type[0] for comp_type in compensation_types]
        context.user_data["valid_draft_compensation_types"] = valid_compensation_types

        # Create keyboard buttons for compensation types
        compensation_buttons = [[comp_type] for comp_type in valid_compensation_types]  # Single column of buttons

        # Send the keyboard to the user
        await update.message.reply_text(
            "Select the Compensation Type for your draft:",
            reply_markup=ReplyKeyboardMarkup(
                compensation_buttons, resize_keyboard=True, one_time_keyboard=True
            ),
        )
        return EDIT_DRAFT_COMPENSATION_TYPE

    except (Exception, psycopg2.DatabaseError) as error:
        await update.message.reply_text(
            "An error occurred while fetching compensation types. Please try again later."
        )
        print(f"Database error: {error}")
        return EDIT_DRAFT_SECTION


async def handle_draft_compensation_type_selection(update: Update, context: CallbackContext):
    """Handle editing of the draft compensation type."""
    new_compensation_type = update.message.text.strip()

    # Retrieve valid compensation types from context
    valid_compensation_types = context.user_data.get("valid_draft_compensation_types", [])

    # Validate the new compensation type
    if not valid_compensation_types or new_compensation_type not in valid_compensation_types:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose a valid Compensation Type from the options provided."
        )
        return EDIT_DRAFT_COMPENSATION_TYPE  # Keep the user in the current state

    # Update context with the new compensation type
    context.user_data["edited_draft_compensation_type"] = new_compensation_type

    # Debugging: Log the updated compensation type
    logger.debug(f"Updated draft compensation type to: {new_compensation_type}")

    # Ensure the original saved compensation type is preserved if needed
    if "draft_compensation_type" not in context.user_data:
        context.user_data["draft_compensation_type"] = new_compensation_type

    # Show the updated draft summary
    await show_updated_draft_summary(update, context)
    return EDIT_DRAFT_SECTION




async def handle_draft_salary_compensation(update: Update, context: CallbackContext):
    """Handle salary/compensation input for the draft with validation."""
    new_salary = update.message.text.strip()

    # Predefined section buttons to avoid registering as input
    invalid_inputs = [
        "🏷️ Edit Job Title", "📄 Edit Job Description", "🏭 Edit Job Site", "🕒 Edit Job Type",
        "🏢 Edit Job Sector", "🎓 Edit Education Qualification", "🎖️ Edit Experience Level",
        "🌐 Edit Location (Country)", "📍 Edit Location (City)", "💰 Edit Compensation Type",
        "💲 Edit Salary", "💱 Edit Currency Type", "👥 Edit Vacancy Number",
        "🚻 Edit Applicant Gender", "⏳ Edit Application Deadline", "💾 Save Draft", "🔙 Back", "✅ Confirm"
    ]

    # Check if the input matches predefined section buttons
    if new_salary in invalid_inputs:
        await update.message.reply_text(
            "❌ Please enter the salary amount instead of selecting a section button."
        )
        return EDIT_DRAFT_SALARY

    # Validate salary amount (must be a numeric value within a range)
    if new_salary.isdigit() and 10 <= int(new_salary) <= 9999999:
        # Update context with the new salary amount
        context.user_data["edited_draft_salary_compensation"] = new_salary

        # Ensure the original saved salary is preserved if needed
        if "draft_salary_compensation" not in context.user_data:
            context.user_data["draft_salary_compensation"] = new_salary

        # Debugging: Log the updated salary amount
        logger.debug(f"Updated draft salary compensation to: {new_salary}")

        # Show the updated draft summary dynamically
        await show_updated_draft_summary(update, context)
        return EDIT_DRAFT_SECTION
    else:
        await update.message.reply_text(
            "❌ Invalid input. Please enter a numeric salary amount between 10 and 9,999,999."
        )
        return EDIT_DRAFT_SALARY




async def fetch_and_show_draft_currency_types(update: Update, context: CallbackContext):
    """Fetch and display currency types dynamically from the database for draft editing."""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()

        # Fetch active currency types
        cursor.execute("SELECT currency_code FROM currency_types WHERE is_active = TRUE ORDER BY currency_code ASC;")
        currencies = [row[0] for row in cursor.fetchall()]
        cursor.close()
        conn.close()

        if not currencies:
            await update.message.reply_text("No active currencies are available.")
            return EDIT_DRAFT_SECTION

        # Save valid currencies to context for validation
        context.user_data["valid_draft_currency_types"] = currencies

        # Create buttons for currency types
        currency_buttons = [[currency] for currency in currencies]

        # Display currency options
        await update.message.reply_text(
            "Please select the currency type for the draft:",
            reply_markup=ReplyKeyboardMarkup(currency_buttons, resize_keyboard=True, one_time_keyboard=True),
        )
        return EDIT_DRAFT_CURRENCY

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error while fetching currencies: {error}")
        await update.message.reply_text("An error occurred while fetching currency types. Please try again later.")
        return EDIT_DRAFT_SECTION


async def handle_draft_currency_selection(update: Update, context: CallbackContext):
    """Handle editing of the draft currency type."""
    new_currency = update.message.text.strip()

    # Retrieve valid currency types from context
    valid_currencies = context.user_data.get("valid_draft_currency_types", [])
    if not valid_currencies or new_currency not in valid_currencies:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose a valid currency type from the options provided."
        )
        return EDIT_DRAFT_CURRENCY

    # Update context with the newly selected currency type
    context.user_data["edited_draft_currency_type"] = new_currency

    # Ensure the original saved currency type is preserved if needed
    if "draft_currency_type" not in context.user_data:
        context.user_data["draft_currency_type"] = new_currency

    # Debugging: Log the updated currency type
    logger.debug(f"Updated draft currency type to: {new_currency}")

    # Show the updated draft summary
    await show_updated_draft_summary(update, context)

    # Return to the draft section selection menu
    return EDIT_DRAFT_SECTION



async def handle_draft_vacancy_number(update: Update, context: CallbackContext):
    """Handle editing of the draft vacancy number."""
    new_vacancy_number = update.message.text.strip()

    # Predefined section buttons to avoid registering as input
    invalid_inputs = [
        "🏷️ Edit Job Title", "📄 Edit Job Description", "🏭 Edit Job Site", "🕒 Edit Job Type",
        "🏢 Edit Job Sector", "🎓 Edit Education Qualification", "🎖️ Edit Experience Level",
        "🌐 Edit Location (Country)", "📍 Edit Location (City)", "💰 Edit Compensation Type",
        "💲 Edit Salary", "💱 Edit Currency Type", "👥 Edit Vacancy Number",
        "🚻 Edit Applicant Gender", "⏳ Edit Application Deadline", "💾 Save Draft", "🔙 Back", "✅ Confirm"
    ]

    # Check if the input matches predefined section buttons
    if new_vacancy_number in invalid_inputs:
        await update.message.reply_text(
            "❌ Please enter the number of vacancies instead of selecting a section button."
        )
        return EDIT_DRAFT_VACANCY_NUMBER

    # Validate vacancy number (must be an integer between 1 and 100)
    if new_vacancy_number.isdigit() and 1 <= int(new_vacancy_number) <= 100:
        # Update context with the new vacancy number
        context.user_data["edited_draft_vacancy_number"] = int(new_vacancy_number)

        # Ensure the original saved vacancy number is preserved if needed
        if "draft_vacancy_number" not in context.user_data:
            context.user_data["draft_vacancy_number"] = int(new_vacancy_number)

        # Debugging: Log the updated vacancy number
        logger.debug(f"Updated draft vacancy number to: {new_vacancy_number}")

        # Show the updated draft summary dynamically
        await show_updated_draft_summary(update, context)
        return EDIT_DRAFT_SECTION
    else:
        await update.message.reply_text(
            "❌ Invalid input. Please enter a numeric vacancy number between 1 and 100."
        )
        return EDIT_DRAFT_VACANCY



async def handle_draft_gender(update: Update, context: CallbackContext):
    """Handle editing of the draft applicant gender."""
    new_gender = update.message.text.strip()

    # Define valid gender options
    valid_genders = ["Male", "Female", "Both"]

    # Validate the input
    if new_gender in valid_genders:
        # Update context with the new gender
        context.user_data["edited_draft_applicant_gender"] = new_gender

        # Ensure the original saved gender is preserved if needed
        if "draft_applicant_gender" not in context.user_data:
            context.user_data["draft_applicant_gender"] = new_gender

        # Debugging: Log the updated gender
        logger.debug(f"Updated draft applicant gender to: {new_gender}")

        # Update the draft summary dynamically
        await show_updated_draft_summary(update, context)

        # Return to the draft section selection menu
        return EDIT_DRAFT_SECTION
    else:
        # Invalid selection, prompt the user to try again
        await update.message.reply_text(
            "❌ Invalid selection. Please choose one of the following options:",
            reply_markup=ReplyKeyboardMarkup(
                [["Male", "Female", "Both"]], resize_keyboard=True, one_time_keyboard=True
            ),
        )
        return EDIT_DRAFT_GENDER


from datetime import datetime, timedelta

async def handle_draft_deadline(update: Update, context: CallbackContext):
    """Handle editing of the draft application deadline."""
    new_deadline = update.message.text.strip()

    # Allow skipping
    if new_deadline.lower() == "skip":
        # Set a default deadline 10 days from now
        default_deadline = (datetime.now() + timedelta(days=10)).strftime("%Y-%m-%d")
        context.user_data["edited_draft_application_deadline"] = default_deadline

        # Ensure the original saved value is consistent
        if "draft_application_deadline" not in context.user_data:
            context.user_data["draft_application_deadline"] = default_deadline

        # Debugging: Log the skipped deadline
        logger.debug(f"Default deadline set to: {default_deadline}")

        # Show the updated draft summary
        await show_updated_draft_summary(update, context)
        return EDIT_DRAFT_SECTION

    # Validate date format (dd/mm/yyyy or yyyy-mm-dd)
    try:
        # Attempt parsing in dd/mm/yyyy format
        try:
            validated_date = datetime.strptime(new_deadline, "%d/%m/%Y").date()
        except ValueError:
            # If parsing as dd/mm/yyyy fails, try yyyy-mm-dd
            validated_date = datetime.strptime(new_deadline, "%Y-%m-%d").date()

        # Format the validated date to yyyy-mm-dd
        formatted_date = validated_date.strftime("%Y-%m-%d")

        # Save the validated deadline as the edited value
        context.user_data["edited_draft_application_deadline"] = formatted_date

        # Ensure the original saved value is consistent
        if "draft_application_deadline" not in context.user_data:
            context.user_data["draft_application_deadline"] = formatted_date

        # Debugging: Log the updated deadline
        logger.debug(f"Updated draft application deadline to: {formatted_date}")

        # Show the updated draft summary
        await show_updated_draft_summary(update, context)
        return EDIT_DRAFT_SECTION

    except ValueError:
        # Invalid date format
        await update.message.reply_text(
            "❌ Invalid date format. Please use the format dd/mm/yyyy or yyyy-mm-dd, or type 'skip' to set a default deadline."
        )
        return EDIT_DRAFT_DEADLINE





async def show_updated_draft_summary(update: Update, context: CallbackContext):
    """Display the updated draft summary, prioritizing edited fields."""
    # Dynamically create the combined job type and site field
    job_type = context.user_data.get("edited_draft_job_type") or context.user_data.get("draft_job_type") or ""
    job_site = context.user_data.get("edited_draft_job_site") or context.user_data.get("draft_job_site") or ""
    combined_job_type = f"{job_site}, {job_type}".strip(", ")

    # Add the combined job type to context for consistency
    context.user_data["combined_job_type"] = combined_job_type if combined_job_type else "Not provided"

    # Dynamically create the combined work location field
    location_city = context.user_data.get("edited_draft_location_city") or context.user_data.get("draft_location_city") or ""
    location_country = context.user_data.get("edited_draft_location_country") or context.user_data.get("draft_location_country") or ""
    work_location = f"{location_city}, {location_country}".strip(", ")

    # Add the combined work location to context for consistency
    context.user_data["work_location"] = work_location if work_location else "Not provided"

    # Dynamically create the combined salary/compensation field
    salary_compensation = context.user_data.get("edited_draft_salary_compensation") or context.user_data.get(
        "draft_salary_compensation") or ""
    currency_type = context.user_data.get("edited_draft_currency_type") or context.user_data.get(
        "draft_currency_type") or ""
    compensation_type = context.user_data.get("edited_draft_compensation_type") or context.user_data.get(
        "draft_compensation_type") or ""

    # Ensure all parts are strings and remove ".0" for floats
    salary_parts = []
    if salary_compensation:
        if isinstance(salary_compensation, (int, float)):
            salary_parts.append(f"{int(salary_compensation)}")  # Convert to int if float
        else:
            salary_parts.append(str(salary_compensation))  # Ensure it's a string
    if currency_type:
        salary_parts.append(currency_type)
    if compensation_type:
        salary_parts.append(f"({compensation_type})")
    salary_summary = " ".join(salary_parts).strip()

    # Add the combined salary/compensation to context for consistency
    context.user_data["salary_summary"] = salary_summary if salary_summary else "Not provided"

    # Dynamically update the applicant gender field with icons
    gender = context.user_data.get("edited_draft_applicant_gender") or context.user_data.get(
        "draft_applicant_gender") or ""
    gender_icons = {"Male": "♂️", "Female": "♀️", "Both": "🚻"}
    gender_icon = gender_icons.get(gender, "🚻")

    # Add the dynamic gender label to context for consistency
    context.user_data["applicant_gender"] = f"{gender}" if gender else "Not provided"

    applicant_gender_label = f"{gender_icon} *Applicant Gender:*"

    # Handle and format the application deadline
    raw_deadline = context.user_data.get("edited_draft_application_deadline") or context.user_data.get(
        "draft_application_deadline")

    if raw_deadline:
        try:
            # Check if raw_deadline is already a date object
            if isinstance(raw_deadline, date):
                deadline_date = raw_deadline
            elif isinstance(raw_deadline, str):
                # Parse the string date
                deadline_date = datetime.strptime(raw_deadline, "%Y-%m-%d").date()
            else:
                raise ValueError("Invalid date format")

            # Add an ordinal suffix to the day
            day_suffix = "th" if 11 <= deadline_date.day <= 13 else {1: "st", 2: "nd", 3: "rd"}.get(
                deadline_date.day % 10, "th")
            application_deadline = deadline_date.strftime(f"%B {deadline_date.day}{day_suffix}, %Y")

        except (ValueError, TypeError):
            # Handle invalid dates gracefully
            application_deadline = "Invalid date format"
    else:
        # If no deadline is provided
        application_deadline = "Not provided"

    # Add the formatted application deadline to context for consistency
    context.user_data["application_deadline"] = application_deadline

    # Define all fields to be displayed in the new order
    summary_fields = [
        ("job_title", "🏷️ *Job Title:*"),
        ("combined_job_type", "🕒 *Job Type:*"),  # Combined job type and site
        ("job_sector", "🏢 *Job Sector:*"),
        ("work_location", "📍 *Work Location:*"),  # Combined city and country
        ("education_level", "🎓 *Education Qualification:*"),
        ("experience_level", "🎖️ *Experience Level:*"),
        ("salary_summary", "💰 *Salary/Compensation:*"),  # Combined salary/compensation
        ("vacancy_number", "👥 *Vacancy Number:*"),
        ("applicant_gender", applicant_gender_label),  # Dynamic gender label
        ("application_deadline", "⏳ *Application Deadline:*"),
        ("job_description", "📄 *Job Description:*"),
    ]

    summary_lines = []
    for field, label in summary_fields:
        if field in ["combined_job_type", "work_location", "salary_summary", "applicant_gender",
                     "application_deadline"]:
            # Use dynamically constructed combined fields
            value = context.user_data.get(field, "Not provided")
        else:
            # Check for the edited value first, fallback to saved value
            edited_value = context.user_data.get(f"edited_draft_{field}")
            saved_value = context.user_data.get(f"draft_{field}")
            value = edited_value or saved_value or "Not provided"

        # Add the field to the summary
        summary_lines.append(f"{label} {value}")
    # Combine all summary lines into the final summary text
    summary = "\n\n".join(summary_lines)

    # Debugging: Log the final summary
    logger.debug("Generated Draft Summary:")
    logger.debug(summary)

    # Send the updated draft summary to the user
    await update.message.reply_text(
        f"Here is your updated draft summary:\n\n{summary}",
        parse_mode="Markdown",
        reply_markup=ReplyKeyboardMarkup(
            [
                ["🏷️ Job Title", "📄 Job Description"],
                ["🏭 Job Site", "🕒 Job Type"],
                ["🏢 Job Sector", "🎓 Education Qualification"],
                ["🎖️ Experience Level", "🌐 Location (Country)"],
                ["📍 Location (City)", "💰 Compensation Type"],
                ["💲 Salary", "💱 Currency Type"],
                ["👥 Vacancy Number", "🚻 Applicant Gender"],
                ["⏳ Application Deadline", "💾 Update Draft"],
                ["🔙 Back", "✅ Confirm"],
            ],
            resize_keyboard=True,
        ),
    )





async def save_draft_updates(update: Update, context: CallbackContext):
    """Save the updated draft to the database."""
    job_id = context.user_data.get("draft_job_id")
    if not job_id:
        await update.message.reply_text("❌ No draft selected for saving. Please try again.")
        return

    # Define the fields that can be updated in the database
    fields = {
        "job_title": context.user_data.get("edited_draft_job_title"),
        "job_description": context.user_data.get("edited_draft_job_description"),
        "job_site": context.user_data.get("edited_draft_job_site"),
        "job_type": context.user_data.get("edited_draft_job_type"),
        "job_sector": context.user_data.get("edited_draft_job_sector"),
        "education_qualification": context.user_data.get("edited_draft_education_level"),
        "experience_level": context.user_data.get("edited_draft_experience_level"),
        "location_country": context.user_data.get("edited_draft_location_country"),
        "location_city": context.user_data.get("edited_draft_location_city"),
        "compensation_type": context.user_data.get("edited_draft_compensation_type"),
        "salary_compensation": context.user_data.get("edited_draft_salary_compensation"),
        "currency_type": context.user_data.get("edited_draft_currency_type"),
        "vacancy_number": context.user_data.get("edited_draft_vacancy_number"),
        "applicant_gender": context.user_data.get("edited_draft_applicant_gender"),
        "job_application_deadline": context.user_data.get("edited_draft_application_deadline"),
    }

    # Filter out None values to only update fields that were edited
    updated_data = {key: value for key, value in fields.items() if value is not None}

    if not updated_data:
        await update.message.reply_text("❌ No changes were made to the draft.")
        return EDIT_DRAFT_SECTION

    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()

        # Generate the SQL UPDATE query dynamically
        set_clause = ", ".join([f'"{key}" = %s' for key in updated_data.keys()])
        values = list(updated_data.values()) + [job_id]
        query = f'UPDATE job_posts SET {set_clause} WHERE "job_id" = %s'

        # Execute the query and commit the transaction
        cursor.execute(query, values)
        conn.commit()

        # Notify the user that the changes were saved
        await update.message.reply_text("✅ Draft changes saved successfully and updated the job post!")

        return

    except Exception as e:
        logger.error(f"Database error while saving draft: {e}")
        await update.message.reply_text("❌ An error occurred while saving your changes. Please try again.")
        return EDIT_DRAFT_SECTION

    finally:
        if conn:
            cursor.close()
            conn.close()


import psycopg2
from datetime import datetime, date
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import ConversationHandler
import logging

logger = logging.getLogger(__name__)

async def handle_draft_confirm(update, context):
    """Handle the confirmation of a drafted job post."""
    chat_id = update.message.chat_id  # This is the contact, not user_id

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve the correct user_id based on the contact (chat_id)
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            logger.error(f"No user found with contact {chat_id}. User must be registered.")
            await update.message.reply_text("❌ You are not registered. Please register before posting a job.")
            return

        user_id = user_row[0]

        # Check if a draft exists
        draft_job_id = context.user_data.get("draft_job_id")
        if not draft_job_id:
            await update.message.reply_text("❌ No draft found to confirm. Please try again.")
            return DRAFT_MENU

        # Check the job post limit and package details
        cursor.execute('''
                    SELECT job_post_limit, package_name, package_expiration 
                    FROM package_usage 
                    WHERE user_id = %s AND package_expiration > NOW()
                ''', (user_id,))
        package_row = cursor.fetchone()

        job_post_limit = "Not Available"
        package_name = "Unknown"

        if package_row:
            job_post_limit, package_name, package_expiration = package_row
            if job_post_limit <= 0:
                await update.message.reply_text(
                    f"⚠️ You have reached the job post limit for your package '{package_name}'. "
                    "Your job post will still be sent to the admin for approval. Please consider upgrading your package."
                )
        else:
            await update.message.reply_text(
                "⚠️ You don't have an active package or your package has expired. "
                "Your job post will still be sent to the admin for approval. Please consider purchasing a package."
            )

        # Deduct job post limit if applicable
        if package_row and job_post_limit > 0:
            cursor.execute('''
                        UPDATE package_usage
                        SET job_post_limit = job_post_limit - 1
                        WHERE user_id = %s AND package_expiration > NOW()
                    ''', (user_id,))
            conn.commit()



        # Validate and format the application deadline
        deadline = (
            context.user_data.get("edited_draft_application_deadline")
            or context.user_data.get("draft_application_deadline")
        )
        try:
            if deadline:
                if isinstance(deadline, str):
                    try:
                        # Attempt parsing in dd/mm/yyyy format
                        deadline_date = datetime.strptime(deadline, "%d/%m/%Y").date()
                    except ValueError:
                        # Fall back to yyyy-mm-dd format
                        deadline_date = datetime.strptime(deadline, "%Y-%m-%d").date()

                    # Format the deadline for display
                    day_suffix = "th" if 11 <= deadline_date.day <= 13 else {1: "st", 2: "nd", 3: "rd"}.get(
                        deadline_date.day % 10, "th"
                    )
                    formatted_deadline_display = deadline_date.strftime(f"%B {deadline_date.day}{day_suffix}, %Y")
                    # Format the deadline for database storage
                    formatted_deadline_db = deadline_date.strftime("%Y-%m-%d")
                    context.user_data["job_application_deadline"] = formatted_deadline_display
                else:
                    # If the deadline is already a date object
                    formatted_deadline_display = deadline.strftime("%B %d, %Y")
                    formatted_deadline_db = deadline.strftime("%Y-%m-%d")
                    context.user_data["job_application_deadline"] = formatted_deadline_display
            else:
                context.user_data["job_application_deadline"] = None
                formatted_deadline_db = None
        except ValueError as e:
            logger.error(f"Date conversion error: {e}")
            await update.message.reply_text("❌ Invalid date format. Please use dd/mm/yyyy or yyyy-mm-dd.")
            return DRAFT_MENU

        # Validate required fields
        required_fields = [
            "job_title", "job_description", "job_site", "job_type", "job_sector",
            "education_level", "experience_level", "location_country", "location_city",
            "compensation_type", "salary_compensation", "currency_type",
            "vacancy_number", "applicant_gender", "application_deadline"
        ]

        # Check for missing fields considering both edited and saved draft fields
        missing_fields = []
        for field in required_fields:
            edited_value = context.user_data.get(f"edited_draft_{field}")
            saved_value = context.user_data.get(f"draft_{field}")
            if not (edited_value or saved_value):
                missing_fields.append(field)

        if missing_fields:
            # Prepare a formatted list of missing fields for user notification
            missing_fields_str = "\n".join([f"• {field.replace('_', ' ').title()}" for field in missing_fields])
            await update.message.reply_text(
                f"⚠️ *Missing Required Fields:*\n\n"
                f"{missing_fields_str}\n\n"
                f"💡 Please complete these fields before confirming the draft.",
                parse_mode="Markdown"
            )
            return SELECT_SECTION

        # Update the draft in the database and set it to "Pending"
        fields = {
            "job_title": context.user_data.get("edited_draft_job_title") or context.user_data.get("draft_job_title"),
            "job_description": context.user_data.get("edited_draft_job_description") or context.user_data.get("draft_job_description"),
            "job_site": context.user_data.get("edited_draft_job_site") or context.user_data.get("draft_job_site"),
            "job_type": context.user_data.get("edited_draft_job_type") or context.user_data.get("draft_job_type"),
            "job_sector": context.user_data.get("edited_draft_job_sector") or context.user_data.get("draft_job_sector"),
            "education_qualification": context.user_data.get("edited_draft_education_level") or context.user_data.get("draft_education_level"),
            "experience_level": context.user_data.get("edited_draft_experience_level") or context.user_data.get("draft_experience_level"),
            "location_country": context.user_data.get("edited_draft_location_country") or context.user_data.get("draft_location_country"),
            "location_city": context.user_data.get("edited_draft_location_city") or context.user_data.get("draft_location_city"),
            "compensation_type": context.user_data.get("edited_draft_compensation_type") or context.user_data.get("draft_compensation_type"),
            "salary_compensation": int(float(context.user_data.get("edited_draft_salary_compensation") or context.user_data.get("draft_salary_compensation") or 0)),
            "currency_type": context.user_data.get("edited_draft_currency_type") or context.user_data.get("draft_currency_type"),
            "vacancy_number": context.user_data.get("edited_draft_vacancy_number") or context.user_data.get("draft_vacancy_number"),
            "applicant_gender": context.user_data.get("edited_draft_applicant_gender") or context.user_data.get("draft_applicant_gender"),
            "job_application_deadline": formatted_deadline_db,  # Use the database-friendly format
            "status_id": 1,  # Set to "Pending"
        }
        set_clause = ", ".join([f'"{key}" = %s' for key in fields.keys()])
        values = list(fields.values()) + [draft_job_id]

        cursor.execute(
            f'UPDATE job_posts SET {set_clause} WHERE "job_id" = %s',
            values
        )
        conn.commit()

        # Fetch company details and total reposts
        cursor.execute('''
                SELECT company_name, is_verified FROM company_profiles WHERE user_id = %s
            ''', (user_id,))
        company_row = cursor.fetchone()
        company_name = company_row[0] if company_row else "Private Client"
        is_verified = company_row[1] if company_row else False

        cursor.execute('SELECT COUNT(*) FROM job_posts WHERE user_id = %s', (user_id,))
        total_posts = cursor.fetchone()[0]

        cursor.execute('SELECT SUM(repost_count) FROM job_posts WHERE user_id = %s', (user_id,))
        total_reposts_all_jobs = cursor.fetchone()[0] or 0

        # Construct the company details section
        repost_section = f"♻️ *Total Reposts (All Jobs):* {total_reposts_all_jobs}\n\n" if total_reposts_all_jobs > 0 else ""
        package_section = (
            f"📦 *Current Package:* {package_name}\n\n"
            f"📝 *Job Posts Remaining:* {job_post_limit}\n\n"
        )
        company_section = (
            f"*{company_name}*\n"
            f"{'Verified Company ✅' if is_verified else 'Private Client'}\n\n"
            f"📁 *Total Jobs Posted:* {total_posts}\n\n"
            f"{repost_section}{package_section}"
        )

        # Construct job summary for admin
        combined_job_type = f"{fields['job_site']}, {fields['job_type']}".strip(", ")
        work_location = f"{fields['location_city']}, {fields['location_country']}".strip(", ")
        salary_summary = f"{fields['salary_compensation']} {fields['currency_type']} ({fields['compensation_type']})".strip()
        gender_icon = {"Male": "♂️", "Female": "♀️", "Both": "🚻"}.get(fields['applicant_gender'], "🚻")

        job_summary = (
            f"🏷️ *Job Title:* {fields['job_title']}\n\n"
            f"🕒 *Job Type:* {combined_job_type}\n\n"
            f"🏢 *Job Sector:* {fields['job_sector']}\n\n"
            f"📍 *Work Location:* {work_location}\n\n"
            f"🎓 *Education Qualification:* {fields['education_qualification']}\n\n"
            f"🎖️ *Experience Level:* {fields['experience_level']}\n\n"
            f"💰 *Salary/Compensation:* {salary_summary}\n\n"
            f"👥 *Vacancy Number:* {fields['vacancy_number']}\n\n"
            f"{gender_icon} *Applicant Gender:* {fields['applicant_gender']}\n\n"
            f"⏳ *Job Application Deadline:* {formatted_deadline_display}\n\n"
            f"📄 *Job Description:*\n{fields['job_description']}\n\n"
            f"{'_' * 30}\n\n{company_section}{'_' * 30}"
        )

        # Send job post to the admin
        admin_message = await context.bot.send_message(
            chat_id=ADMIN_ID,
            text=job_summary,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("Approve", callback_data=f"approve:{draft_job_id}")],
                [InlineKeyboardButton("Deny", callback_data=f"deny:{draft_job_id}")],
                [InlineKeyboardButton("Request Payment", callback_data=f"request_payment:{draft_job_id}")]
            ])
        )

        # Update admin message ID in the database
        cursor.execute("UPDATE job_posts SET message_id = %s WHERE job_id = %s", (admin_message.message_id, draft_job_id))
        conn.commit()

        # Notify the user
        await update.message.reply_text(
            "🎉 *Success!* Your drafted job post has been updated and forwarded to the admin for approval.\n\n"
            "📩 You will be notified once your job post is reviewed. Thank you for choosing our platform!",
            parse_mode="Markdown"
        )

        await update.message.reply_text(
            "Employer Menu: Please choose an action.",
            reply_markup=ReplyKeyboardMarkup([
                ["🗂️ Job Management", "📄 Applications"],
                ["🔍 Search & Filter", "🪪 Profile"],
                ["💳 Billing & Payments", "📢 Notifications"],
                ["⚙️ Performance", "📞 Support"]
            ], resize_keyboard=True)
        )
        return EMPLOYER_MENU

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error while confirming draft: {error}")
        await update.message.reply_text("❌ An error occurred while confirming the draft. Please try again.")
        return

    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()




# Function to cancel the edit process
async def cancel_edit(update: Update, context: CallbackContext) -> int:
    await update.callback_query.edit_message_text("🛑 Editing has been cancelled.")
    return




from telegram import InlineKeyboardButton, InlineKeyboardMarkup
import re
from datetime import date
import psycopg2
from telegram import Update
from telegram.ext import CallbackContext

# Function to escape special characters for MarkdownV2
def escape_markdown_v2(text):
    return re.sub(r'([_\*\[\]\(\)~`>#+\-=|{}.!])', r'\\\1', str(text))

# Function to format the deadline with a suffix (e.g., "20th")
def format_deadline_with_suffix(deadline_date):
    try:
        if isinstance(deadline_date, date):
            day_suffix = "th" if 11 <= deadline_date.day <= 13 else {1: "st", 2: "nd", 3: "rd"}.get(deadline_date.day % 10, "th")
            return deadline_date.strftime(f"%B {deadline_date.day}{day_suffix}, %Y")
        return deadline_date
    except Exception as e:
        logger.error(f"Error formatting deadline: {e}")
        return deadline_date

# Function to handle viewing closed jobs
async def closed_jobs(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id  # Telegram chat_id

    conn = None
    cursor = None

    try:
        # Step 1: Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 2: Map chat_id to user_id in the users table
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return JOB_MANAGEMENT

        user_id = user_row[0]

        # Step 3: Fetch the 'closed' status_id from the job_status table
        cursor.execute('SELECT status_id FROM job_status WHERE status_name = %s', ('closed',))
        closed_status_row = cursor.fetchone()

        if not closed_status_row:
            await update.message.reply_text("Could not find 'closed' status. Please contact support.")
            return JOB_MANAGEMENT

        closed_status_id = closed_status_row[0]

        # Step 4: Fetch jobs with 'closed' status for the user, ordered by creation date (oldest first)
        cursor.execute('''
            SELECT jp.job_id, jp.job_title, jp.job_description, jp.job_site, jp.job_type, 
                   jp.job_sector, jp.education_qualification, jp.experience_level, 
                   jp.location_country, jp.location_city, jp.compensation_type, 
                   jp.salary_compensation, jp.currency_type, jp.vacancy_number,
                   jp.applicant_gender, jp.job_application_deadline, jp.user_id, jp.created_at
            FROM job_posts jp
            WHERE jp.user_id = %s AND jp.status_id = %s
            ORDER BY jp.created_at ASC
        ''', (user_id, closed_status_id))

        closed_jobs = cursor.fetchall()

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error: {error}")
        await update.message.reply_text("An error occurred while retrieving closed jobs.")
        return JOB_MANAGEMENT

    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

    # Step 5: Display the closed job summaries to the user
    if closed_jobs:
        for job in closed_jobs:
            job_id, job_title, job_description, job_site, job_type, job_sector, education_qualification, \
            experience_level, location_country, location_city, compensation_type, salary_compensation, \
            currency_type, vacancy_number, applicant_gender, job_application_deadline, company_user_id, created_at = job

            # Format the application deadline
            if isinstance(job_application_deadline, date):
                job_application_deadline = format_deadline_with_suffix(job_application_deadline)

            # Gender icon logic
            gender_icon = "⚥" if applicant_gender not in ["Male", "Female"] else "♂️" if applicant_gender == "Male" else "♀️"

            # Format salary/compensation summary
            salary_compensation_summary = (
                f"{int(salary_compensation)} {currency_type} {compensation_type}"
                if salary_compensation else f"{currency_type} {compensation_type}"
            )

            # Fetch company profile details for the current job
            try:
                conn = psycopg2.connect(
                    dbname="my_project_db",
                    user="postgres",
                    password="1201",
                    host="localhost",
                    port="5432"
                )
                cursor = conn.cursor()

                cursor.execute('''
                    SELECT cp.company_name, cp.is_verified
                    FROM company_profiles cp
                    WHERE cp.user_id = %s
                ''', (company_user_id,))

                company_profile = cursor.fetchone()
                if company_profile and company_profile[1]:  # Verified company
                    company_name = company_profile[0]
                    verified_company_section = (
                        f"\n\n{'\\_' * 30}\n\n*{escape_markdown_v2(company_name)}*\n✅ Verified Company\n\u200B\n\n"
                    )
                else:  # Unverified or missing profile
                    company_name = "Private Client"
                    verified_company_section = (
                        f"\n\n{'\\_' * 30}\n\n*{escape_markdown_v2(company_name)}*\n\u200B\n\n"
                    )

            except (Exception, psycopg2.DatabaseError) as error:
                logger.error(f"Error fetching company profile: {error}")
                company_name = "Private Client"
                verified_company_section = (
                    f"\n\n{'\\_' * 30}\n\n*{escape_markdown_v2(company_name)}*\n\n"
                )

            finally:
                if cursor:
                    cursor.close()
                if conn:
                    conn.close()

            # Job summary for display
            job_summary = (
                f"🏷️ *Job Title:* {escape_markdown_v2(job_title)}\n\n"
                f"🕒 *Job Type:* {escape_markdown_v2(job_site)}, {escape_markdown_v2(job_type)}\n\n"
                f"🏢 *Job Sector:* {escape_markdown_v2(job_sector)}\n\n"
                f"📍 *Work Location:* {escape_markdown_v2(location_city)}, {escape_markdown_v2(location_country)}\n\n"
                f"🎓 *Education Qualification:* {escape_markdown_v2(education_qualification)}\n\n"
                f"🎖️ *Experience Level:* {escape_markdown_v2(experience_level)}\n\n"
                f"💰 *Salary/Compensation:* {escape_markdown_v2(salary_compensation_summary)}\n\n"
                f"👥 *Vacancy Number:* {escape_markdown_v2(str(vacancy_number))}\n\n"
                f"{gender_icon} *Applicant Gender:* {escape_markdown_v2(applicant_gender)}\n\n"
                f"⏳ *Job Application Deadline:* {escape_markdown_v2(job_application_deadline)}\n\n"
                f"📄 *Job Description:* {escape_markdown_v2(job_description)}"
            ) + verified_company_section

            await update.message.reply_text(text=job_summary, parse_mode='MarkdownV2')
    else:
        await update.message.reply_text("You have no closed jobs at the moment.")

    return JOB_MANAGEMENT


from telegram import InlineKeyboardButton, InlineKeyboardMarkup
import re
from datetime import date
import psycopg2
from telegram import Update
from telegram.ext import CallbackContext

# Function to escape special characters for MarkdownV2
def escape_markdown_v2(text):
    return re.sub(r'([_\*\[\]\(\)~`>#+\-=|{}.!])', r'\\\1', str(text))

# Function to format the deadline with a suffix (e.g., "20th")
def format_deadline_with_suffix(deadline_date):
    try:
        if isinstance(deadline_date, date):
            day_suffix = "th" if 11 <= deadline_date.day <= 13 else {1: "st", 2: "nd", 3: "rd"}.get(deadline_date.day % 10, "th")
            return deadline_date.strftime(f"%B {deadline_date.day}{day_suffix}, %Y")
        return deadline_date
    except Exception as e:
        logger.error(f"Error formatting deadline: {e}")
        return deadline_date

# Function to handle reposting closed jobs
async def repost_closed_jobs(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id  # Telegram chat_id

    conn = None
    cursor = None

    try:
        # Step 1: Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 2: Map chat_id to user_id in the users table
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return JOB_MANAGEMENT

        user_id = user_row[0]

        # Step 3: Fetch the 'closed' status_id from the job_status table
        cursor.execute('SELECT status_id FROM job_status WHERE status_name = %s', ('closed',))
        closed_status_row = cursor.fetchone()

        if not closed_status_row:
            await update.message.reply_text("Could not find 'closed' status. Please contact support.")
            return JOB_MANAGEMENT

        closed_status_id = closed_status_row[0]

        # Step 4: Fetch jobs with 'closed' status for the user, ordered by creation date
        cursor.execute('''
            SELECT jp.job_id, jp.job_title, jp.job_description, jp.job_site, jp.job_type, 
                   jp.job_sector, jp.education_qualification, jp.experience_level, 
                   jp.location_country, jp.location_city, jp.compensation_type, 
                   jp.salary_compensation, jp.currency_type, jp.vacancy_number,
                   jp.applicant_gender, jp.job_application_deadline, jp.user_id, jp.created_at
            FROM job_posts jp
            WHERE jp.user_id = %s AND jp.status_id = %s
            ORDER BY jp.created_at ASC
        ''', (user_id, closed_status_id))

        closed_jobs = cursor.fetchall()

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error: {error}")
        await update.message.reply_text("An error occurred while retrieving closed jobs.")
        return JOB_MANAGEMENT

    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

    # Step 5: Display the full job summaries with a repost button
    if closed_jobs:
        for job in closed_jobs:
            job_id, job_title, job_description, job_site, job_type, job_sector, education_qualification, \
            experience_level, location_country, location_city, compensation_type, salary_compensation, \
            currency_type, vacancy_number, applicant_gender, job_application_deadline, company_user_id, created_at = job

            # Format the application deadline
            if isinstance(job_application_deadline, date):
                job_application_deadline = format_deadline_with_suffix(job_application_deadline)

            # Gender icon logic
            gender_icon = "⚥" if applicant_gender not in ["Male", "Female"] else "♂️" if applicant_gender == "Male" else "♀️"

            # Format salary/compensation summary
            salary_compensation_summary = (
                f"{int(salary_compensation) if float(salary_compensation).is_integer() else salary_compensation} {currency_type} {compensation_type}"
                if salary_compensation else
                f"{currency_type} {compensation_type}"
            )

            # Fetch company profile details for the current job
            try:
                conn = psycopg2.connect(
                    dbname="my_project_db",
                    user="postgres",
                    password="1201",
                    host="localhost",
                    port="5432"
                )
                cursor = conn.cursor()

                cursor.execute('''
                    SELECT cp.company_name, cp.is_verified
                    FROM company_profiles cp
                    WHERE cp.user_id = %s
                ''', (company_user_id,))

                company_profile = cursor.fetchone()
                if company_profile and company_profile[1]:  # Verified company
                    company_name = company_profile[0]
                    company_section = (
                        f"\n\n{'\\_' * 30}\n\n*{escape_markdown_v2(company_name)}*\n✅ Verified Company\n\u200B\n\n"
                    )
                else:  # Unverified or missing profile
                    company_name = "Private Client"
                    company_section = (
                        f"\n\n{'\\_' * 30}\n\n*{escape_markdown_v2(company_name)}*\n\u200B\n\n"
                    )

            except (Exception, psycopg2.DatabaseError) as error:
                logger.error(f"Error fetching company profile: {error}")
                company_name = "Private Client"
                company_section = (
                    f"\n\n{'\\_' * 30}\n\n*{escape_markdown_v2(company_name)}*\n\n"
                )

            finally:
                if cursor:
                    cursor.close()
                if conn:
                    conn.close()

            # Job summary for display
            job_summary = (
                f"🏷️ *Job Title:* {escape_markdown_v2(job_title)}\n\n"
                f"🕒 *Job Type:* {escape_markdown_v2(job_site)}, {escape_markdown_v2(job_type)}\n\n"
                f"🏢 *Job Sector:* {escape_markdown_v2(job_sector)}\n\n"
                f"📍 *Work Location:* {escape_markdown_v2(location_city)}, {escape_markdown_v2(location_country)}\n\n"
                f"🎓 *Education Qualification:* {escape_markdown_v2(education_qualification)}\n\n"
                f"🎖️ *Experience Level:* {escape_markdown_v2(experience_level)}\n\n"
                f"💰 *Salary/Compensation:* {escape_markdown_v2(salary_compensation_summary)}\n\n"
                f"👥 *Vacancy Number:* {escape_markdown_v2(str(vacancy_number))}\n\n"
                f"{gender_icon} *Applicant Gender:* {escape_markdown_v2(applicant_gender)}\n\n"
                f"⏳ *Job Application Deadline:* {escape_markdown_v2(job_application_deadline)}\n\n"
                f"📄 *Job Description:* {escape_markdown_v2(job_description)}"
            ) + company_section

            # Add an inline button to repost the job
            inline_keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("🔁 Repost Job", callback_data=f"repost:{job_id}")]
            ])

            await update.message.reply_text(text=job_summary, parse_mode='MarkdownV2', reply_markup=inline_keyboard)
    else:
        await update.message.reply_text("You have no closed jobs at the moment.")

    return JOB_MANAGEMENT


from telegram import InlineKeyboardMarkup, InlineKeyboardButton

# Function to handle repost requests when the button is pressed
async def handle_repost_request(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    job_id = query.data.split(":")[1]  # Extract job_id from callback data
    logger.debug(f"handle_repost_request called for job_id: {job_id}")

    try:
        # Notify the employer that the repost request is being processed
        await query.answer(text="Processing your repost request...")

        # Connect to the database
        logger.debug("Connecting to PostgreSQL to fetch job details and repost limits...")
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch job details
        cursor.execute('''
            SELECT job_title, job_description, job_site, job_type, job_sector,
                   education_qualification, experience_level, location_country, location_city,
                   compensation_type, salary_compensation, currency_type, vacancy_number,
                   applicant_gender, job_application_deadline, user_id, repost_count
            FROM job_posts
            WHERE job_id = %s
        ''', (job_id,))
        job_post = cursor.fetchone()

        if not job_post:
            logger.error(f"Job post with ID {job_id} not found.")
            await query.answer(text="Job post not found.")
            return

        (job_title, job_description, job_site, job_type, job_sector, education_qualification, experience_level,
         location_country, location_city, compensation_type, salary_compensation, currency_type, vacancy_number,
         applicant_gender, job_application_deadline, user_id, specific_repost_count) = job_post

        # Fetch repost limits from the package_usage table
        cursor.execute('''
            SELECT repost_limit
            FROM package_usage
            WHERE user_id = %s AND package_expiration > NOW()
        ''', (user_id,))
        package_row = cursor.fetchone()

        if not package_row or package_row[0] <= 0:
            logger.debug(f"Employer with user_id {user_id} has insufficient repost limits.")
            await query.message.reply_text(
                "❌ You have reached your repost limit. Please upgrade your package or contact support for assistance."
            )
            return

        repost_limit = package_row[0]

        # Deduct one repost from the repost limit
        cursor.execute('''
            UPDATE package_usage
            SET repost_limit = repost_limit - 1
            WHERE user_id = %s AND package_expiration > NOW()
        ''', (user_id,))
        conn.commit()

        # Fetch company details and repost statistics
        cursor.execute('''
            SELECT cp.company_name, cp.is_verified 
            FROM company_profiles cp 
            WHERE cp.user_id = %s
        ''', (user_id,))
        company_row = cursor.fetchone()
        company_name = company_row[0] if company_row else "Private Client"
        is_verified = company_row[1] if company_row else False

        cursor.execute('SELECT COUNT(*) FROM job_posts WHERE user_id = %s', (user_id,))
        total_posts = cursor.fetchone()[0]

        cursor.execute('SELECT SUM(repost_count) FROM job_posts WHERE user_id = %s', (user_id,))
        total_reposts_all_jobs = cursor.fetchone()[0] or 0

        # Construct dynamic repost section
        repost_section = f"♻️ *Total Reposts (All Jobs):* {total_reposts_all_jobs}\n\n"
        repost_section += f"🔂 *Reposts for This Job:* {specific_repost_count}\n"

        # Construct the company details section
        if is_verified:
            verified_company_section = (
                f"*{company_name}*\n"
                f"Verified Company ✅\n\n"
                f"📁 *Total Jobs Posted:* {total_posts}\n\n"
                f"{repost_section}"
            )
        else:
            verified_company_section = (
                f"*Private Client*\n\n"
                f"📁 *Total Jobs Posted:* {total_posts}\n\n"
                f"{repost_section}"
            )

        # Dynamically choose the correct gender icon
        gender_icon = {
            "Male": "♂️",
            "Female": "♀️"
        }.get(applicant_gender, "⚥")

        # Format salary/compensation summary
        salary_compensation_summary = (
            f"{salary_compensation} {currency_type} {compensation_type}"
            if salary_compensation else
            f"{currency_type} {compensation_type}"
        )

        # Notify the admin about the repost request
        admin_id = 896853541  # Replace with your actual admin's Telegram ID
        repost_message = (
            f"🏷️ *Job Title:* {job_title}\n\n"
            f"🕒 *Job Type:* {job_site}, {job_type}\n\n"
            f"🏢 *Job Sector:* {job_sector}\n\n"
            f"📍 *Location:* {location_city}, {location_country}\n\n"
            f"🎓 *Education Qualification:* {education_qualification}\n\n"
            f"🎖️ *Experience Level:* {experience_level}\n\n"
            f"💰 *Salary/Compensation:* {salary_compensation_summary}\n\n"
            f"👥 *Vacancy Number:* {vacancy_number}\n\n"
            f"{gender_icon} *Applicant Gender:* {applicant_gender}\n\n"
            f"⏳ *Job Application Deadline:* {job_application_deadline}\n\n"
            f"📄 *Job Description:* {job_description}\n"
            f"{'\\_' * 30}\n\n"  # Separator line
            f"{verified_company_section}"
            f"{'\\_' * 30}\n"
        )

        logger.debug(f"Sending repost approval message to admin_id {admin_id}")
        await context.bot.send_message(
            chat_id=admin_id,
            text=repost_message,
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("✅ Approve", callback_data=f"approve_repost:{job_id}")],
                [InlineKeyboardButton("❌ Deny", callback_data=f"deny_repost:{job_id}")]
            ])
        )

        # Notify the employer about the successful repost request
        await query.message.reply_text(
            f"🔁 Your repost request has been sent to the admin for approval. You now have {repost_limit - 1} reposts remaining."
        )

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error: {error}")
        await query.answer(text="An error occurred while sending the repost request.")
    finally:
        if conn:
            cursor.close()
            conn.close()


async def handle_repost_approval(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    job_id = query.data.split(":")[1]  # Extract job_id from callback data

    try:
        # Step 1: Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 2: Update the job status to 'opened' and increment the repost count
        cursor.execute('''
            UPDATE job_posts
            SET status_id = (SELECT status_id FROM job_status WHERE status_name = 'opened'),
                repost_count = repost_count + 1
            WHERE job_id = %s
        ''', (job_id,))
        conn.commit()

        # Step 3: Fetch the employer's chat_id
        cursor.execute('''
            SELECT u.contact, u.user_id
            FROM users u
            JOIN job_posts j ON u.user_id = j.user_id
            WHERE j.job_id = %s
        ''', (job_id,))
        employer_chat_row = cursor.fetchone()

        if not employer_chat_row:
            await query.answer(text="Employer not found.")
            return

        employer_chat_id, employer_user_id = employer_chat_row

        # Notify the employer about the repost approval
        await context.bot.send_message(
            chat_id=employer_chat_id,
            text=f"✅ Your job has been reposted and is now live on the platform."
        )

        # Step 4: Fetch job details
        cursor.execute('''
            SELECT job_title, job_description, job_site, job_type, job_sector,
                   education_qualification, experience_level, location_country, location_city,
                   compensation_type, salary_compensation, currency_type, vacancy_number,
                   applicant_gender, job_application_deadline, repost_count
            FROM job_posts
            WHERE job_id = %s
        ''', (job_id,))
        job_post = cursor.fetchone()

        if not job_post:
            await query.answer(text="Job details not found.")
            return

        job_title, job_description, job_site, job_type, job_sector, education_qualification, \
        experience_level, location_country, location_city, compensation_type, salary_compensation, \
        currency_type, vacancy_number, applicant_gender, job_application_deadline, specific_repost_count = job_post

        # Fetch company details and total repost count for all jobs by employer
        cursor.execute('''
            SELECT cp.company_name, cp.is_verified 
            FROM company_profiles cp 
            WHERE cp.user_id = %s
        ''', (employer_user_id,))
        company_row = cursor.fetchone()
        company_name = company_row[0] if company_row else "Private Client"
        is_verified = company_row[1] if company_row else False

        cursor.execute('SELECT COUNT(*) FROM job_posts WHERE user_id = %s', (employer_user_id,))
        total_posts = cursor.fetchone()[0]

        cursor.execute('SELECT SUM(repost_count) FROM job_posts WHERE user_id = %s', (employer_user_id,))
        total_reposts_all_jobs = cursor.fetchone()[0] or 0

        # Dynamically construct repost section
        repost_section = ""
        if total_reposts_all_jobs > 0:
            repost_section += f"♻️ *Total Reposts (All Jobs):* {total_reposts_all_jobs}\n\n"
        if specific_repost_count > 0:
            repost_section += f"🔂 *Reposts for This Job:* {specific_repost_count}\n"

        # Construct the company details section
        if is_verified:
            verified_company_section = (
                f"*{company_name}*\n"
                f"Verified Company ✅\n\n"
                f"📁 *Total Jobs Posted:* {total_posts}\n\n"
                f"{repost_section}"  # Include dynamic repost section if available
            )
        else:
            verified_company_section = (
                f"*Private Client*\n\n"
                f"📁 *Total Jobs Posted:* {total_posts}\n\n"
                f"{repost_section}"  # Include dynamic repost section if available
            )

        # Format salary/compensation summary
        if salary_compensation:
            # Remove .0 if the salary is a whole number
            salary_compensation = int(salary_compensation) if float(
                salary_compensation).is_integer() else salary_compensation
            salary_compensation_summary = f"{salary_compensation} {currency_type} {compensation_type}"
        else:
            salary_compensation_summary = f"{currency_type} {compensation_type}"

        # Choose the correct gender icon
        gender_icon = "⚥" if applicant_gender not in ["Male", "Female"] else "♂️" if applicant_gender == "Male" else "♀️"

        # Construct the job summary
        job_summary = (
            f"🏷️ *Job Title:* {job_title}\n\n"
            f"🕒 *Job Type:* {job_site}, {job_type}\n\n"
            f"🏢 *Job Sector:* {job_sector}\n\n"
            f"📍 *Work Location:* {location_city}, {location_country}\n\n"
            f"🎓 *Education Qualification:* {education_qualification}\n\n"
            f"🎖️ *Experience Level:* {experience_level}\n\n"
            f"💰 *Salary/Compensation:* {salary_compensation_summary}\n\n"
            f"👥 *Vacancy Number:* {vacancy_number}\n\n"
            f"{gender_icon} *Applicant Gender:* {applicant_gender}\n\n"
            f"⏳ *Job Application Deadline:* {job_application_deadline}\n\n"
            f"📄 *Job Description:*\n{job_description}\n"
            f"{'\\_' * 30}\n\n"
            f"{verified_company_section}"
            f"{'\\_' * 30}\n"
        )

        # Step 5: Post the job summary to the designated channel with Apply button
        apply_button = InlineKeyboardButton("Apply",
                                            url=f"https://t.me/{context.bot.username}?start=apply_{job_id}")
        reply_markup = InlineKeyboardMarkup([[apply_button]])

        sent_message = await context.bot.send_message(
            chat_id="@tegu_ethio",  # Replace with actual channel username
            text=job_summary,
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )

        # Step 6: Capture the message_id from the sent message
        message_id = sent_message.message_id

        # Step 7: Store message_id and channel_username in the job_posts table
        cursor.execute('''
            UPDATE job_posts 
            SET message_id = %s, channel_username = %s 
            WHERE job_id = %s
        ''', (message_id, "@tegu_ethio", job_id))
        conn.commit()

        # Notify admin
        await query.answer(text="Job repost approved and posted to the channel.")

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error: {error}")
        await query.answer(text="An error occurred while approving the repost.")
    finally:
        if conn:
            cursor.close()
            conn.close()





async def handle_admin_action(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    query_data = query.data
    job_id = query_data.split(":")[1]

    if query_data.startswith("approve_repost:"):
        # Admin approved the repost
        await handle_repost_approval(update, context)

    elif query_data.startswith("deny_repost:"):
        # Admin denied the repost
        try:
            # Connect to the database
            conn = psycopg2.connect(
                dbname="my_project_db",
                user="postgres",
                password="1201",
                host="localhost",
                port="5432"
            )
            cursor = conn.cursor()

            # Update the job status to 'denied'
            cursor.execute('''
                UPDATE job_posts
                SET status_id = (SELECT status_id FROM job_status WHERE status_name = 'denied')
                WHERE job_id = %s
            ''', (job_id,))
            conn.commit()

            # Notify the employer about job denial
            cursor.execute('SELECT contact FROM users WHERE user_id = (SELECT user_id FROM job_posts WHERE job_id = %s)', (job_id,))
            user_chat_row = cursor.fetchone()

            if user_chat_row:
                employer_chat_id = user_chat_row[0]
                await context.bot.send_message(
                    chat_id=employer_chat_id,
                    text=f"❌ Your repost request for job '{job_id}' has been denied."
                )

            # Notify the admin that the job repost was denied
            await query.answer(text="Job repost denied.")

        except (Exception, psycopg2.DatabaseError) as error:
            logger.error(f"Database error while denying repost: {error}")
            await query.answer(text="An error occurred while denying the repost.")
        finally:
            if conn:
                cursor.close()
                conn.close()

    # Remove the inline buttons after approval/denial
    await query.edit_message_reply_markup(reply_markup=None)


async def validate_user_input(update: Update, context: CallbackContext) -> int:
    """
    Validates user input and reminds them to use the buttons if the input is not recognized.
    """
    await update.message.reply_text(
        "⚠️ Invalid input. Kindly choose one of the options provided by clicking the appropriate button."
    )
    return VIEW_APPLICANTS_STATE  # Stay in the current state



from telegram import InlineKeyboardButton, InlineKeyboardMarkup

async def view_applicants(update: Update, context: CallbackContext) -> int:
    employer_contact = update.effective_user.id  # Employer's chat ID

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch all jobs posted by this employer
        cursor.execute('''
            SELECT job_posts.job_id, job_posts.job_title 
            FROM job_posts
            JOIN users ON job_posts.user_id = users.user_id
            WHERE users.contact = %s
        ''', (str(employer_contact),))
        jobs = cursor.fetchall()

        if not jobs:
            await update.message.reply_text("You have not posted any jobs yet.")
            return JOB_MANAGEMENT

        # Fetch all applicants for these jobs
        cursor.execute('''
            SELECT users.user_id, users.first_name, users.last_name, users.gender, 
                   job_posts.job_title, applications.application_id, applications.status
            FROM applications
            JOIN users ON applications.user_id = users.user_id
            JOIN job_posts ON applications.job_id = job_posts.job_id
            WHERE job_posts.user_id = (SELECT user_id FROM users WHERE contact = %s)
        ''', (str(employer_contact),))
        applicants = cursor.fetchall()

    except Exception as e:
        logger.error(f"Error retrieving applicants: {e}")
        await update.message.reply_text("An error occurred while retrieving applicants.")
        return JOB_MANAGEMENT

    finally:
        if conn:
            cursor.close()
            conn.close()

    # If applicants are found
    if applicants:
        response = ""
        current_job_title = None

        for applicant in applicants:
            user_id, first_name, last_name, gender, job_title, application_id, status = applicant

            # Determine gender icon based on user gender
            gender_icon = {
                "male": "👨🏾",
                "female": "👩🏾",
            }.get(gender.lower(), "⚥")  # Default to ⚥ for unknown/other genders

            # Group applicants under their respective job titles
            if current_job_title != job_title:
                # Send previous job group if response isn't empty
                if response.strip():
                    await update.message.reply_text(
                        response.strip(),
                        parse_mode='MarkdownV2'
                    )
                response = f"\n*📌 Job Title: {escape_markdown_v2(job_title)}*\n"
                current_job_title = job_title

            response += f"\n {gender_icon} *Name:* *{escape_markdown_v2(first_name)} {escape_markdown_v2(last_name)}*\n"

            # Ensure only one button shows a status icon based on the current status
            shortlist_label = "Shortlist ✔️" if status == "shortlisted" else "Shortlist"
            hire_label = "Hired ✅" if status == "hired" else "Hire"
            reject_label = "Rejected ❌" if status == "rejected" else "Reject"

            # Inline buttons for each applicant
            buttons = InlineKeyboardMarkup([
                [InlineKeyboardButton("Application Message", callback_data=f"view_app_message_{application_id}")],
                [InlineKeyboardButton("View Profile", callback_data=f"view_app_profile_{application_id}")],
                [InlineKeyboardButton("Chat", callback_data=f"start_chat_{application_id}")],
                [InlineKeyboardButton(shortlist_label, callback_data=f"shortlist_{application_id}")],
                [InlineKeyboardButton(hire_label, callback_data=f"hire_{application_id}")],
                [InlineKeyboardButton(reject_label, callback_data=f"reject_{application_id}")]
            ])
            await update.message.reply_text(
                response.strip(),
                reply_markup=buttons,
                parse_mode='MarkdownV2'
            )
            response = ""  # Reset response after sending applicant details

        # Send any remaining grouped applicants
        if response.strip():
            await update.message.reply_text(
                response.strip(),
                parse_mode='MarkdownV2'
            )

        # Add "Back to Menu" button after all applicants
        await update.message.reply_text(
            "You can return to the Applications menu using the button below.",
            reply_markup=ReplyKeyboardMarkup([
                ["🔙 Back"]
            ], resize_keyboard=True)
        )
        return VIEW_APPLICANTS_STATE  # Stay in the applicants view state

    # If no applicants are found
    else:
        await update.message.reply_text(
            "No applicants found for your jobs.",
            reply_markup=ReplyKeyboardMarkup([
                ["🔙 Back"]
            ], resize_keyboard=True)
        )
        return VIEW_APPLICANTS_STATE

async def handle_back_to_menu(update: Update, context: CallbackContext) -> int:
    """
    Handle the '🔙 Back to Menu' button, redirecting users to the Applications menu.
    """
    await update.message.reply_text(
        "Applications: Please choose an action.",
        reply_markup=ReplyKeyboardMarkup([
            ["🔍 View Applicants", "📋 Shortlisted"],
            ["⚖️ Hired Applicants", "📞 Contact Applicants"],
            ["🔙 Back"]
        ], resize_keyboard=True)
    )
    return APPLICATIONS  # Define APPLICATIONS state in your ConversationHandler


import logging
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import CallbackContext
import psycopg2
from telegram.constants import ParseMode
from datetime import datetime, date
import ast  # For safely parsing list-like strings

def escape_markdown_v2(text):
    """Escape Markdown V2 special characters."""
    escape_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!', '\\']
    if text:
        for char in escape_chars:
            text = text.replace(char, f"\\{char}")
    return text

def calculate_age(dob):
    """Calculate age from a date of birth (datetime.date or str)."""
    if not dob:
        return "N/A"
    if isinstance(dob, str):
        try:
            dob = datetime.strptime(dob, '%Y-%m-%d').date()
        except ValueError:
            return "Invalid Date"
    elif not isinstance(dob, date):
        return "N/A"
    today = date.today()
    return f"{today.year - dob.year - ((today.month, today.day) < (dob.month, dob.day))} years"

def format_list_field(value, icon):
    """Format list-like fields to remove brackets and display items cleanly."""
    try:
        items = ast.literal_eval(value) if isinstance(value, str) else value
        return "\n\n".join([f"{icon} {escape_markdown_v2(item.strip())}" for item in items if item.strip()])
    except (ValueError, SyntaxError):
        return f"{icon} {escape_markdown_v2(value.strip())}"  # Fallback for single values

def add_section(title, fields):
    """Add a dynamic section if there are valid fields."""
    section_content = "\n".join(filter(None, fields)).strip()
    return f"*{title}*\n\n{section_content}\n" if section_content else ""

async def handle_view_app_profile(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    application_id = int(query.data.split("_")[-1])  # Extract application_id from callback data

    logging.info(f"Fetching profile for application_id: {application_id}")

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id and associated fields from applications and applicant_profiles
        cursor.execute('''
            SELECT ap.full_name, ap.job_title, ap.experience_level, ap.skills, ap.location, ap.phone_number, ap.email, 
                   ap.work_experience, ap.highest_degree, ap.university, ap.college, ap.graduation_year, ap.gpa, 
                   ap.certifications, ap.languages, ap.portfolio_link, ap.dob, ap.gender, ap.employment_type, ap.availability, a.user_id
            FROM applications a
            JOIN applicant_profiles ap ON a.user_id = ap.user_id
            WHERE a.application_id = %s
        ''', (application_id,))
        profile_data = cursor.fetchone()

        if not profile_data:
            logging.warning(f"No profile found for application_id: {application_id}")
            await query.answer("Applicant profile not found.", show_alert=True)
            return VIEW_APPLICANTS_STATE

        # Unpack profile data
        (full_name, job_title, experience_level, skills, location, phone_number, email,
         work_experience, highest_degree, university, college, graduation_year, gpa,
         certifications, languages, portfolio_link, dob, gender, employment_type, availability, user_id) = profile_data

        # Format phone number as clickable if it exists, prepend +251 (or country code if needed)
        formatted_phone_number = f"+{phone_number}" if phone_number else ""

        # Dynamically include only sections with actual data
        sections = filter(None, [
            add_section("Personal Information", [
                f"{'👨🏾' if gender.strip().lower() == 'male' else '👩🏾'} *Full Name:* {escape_markdown_v2(full_name)}",
                f"\n🎂 *Age:* {escape_markdown_v2(calculate_age(dob))}" if dob else "",
                f"\n📞 *Phone:* [{escape_markdown_v2(formatted_phone_number)}](tel:{formatted_phone_number})" if phone_number else "",
                f"\n✉️ *Email:* {escape_markdown_v2(email)}" if email else "",
                f"\n📍 *Location:* {escape_markdown_v2(location)}" if location else ""
            ]),
            add_section("Professional Overview", [
                f"💼 *Job Title:* {escape_markdown_v2(job_title)}" if job_title else "",
                f"\n📊 *Experience Level:* {escape_markdown_v2(experience_level)}" if experience_level else "",
                f"\n🕒 *Employment Type:* {escape_markdown_v2(employment_type)}" if employment_type else "",
                f"\n📅 *Availability:* {escape_markdown_v2(availability)}" if availability else ""
            ]),
            add_section("Work Experience", [
                f"🏢 {escape_markdown_v2(work_experience)}" if work_experience else ""
            ]),
            add_section("Education", [
                f"🎓 *Degrees:* {escape_markdown_v2(highest_degree)}" if highest_degree else "",
                f"\n🏫 *University:* {escape_markdown_v2(university)}" if university else "",
                f"\n🏛️ *College:* {escape_markdown_v2(college)}" if college else "",
                f"\n📅 *Graduation Year:* {escape_markdown_v2(graduation_year)}" if graduation_year else "",
                f"\n📊 *GPA:* {escape_markdown_v2(gpa)}" if gpa else ""
            ]),
            add_section("Certifications", [
                format_list_field(certifications, "📜") if certifications else ""
            ]),
            add_section("Languages", [
                format_list_field(languages, "🌐") if languages else ""
            ]),
            add_section("Skills", [
                format_list_field(skills, "🛠️") if skills else ""
            ]),
            add_section("Portfolio Links", [
                "\n\n".join([f"🔗 {escape_markdown_v2(link.strip())}" for link in portfolio_link.split(",") if link.strip()]) if portfolio_link else ""
            ])
        ])

        profile_info = "\n\n".join(sections)

        # Edit the message with the complete profile information
        await query.message.edit_text(
            profile_info,
            parse_mode='MarkdownV2',
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("Back", callback_data=f"back_to_applicants_{application_id}")]
            ])
        )
        await query.answer()  # Remove spinner

    except Exception as e:
        logging.error(f"Error fetching profile for application_id {application_id}: {e}")
        await query.message.edit_text("An error occurred while retrieving the profile.")
    finally:
        if conn:
            cursor.close()
            conn.close()

    return VIEW_APPLICANTS_STATE


from telegram import Update
from telegram.ext import CallbackContext
import psycopg2
import logging

logger = logging.getLogger(__name__)

async def handle_hire_applicant(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    application_id = query.data.split("_")[-1]

    try:
        conn = psycopg2.connect(dbname="my_project_db", user="postgres", password="1201", host="localhost", port="5432")
        cursor = conn.cursor()

        # Check the current status
        cursor.execute('SELECT status FROM applications WHERE application_id = %s', (application_id,))
        current_status = cursor.fetchone()[0]

        if current_status == 'hired':
            await query.answer("This applicant has already been hired. Status changes are not allowed.", show_alert=True)
            return

        # Update to 'hired' status
        cursor.execute('UPDATE applications SET status = %s, hired_date = NOW() WHERE application_id = %s',
                       ('hired', application_id))
        conn.commit()

        # Fetch applicant and job details
        cursor.execute('''
            SELECT u.contact, u.first_name, u.last_name, jp.job_title, jp.channel_username, jp.message_id, c.company_name
            FROM applications a
            JOIN users u ON a.user_id = u.user_id
            JOIN job_posts jp ON a.job_id = jp.job_id
            LEFT JOIN company_profiles c ON jp.user_id = c.user_id
            WHERE a.application_id = %s
        ''', (application_id,))
        applicant_data = cursor.fetchone()

        if not applicant_data:
            raise ValueError("Applicant or job data not found.")

        applicant_contact, applicant_first_name, applicant_last_name, job_title, channel_username, message_id, company_name = applicant_data

        # Fetch employer details
        cursor.execute('''
            SELECT u.first_name AS employer_name
            FROM job_posts jp
            JOIN users u ON jp.user_id = u.user_id
            WHERE jp.job_id = (SELECT job_id FROM applications WHERE application_id = %s)
        ''', (application_id,))
        employer_data = cursor.fetchone()

        employer_name = employer_data[0] if employer_data else "Your Employer"

        # Construct job link
        job_link = f"https://t.me/{channel_username.strip('@')}/{message_id}" if channel_username and message_id else "#"

        # Construct notification message
        notification_message = (
                "🎉 <b>Welcome aboard!</b>\n\n"
                f"Hi <b>{applicant_first_name} {applicant_last_name}</b>,\n\n"
                f"We’re thrilled to let you know that you’ve been hired for the "
                f"<a href='{job_link}'>{job_title}</a> position"
                + (f" at <b>{company_name}</b>" if company_name else "")  # Add "at company" dynamically
                + "!\n\n"
                  "Here’s who you’ll be working with:\n"
                  f"\n👤 <b>Employer Name:</b> {employer_name}"
                + (f"\n\n🏢 <b>Company Name:</b> {company_name}" if company_name else "")  # Add company line dynamically
                + "\n\nYour employer will reach out to coordinate the next steps. Congrats again!"
        )

        # Send the message to the applicant
        if applicant_contact:
            try:
                await context.bot.send_message(
                    chat_id=applicant_contact,
                    text=notification_message,
                    parse_mode="HTML"
                )
            except Exception as notify_error:
                logger.warning(f"Could not notify applicant {applicant_contact}: {notify_error}")

        # Update inline keyboard for the employer
        updated_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("Close Job", callback_data=f"close_job_{application_id}")],
            [InlineKeyboardButton("Keep Job Open", callback_data=f"keep_open_{application_id}")]
        ])

        await query.message.edit_reply_markup(reply_markup=updated_keyboard)
        await query.answer("Applicant successfully hired.", show_alert=True)

    except Exception as e:
        logger.error(f"Error updating hire status: {e}")
        await query.answer("Failed to update hire status.", show_alert=True)

    finally:
        if conn:
            cursor.close()
            conn.close()


from telegram import InlineKeyboardButton, InlineKeyboardMarkup
import psycopg2
import logging

logger = logging.getLogger(__name__)

async def handle_close_job(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    application_id = query.data.split("_")[-1]

    try:
        conn = psycopg2.connect(dbname="my_project_db", user="postgres", password="1201", host="localhost", port="5432")
        cursor = conn.cursor()

        # Get job_id and application status
        cursor.execute('SELECT job_id, status FROM applications WHERE application_id = %s', (application_id,))
        result = cursor.fetchone()
        if not result:
            await query.answer("Job not found.", show_alert=True)
            return

        job_id, current_status = result

        # Update job status to closed
        cursor.execute('UPDATE job_posts SET status_id = 6 WHERE job_id = %s', (job_id,))
        conn.commit()

        # Determine button labels
        hire_label = "Hired ✅" if current_status == "hired" else "Hire"
        shortlist_label = "Shortlist ✔️" if current_status == "shortlisted" else "Shortlist"
        reject_label = "Rejected ❌" if current_status == "rejected" else "Reject"

        # Update keyboard without close/open buttons
        updated_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("Application Message", callback_data=f"view_app_message_{application_id}")],
            [InlineKeyboardButton("View Profile", callback_data=f"view_app_profile_{application_id}")],
            [InlineKeyboardButton("Chat", callback_data=f"start_chat_{application_id}")],

            [InlineKeyboardButton(hire_label, callback_data=f"hire_{application_id}")],

        ])

        await query.message.edit_reply_markup(reply_markup=updated_keyboard)
        await query.answer("Job successfully closed.", show_alert=True)

    except Exception as e:
        logger.error(f"Error closing job: {e}")
        await query.answer("Failed to close job.", show_alert=True)

    finally:
        if conn:
            cursor.close()
            conn.close()

async def handle_keep_job_open(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    application_id = query.data.split("_")[-1]

    try:
        conn = psycopg2.connect(dbname="my_project_db", user="postgres", password="1201", host="localhost", port="5432")
        cursor = conn.cursor()

        # Get current application status
        cursor.execute('SELECT status FROM applications WHERE application_id = %s', (application_id,))
        current_status = cursor.fetchone()[0]

        # Determine button labels
        hire_label = "Hired ✅" if current_status == "hired" else "Hire"
        shortlist_label = "Shortlist ✔️" if current_status == "shortlisted" else "Shortlist"
        reject_label = "Rejected ❌" if current_status == "rejected" else "Reject"

        # Update keyboard without close/open buttons
        updated_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("Application Message", callback_data=f"view_app_message_{application_id}")],
            [InlineKeyboardButton("View Profile", callback_data=f"view_app_profile_{application_id}")],
            [InlineKeyboardButton("Chat", callback_data=f"start_chat_{application_id}")],

            [InlineKeyboardButton(hire_label, callback_data=f"hire_{application_id}")],

        ])

        await query.message.edit_reply_markup(reply_markup=updated_keyboard)
        await query.answer("Job will remain open.", show_alert=True)

    except Exception as e:
        logger.error(f"Error keeping job open: {e}")
        await query.answer("Failed to keep job open.", show_alert=True)

    finally:
        if conn:
            cursor.close()
            conn.close()



async def handle_reject_applicant(update: Update, context: CallbackContext) -> None:
    """Toggle reject status and update button states."""
    query = update.callback_query
    application_id = query.data.split("_")[-1]  # Extract application ID

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Check the current status
        cursor.execute('SELECT status FROM applications WHERE application_id = %s', (application_id,))
        current_status = cursor.fetchone()[0]

        # Toggle between 'rejected' and 'pending'
        if current_status == 'rejected':
            new_status = 'pending'
            cursor.execute('UPDATE applications SET status = %s, rejected_date = NULL WHERE application_id = %s', (new_status, application_id))
        else:
            new_status = 'rejected'
            cursor.execute('UPDATE applications SET status = %s, rejected_date = NOW() WHERE application_id = %s', (new_status, application_id))

        conn.commit()

        # Fetch the updated status after commit
        cursor.execute('SELECT status FROM applications WHERE application_id = %s', (application_id,))
        updated_status = cursor.fetchone()[0]

        # Update inline keyboard dynamically
        shortlist_label = "Shortlist ✔️" if updated_status == "shortlisted" else "Shortlist"
        hire_label = "Hired ✅" if updated_status == "hired" else "Hire"
        reject_label = "Rejected ❌" if updated_status == "rejected" else "Reject"

        # Inline keyboard reflecting the updated status
        updated_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("Application Message", callback_data=f"view_app_message_{application_id}")],
            [InlineKeyboardButton("View Profile", callback_data=f"view_app_profile_{application_id}")],
            [InlineKeyboardButton("Chat", callback_data=f"start_chat_{application_id}")],
            [InlineKeyboardButton(shortlist_label, callback_data=f"shortlist_{application_id}")],
            [InlineKeyboardButton(hire_label, callback_data=f"hire_{application_id}")],
            [InlineKeyboardButton(reject_label, callback_data=f"reject_{application_id}")]
        ])

        await query.message.edit_reply_markup(reply_markup=updated_keyboard)
        await query.answer("Status updated.", show_alert=True)

    except Exception as e:
        logger.error(f"Error updating reject status: {e}")
        await query.answer("Failed to update reject status.", show_alert=True)

    finally:
        if conn:
            cursor.close()
            conn.close()




async def start_chat(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()  # Acknowledge the callback query

    try:
        application_id = int(query.data.split("_")[-1])  # Extract application_id

        # Establish database connection
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id linked to this application_id
        cursor.execute("""
            SELECT u.first_name, u.last_name, u.username, u.phone_number 
            FROM applications a
            JOIN users u ON a.user_id = u.user_id
            WHERE a.application_id = %s
        """, (application_id,))
        applicant_row = cursor.fetchone()

        if not applicant_row:
            await query.message.reply_text("Applicant not found in the database.")
            return

        applicant_first_name, applicant_last_name, applicant_username, applicant_phone = applicant_row
        applicant_name = f"{applicant_first_name} {applicant_last_name}"

        # Add "+" sign to the phone number if not already present
        if applicant_phone and not applicant_phone.startswith("+"):
            applicant_phone = f"+{applicant_phone}"

        # Generate contact info with a professional disclaimer
        if applicant_username:
            applicant_contact_info = f"Telegram: [@{applicant_username}](https://t.me/{applicant_username})"
        elif applicant_phone:
            applicant_contact_info = f"📞 *Phone:* {applicant_phone}"  # Ensure phone number has a '+' prefix
        else:
            applicant_contact_info = "Contact information not available."

        # Professional disclaimer for using contact details
        disclaimer = (
            "\n\n⚠️ *Important Notice:*\n"
            "This contact information is provided for professional purposes only. Misuse of this information, including "
            "unsolicited messages or harassment, will result in your account being reviewed and potentially blocked."
        )

        # Display applicant contact details with the disclaimer
        await query.message.reply_text(
            f"👤 *Name:* {applicant_name}\n\n"
            f"{applicant_contact_info}{disclaimer}",
            parse_mode="Markdown"
        )


    except Exception as e:
        logging.error(f"Error in start_chat: {e}")
        await query.message.reply_text("An error occurred while initiating the chat. Please try again.")
    finally:
        if conn:
            cursor.close()
            conn.close()





async def end_chat(update: Update, context: CallbackContext) -> None:
    """End the chat and delete the temporary group."""
    employer_id = update.message.from_user.id  # Assuming the employer ends the chat

    # Find the group by employer_id
    group_id = chat_pairs.pop((employer_id, applicant_id), None)

    if group_id:
        try:
            # Step 1: Notify the group
            await context.bot.send_message(chat_id=group_id, text="This group will now be closed.")

            # Step 2: Delete the group
            await context.bot.delete_chat(group_id)
            await update.message.reply_text("The chat group has been closed.")
        except Exception as e:
            logger.error(f"Error ending chat: {e}")
            await update.message.reply_text("Failed to close the chat group.")
    else:
        await update.message.reply_text("No active group chat found.")

from telegram import ChatPermissions

permissions = ChatPermissions(
    can_send_messages=True,
    can_send_polls=False,
    can_add_web_page_previews=False,
    can_invite_users=False
)



from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import CallbackContext
import psycopg2
import logging

logger = logging.getLogger(__name__)

# Function to handle viewing the application message
async def handle_application_message(update: Update, context: CallbackContext) -> int:
    """
    Show the application message and details when the 'Application Message' button is pressed.
    """
    query = update.callback_query
    application_id = query.data.split("_")[-1]  # Extract the application ID from callback data

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve application details and resume based on the application_id
        cursor.execute('''
            SELECT applications.application_message, applications.portfolio_links, 
                   applicant_profiles.resume, applications.user_id
            FROM applications
            JOIN applicant_profiles ON applications.user_id = applicant_profiles.user_id
            WHERE applications.application_id = %s
        ''', (application_id,))
        application_row = cursor.fetchone()

        if not application_row:
            await query.answer("Application details not found.", show_alert=True)
            return VIEW_APPLICANTS_STATE

        application_message, portfolio_links, resume, user_id = application_row

        # Check for CV attachment
        attachments = "📎 CV attached" if resume else "No CV provided"

        # Construct the detailed application message
        response_text = (
            f"*📩 Applicant Message:*{application_message or 'No message provided'}\n\n"
            f"*🌐 Portfolio Links:*{portfolio_links or 'No links provided'}\n\n"
            f"*📂 Attachments:* {attachments}"
        )

        # Construct InlineKeyboardMarkup
        buttons = [
            [InlineKeyboardButton("🔙 Back to Applicants", callback_data=f"back_to_applicants_{application_id}")],
        ]
        if resume:
            buttons.append(
                [InlineKeyboardButton("📥 Download CV", callback_data=f"download_cv_{application_id}")]
            )

        # Edit the message to display the application details
        await query.message.edit_text(
            response_text,
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup(buttons)
        )
        await query.answer()  # Remove the loading spinner

    except Exception as e:
        logger.error(f"Error fetching application details: {e}")
        await query.message.reply_text("An error occurred while retrieving the application details.")
        return VIEW_APPLICANTS_STATE

    finally:
        if conn:
            cursor.close()
            conn.close()

    return VIEW_APPLICANTS_STATE

async def back_to_applicants(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    application_id = query.data.split("_")[-1]  # Extract application_id from callback data

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch applicant details and their job title
        cursor.execute('''
            SELECT users.user_id, users.first_name, users.last_name, users.gender, 
                   job_posts.job_title, applications.status
            FROM applications
            JOIN users ON applications.user_id = users.user_id
            JOIN job_posts ON applications.job_id = job_posts.job_id
            WHERE applications.application_id = %s
        ''', (application_id,))
        applicant_row = cursor.fetchone()

        if not applicant_row:
            logger.warning(f"No applicant details found for application_id: {application_id}")
            await query.message.edit_text("Applicant details not found.")
            return VIEW_APPLICANTS_STATE

        user_id, first_name, last_name, gender, job_title, status = applicant_row

        # Determine gender icon
        gender_icon = {
            "male": "👨🏾",
            "female": "👩🏾"
        }.get(gender.lower(), "⚥")

        # Build response text
        response_text = (
            f"*📌 Job Title: {escape_markdown_v2(job_title)}*\n"
            f"\n{gender_icon} *Name:* {escape_markdown_v2(first_name)} {escape_markdown_v2(last_name)}\n\n"
        )

        # Inline buttons reflecting the updated `view_applicants` structure
        if status == "hired":
            buttons = InlineKeyboardMarkup([
                [InlineKeyboardButton("Application Message", callback_data=f"view_app_message_{application_id}")],
                [InlineKeyboardButton("View Profile", callback_data=f"view_app_profile_{application_id}")],
                [InlineKeyboardButton("Chat", callback_data=f"start_chat_{application_id}")],
                [InlineKeyboardButton("Hired ✅", callback_data=f"hire_{application_id}")]
            ])
        else:
            shortlist_label = "Shortlist ✔️" if status == "shortlisted" else "Shortlist"
            hire_label = "Hire" if status != "hired" else "Hired ✅"
            reject_label = "Rejected ❌" if status == "rejected" else "Reject"

            buttons = InlineKeyboardMarkup([
                [InlineKeyboardButton("Application Message", callback_data=f"view_app_message_{application_id}")],
                [InlineKeyboardButton("View Profile", callback_data=f"view_app_profile_{application_id}")],
                [InlineKeyboardButton("Chat", callback_data=f"start_chat_{application_id}")],
                [InlineKeyboardButton(shortlist_label, callback_data=f"shortlist_{application_id}")],
                [InlineKeyboardButton(hire_label, callback_data=f"hire_{application_id}")],
                [InlineKeyboardButton(reject_label, callback_data=f"reject_{application_id}")]
            ])

        await query.message.edit_text(
            response_text,
            parse_mode='MarkdownV2',
            reply_markup=buttons
        )
        await query.answer()  # Remove loading spinner

    except Exception as e:
        logger.error(f"Error fetching applicant details for application_id {application_id}: {e}")
        await query.message.edit_text("An error occurred while retrieving the applicant details.")
        return VIEW_APPLICANTS_STATE

    finally:
        if conn:
            cursor.close()
            conn.close()

    return VIEW_APPLICANTS_STATE



async def handle_download_cv(update: Update, context: CallbackContext) -> None:
    """Send the CV as a document in response to the 'Download CV' button, including the applicant's name in the caption."""
    query = update.callback_query
    application_id = query.data.split("_")[-1]  # Extract application ID

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch the resume file path and applicant's name based on the application_id
        cursor.execute('''
            SELECT applicant_profiles.resume, users.first_name, users.last_name
            FROM applications
            JOIN applicant_profiles ON applications.user_id = applicant_profiles.user_id
            JOIN users ON applications.user_id = users.user_id
            WHERE applications.application_id = %s
        ''', (application_id,))
        resume_row = cursor.fetchone()

        if not resume_row or not resume_row[0]:
            await query.answer("No CV available for this applicant.", show_alert=True)
            return

        resume_path = resume_row[0]  # File path or file ID
        applicant_name = f"{resume_row[1]} {resume_row[2]}"  # First Name + Last Name

        # Send the CV as a document with a personalized caption
        await context.bot.send_document(
            chat_id=query.message.chat_id,
            document=resume_path,
            caption=f"Here is the requested CV for {applicant_name}.",
            reply_to_message_id=query.message.message_id
        )

        # Answer callback to remove spinner without changing buttons
        await query.answer()

    except Exception as e:
        logger.error(f"Error sending CV: {e}")
        await query.message.reply_text("An error occurred while sending the CV. Please try again later.")

    finally:
        if conn:
            cursor.close()
            conn.close()


from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import CallbackContext
import psycopg2
import logging

logger = logging.getLogger(__name__)

async def shortlist_applicant(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    application_id = query.data.split("_")[-1]  # Extract application ID

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Check the current status
        cursor.execute('SELECT status FROM applications WHERE application_id = %s', (application_id,))
        current_status = cursor.fetchone()[0]

        # Determine new status
        if current_status == 'shortlisted':
            new_status = 'pending'
            cursor.execute('UPDATE applications SET status = %s WHERE application_id = %s', (new_status, application_id))
        else:
            new_status = 'shortlisted'
            cursor.execute('''
                UPDATE applications
                SET status = %s, hired_date = NULL, rejected_date = NULL
                WHERE application_id = %s
            ''', (new_status, application_id))

        conn.commit()

        # Fetch the updated status after commit
        cursor.execute('SELECT status FROM applications WHERE application_id = %s', (application_id,))
        updated_status = cursor.fetchone()[0]

        # Fetch applicant and job details for notification
        cursor.execute('''
            SELECT u.contact, u.first_name, u.last_name, jp.job_title, jp.channel_username, jp.message_id, c.company_name
            FROM applications a
            JOIN users u ON a.user_id = u.user_id
            JOIN job_posts jp ON a.job_id = jp.job_id
            LEFT JOIN company_profiles c ON jp.user_id = c.user_id
            WHERE a.application_id = %s
        ''', (application_id,))
        applicant_data = cursor.fetchone()

        if applicant_data:
            applicant_contact, applicant_first_name, applicant_last_name, job_title, channel_username, message_id, company_name = applicant_data

            # Construct job link
            job_link = f"https://t.me/{channel_username.strip('@')}/{message_id}" if channel_username and message_id else "#"

            # Construct notification message
            notification_message = (
                    "🎯 <b>You’ve made it to the shortlist!</b>\n\n"
                    f"Dear <b>{applicant_first_name} {applicant_last_name}</b>,\n\n"
                    f"We’re thrilled to inform you that you’re shortlisted for the "
                    f"<a href='{job_link}'>{job_title}</a> role"
                    + (f" at <b>{company_name}</b>" if company_name else "")  # Add company name dynamically
                    + "!\n\n"
                      "You’ll be hearing from the employer shortly. Congratulations and all the best moving forward!"
            )

            # Send the message to the applicant
            if applicant_contact:
                try:
                    await context.bot.send_message(
                        chat_id=applicant_contact,
                        text=notification_message,
                        parse_mode="HTML"
                    )
                except Exception as notify_error:
                    logger.warning(f"Could not notify applicant {applicant_contact}: {notify_error}")

        # Update inline keyboard based on the new status
        shortlist_label = "Shortlist ✔️" if updated_status == "shortlisted" else "Shortlist"
        hire_label = "Hire" if updated_status != "hired" else "Hired ✅"
        reject_label = "Reject" if updated_status != "rejected" else "Rejected ❌"

        # Inline keyboard reflecting only one active status icon
        updated_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("Application Message", callback_data=f"view_app_message_{application_id}")],
            [InlineKeyboardButton("View Profile", callback_data=f"view_app_profile_{application_id}")],
            [InlineKeyboardButton("Chat", callback_data=f"start_chat_{application_id}")],
            [InlineKeyboardButton(shortlist_label, callback_data=f"shortlist_{application_id}")],
            [InlineKeyboardButton(hire_label, callback_data=f"hire_{application_id}")],
            [InlineKeyboardButton(reject_label, callback_data=f"reject_{application_id}")]
        ])

        await query.message.edit_reply_markup(reply_markup=updated_keyboard)
        await query.answer("Status updated.", show_alert=True)

    except Exception as e:
        logger.error(f"Error updating shortlist status: {e}")
        await query.answer("Failed to update shortlist status.", show_alert=True)

    finally:
        if conn:
            cursor.close()
            conn.close()

async def validate_shortlisted_input(update: Update, context: CallbackContext) -> int:
    """
    Validates user input and reminds them to use the buttons if the input is not recognized.
    """
    await update.message.reply_text(
        "⚠️ Invalid input. Kindly choose one of the options provided by clicking the appropriate button."
    )
    return VIEW_SHORTLISTED_STATE  # Stay in the current state


async def view_shortlisted_applicants(update: Update, context: CallbackContext) -> int:
    employer_contact = update.effective_user.id  # Employer's chat ID

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch all jobs posted by this employer
        cursor.execute('''
            SELECT job_posts.job_id, job_posts.job_title 
            FROM job_posts
            JOIN users ON job_posts.user_id = users.user_id
            WHERE users.contact = %s
        ''', (str(employer_contact),))
        jobs = cursor.fetchall()

        if not jobs:
            await update.message.reply_text("You have not posted any jobs yet.")
            return JOB_MANAGEMENT

        # Fetch all shortlisted applicants for these jobs
        cursor.execute('''
            SELECT users.user_id, users.first_name, users.last_name, users.gender, 
                   job_posts.job_title, applications.application_id
            FROM applications
            JOIN users ON applications.user_id = users.user_id
            JOIN job_posts ON applications.job_id = job_posts.job_id
            WHERE job_posts.user_id = (SELECT user_id FROM users WHERE contact = %s)
              AND applications.status = 'shortlisted'
        ''', (str(employer_contact),))
        shortlisted_applicants = cursor.fetchall()

    except Exception as e:
        logger.error(f"Error retrieving shortlisted applicants: {e}")
        await update.message.reply_text("An error occurred while retrieving shortlisted applicants.")
        return JOB_MANAGEMENT

    finally:
        if conn:
            cursor.close()
            conn.close()

    if shortlisted_applicants:
        response = ""
        current_job_title = None

        for applicant in shortlisted_applicants:
            user_id, first_name, last_name, gender, job_title, application_id = applicant

            # Determine gender icon based on user gender
            gender_icon = {
                "male": "👨🏾",
                "female": "👩🏾",
            }.get(gender.lower(), "⚥")  # Default to ⚥ for unknown/other genders

            # Group shortlisted applicants under their respective job titles
            if current_job_title != job_title:
                # Send previous job group if response isn't empty
                if response.strip():
                    await update.message.reply_text(
                        response.strip(),
                        parse_mode='MarkdownV2'
                    )
                response = f"\n*📌 Job Title: {escape_markdown_v2(job_title)}*\n"
                current_job_title = job_title

            response += f"\n {gender_icon} *Name:* *{escape_markdown_v2(first_name)} {escape_markdown_v2(last_name)}*\n"

            # Inline buttons for each shortlisted applicant
            buttons = InlineKeyboardMarkup([
                [InlineKeyboardButton("Application Message", callback_data=f"view_shortlisted_app_message_{application_id}")],
                [InlineKeyboardButton("View Profile", callback_data=f"view_shortlisted_profile_{application_id}")],
                [InlineKeyboardButton("Chat", callback_data=f"start_chat_{application_id}")],
                [InlineKeyboardButton("Hire", callback_data=f"hire_shortlisted_{application_id}")],
                [InlineKeyboardButton("Remove from Shortlist", callback_data=f"remove_shortlist_{application_id}")]
            ])
            await update.message.reply_text(
                response.strip(),
                reply_markup=buttons,
                parse_mode='MarkdownV2'
            )
            response = ""  # Reset response after sending applicant details

        # Send any remaining grouped shortlisted applicants
        if response.strip():
            await update.message.reply_text(
                response.strip(),
                parse_mode='MarkdownV2'
            )

        # Add "🔙 Back to Menu" button at the end
        await update.message.reply_text(
            "Would you like to return to the menu?",
            reply_markup=ReplyKeyboardMarkup(
                [["🔙 Back"]],
                resize_keyboard=True
            )
        )
        return VIEW_SHORTLISTED_STATE  # Stay in the shortlisted viewing state

    else:
        await update.message.reply_text(
            "No shortlisted applicants found for your jobs.",
            reply_markup=ReplyKeyboardMarkup(
                [["🔙 Back to Menu"]],
                resize_keyboard=True
            )
        )
        return VIEW_SHORTLISTED_STATE



import logging
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import CallbackContext
import psycopg2
from telegram.constants import ParseMode
from datetime import datetime, date
import ast  # For safely parsing list-like strings

logger = logging.getLogger(__name__)

def escape_markdown_v2(text):
    """Escape Markdown V2 special characters."""
    escape_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!', '\\']
    if text:
        for char in escape_chars:
            text = text.replace(char, f"\\{char}")
    return text


def calculate_age(dob):
    """Calculate age from a date of birth (datetime.date or str)."""
    if not dob:
        return "N/A"
    if isinstance(dob, str):
        try:
            dob = datetime.strptime(dob, '%Y-%m-%d').date()
        except ValueError:
            return "Invalid Date"
    elif not isinstance(dob, date):
        return "N/A"
    today = date.today()
    return f"{today.year - dob.year - ((today.month, today.day) < (dob.month, dob.day))} years"

def format_list_field(value, icon):
    """Format list-like fields to remove brackets and display items cleanly."""
    try:
        items = ast.literal_eval(value) if isinstance(value, str) else value
        return "\n\n".join([f"{icon} {escape_markdown_v2(item.strip())}" for item in items if item.strip()])
    except (ValueError, SyntaxError):
        return f"{icon} {escape_markdown_v2(value.strip())}"  # Fallback for single values

def add_section(title, fields):
    """Add a dynamic section if there are valid fields."""
    section_content = "\n".join(filter(None, fields)).strip()
    return f"*{title}*\n\n{section_content}\n" if section_content else ""

async def handle_view_shortlisted_profile(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    application_id = int(query.data.split("_")[-1])

    logger.info(f"Fetching profile for shortlisted application_id: {application_id}")

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        cursor.execute('''
            SELECT ap.full_name, ap.job_title, ap.experience_level, ap.skills, ap.location, ap.phone_number, ap.email, 
                   ap.work_experience, ap.highest_degree, ap.university, ap.college, ap.graduation_year, ap.gpa, 
                   ap.certifications, ap.languages, ap.portfolio_link, ap.dob, ap.gender, ap.employment_type, 
                   ap.availability, a.user_id
            FROM applications a
            JOIN applicant_profiles ap ON a.user_id = ap.user_id
            WHERE a.application_id = %s
        ''', (application_id,))
        profile_data = cursor.fetchone()

        if not profile_data:
            logger.warning(f"No profile found for application_id: {application_id}")
            await query.answer("Applicant profile not found.", show_alert=True)
            return VIEW_SHORTLISTED_STATE

        (full_name, job_title, experience_level, skills, location, phone_number, email,
         work_experience, highest_degree, university, college, graduation_year, gpa,
         certifications, languages, portfolio_link, dob, gender, employment_type, availability, user_id) = profile_data

        # Adjust handling of portfolio_link
        if isinstance(portfolio_link, list):
            portfolio_links = "\n\n".join([f"🔗 {escape_markdown_v2(link.strip())}" for link in portfolio_link if link.strip()])
        elif isinstance(portfolio_link, str):
            portfolio_links = "\n\n".join([f"🔗 {escape_markdown_v2(link.strip())}" for link in portfolio_link.split(",") if link.strip()])
        else:
            portfolio_links = ""

        # Prepend '+' to phone number if it's missing
        formatted_phone_number = f"+{phone_number}" if not phone_number.startswith('+') else phone_number

        sections = filter(None, [
            add_section("Personal Information", [
                f"{'👨🏾' if gender.strip().lower() == 'male' else '👩🏾'} *Full Name:* {escape_markdown_v2(full_name)}",
                f"\n🎂 *Age:* {escape_markdown_v2(str(calculate_age(dob)))}" if dob else "",
                f"\n📞 *Phone:* [{escape_markdown_v2(formatted_phone_number)}](tel:{formatted_phone_number})" if phone_number else "",
                f"\n✉️ *Email:* {escape_markdown_v2(email)}" if email else "",
                f"\n📍 *Location:* {escape_markdown_v2(location)}" if location else ""
            ]),
            add_section("Professional Overview", [
                f"💼 *Job Title:* {escape_markdown_v2(job_title)}" if job_title else "",
                f"\n📊 *Experience Level:* {escape_markdown_v2(experience_level)}" if experience_level else "",
                f"\n🕒 *Employment Type:* {escape_markdown_v2(employment_type)}" if employment_type else "",
                f"\n📅 *Availability:* {escape_markdown_v2(availability)}" if availability else ""
            ]),

            add_section("Work Experience", [f"🏢 {escape_markdown_v2(work_experience)}" if work_experience else ""]),
            add_section("Education", [
                f"🎓 *Degrees:* {escape_markdown_v2(highest_degree)}" if highest_degree else "",
                f"\n🏫 *University:* {escape_markdown_v2(university)}" if university else "",
                f"\n🏛️ *College:* {escape_markdown_v2(college)}" if college else "",
                f"\n📅 *Graduation Year:* {escape_markdown_v2(graduation_year)}" if graduation_year else "",
                f"\n📊 *GPA:* {escape_markdown_v2(gpa)}" if gpa else ""
            ]),
            add_section("Certifications", [format_list_field(certifications, "📜") if certifications else ""]),
            add_section("Languages", [format_list_field(languages, "🌐") if languages else ""]),
            add_section("Skills", [format_list_field(skills, "🛠️") if skills else ""]),
            add_section("Portfolio Links", [portfolio_links])
        ])

        profile_info = "\n\n".join(sections)

        await query.message.edit_text(
            profile_info,
            parse_mode='MarkdownV2',
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("Back", callback_data=f"back_to_shortlisted_{application_id}")]
            ])
        )
        await query.answer()  # Remove spinner

    except Exception as e:
        logger.error(f"Error fetching profile for application_id {application_id}: {e}")
        await query.message.edit_text("An error occurred while retrieving the profile.")
    finally:
        if conn:
            cursor.close()
            conn.close()

    return VIEW_SHORTLISTED_STATE


async def handle_shortlisted_application_message(update: Update, context: CallbackContext) -> int:
    """Show the application message and details for shortlisted applicants."""
    query = update.callback_query
    application_id = query.data.split("_")[-1]  # Extract the application ID from callback data

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve application details and resume based on the application_id
        cursor.execute('''
            SELECT applications.application_message, applications.portfolio_links, 
                   applicant_profiles.resume
            FROM applications
            JOIN applicant_profiles ON applications.user_id = applicant_profiles.user_id
            WHERE applications.application_id = %s
        ''', (application_id,))
        application_row = cursor.fetchone()

        if not application_row:
            await query.answer("Application details not found.", show_alert=True)
            return VIEW_SHORTLISTED_STATE

        application_message, portfolio_links, resume = application_row

        # Check for CV attachment
        attachments = "CV attached" if resume else "No CV provided"

        # Construct the detailed application message
        response_text = (
            f"*📩Applicant Message:* {escape_markdown_v2(application_message) or 'No message provided'}\n\n"
            f"*🌐Portfolio Links:* {escape_markdown_v2(portfolio_links) or 'No links provided'}\n\n"
            f"*📂Attachments:* {escape_markdown_v2(attachments)}"
        )

        # Build the inline keyboard
        buttons = [
            [InlineKeyboardButton("Back", callback_data=f"back_to_shortlisted_{application_id}")],
        ]
        if resume:
            buttons.append([InlineKeyboardButton("Download CV", callback_data=f"download_cv_{application_id}")])

        # Edit the message to display the application details
        await query.message.edit_text(
            response_text,
            parse_mode='MarkdownV2',
            reply_markup=InlineKeyboardMarkup(buttons)
        )
        await query.answer()  # Remove the loading spinner

    except Exception as e:
        logger.error(f"Error fetching application details for application_id {application_id}: {e}")
        await query.message.reply_text("An error occurred while retrieving the application details.")
        return VIEW_SHORTLISTED_STATE

    finally:
        if conn:
            cursor.close()
            conn.close()

    return VIEW_SHORTLISTED_STATE


from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import CallbackContext
import psycopg2
import logging

logger = logging.getLogger(__name__)

async def handle_hire_shortlisted_applicant(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    application_id = query.data.split("_")[-1]

    try:
        conn = psycopg2.connect(dbname="my_project_db", user="postgres", password="1201", host="localhost", port="5432")
        cursor = conn.cursor()

        # Check the current status
        cursor.execute('SELECT status FROM applications WHERE application_id = %s', (application_id,))
        current_status = cursor.fetchone()[0]

        if current_status == 'hired':
            # Politely inform the employer that they cannot change the status
            await query.answer("This applicant has already been hired. Status changes are not allowed.", show_alert=True)
            return

        # Update to 'hired' status
        new_status = 'hired'
        cursor.execute('UPDATE applications SET status = %s, hired_date = NOW() WHERE application_id = %s',
                       (new_status, application_id))
        conn.commit()

        # Fetch applicant and employer details
        cursor.execute('''
            SELECT u.contact, u.first_name, u.last_name, jp.job_title, jp.channel_username, jp.message_id
            FROM applications a
            JOIN users u ON a.user_id = u.user_id
            JOIN job_posts jp ON a.job_id = jp.job_id
            WHERE a.application_id = %s
        ''', (application_id,))
        applicant_data = cursor.fetchone()
        applicant_contact, applicant_first_name, applicant_last_name, job_title, channel_username, message_id = applicant_data

        cursor.execute('''
            SELECT c.company_name, u.first_name AS employer_name, u.phone_number AS employer_phone
            FROM job_posts jp
            JOIN users u ON jp.user_id = u.user_id
            LEFT JOIN company_profiles c ON c.user_id = u.user_id
            WHERE jp.job_id = (SELECT job_id FROM applications WHERE application_id = %s)
        ''', (application_id,))
        employer_data = cursor.fetchone()
        company_name, employer_name, employer_phone = employer_data

        # Construct job link
        job_link = f"https://t.me/{channel_username.strip('@')}/{message_id}" if channel_username and message_id else "#"

        if applicant_contact:
            notification_message = (
                    "🎉 <b>Welcome aboard!</b>\n\n"
                    f"Hi <b>{applicant_first_name} {applicant_last_name}</b>,\n\n"
                    f"We’re thrilled to let you know that you’ve been hired for the "
                    f"<a href='{job_link}'>{job_title}</a> position"
                    + (f" at <b>{company_name}</b>" if company_name else "")  # Add company name dynamically
                    + "!\n\n"
                      "Here’s who you’ll be working with:\n"
                      f"\n👤 <b>Employer Name:</b> {employer_name}"
                    + (
                        f"\n\n🏢 <b>Company Name:</b> {company_name}" if company_name else "")  # Add company name line dynamically
                    + "\n\nYour employer will reach out to coordinate the next steps. Congrats again!"
            )

            try:
                await context.bot.send_message(
                    chat_id=applicant_contact,
                    text=notification_message,
                    parse_mode="HTML"
                )
            except Exception as notify_error:
                logger.warning(f"Could not notify applicant {applicant_contact}: {notify_error}")

        # Update inline keyboard for employer
        updated_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("Close Job", callback_data=f"close_job_{application_id}")],
            [InlineKeyboardButton("Keep Job Open", callback_data=f"keep_open_{application_id}")]
        ])

        await query.message.edit_reply_markup(reply_markup=updated_keyboard)
        await query.answer("Applicant successfully hired.", show_alert=True)

    except Exception as e:
        logger.error(f"Error updating hire status for shortlisted applicant: {e}")
        await query.answer("Failed to update hire status.", show_alert=True)

    finally:
        if conn:
            cursor.close()
            conn.close()

from telegram import InlineKeyboardButton, InlineKeyboardMarkup
import psycopg2
import logging

logger = logging.getLogger(__name__)

async def handle_finalize_job_action(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    application_id = query.data.split("_")[-1]

    try:
        conn = psycopg2.connect(dbname="my_project_db", user="postgres", password="1201", host="localhost", port="5432")
        cursor = conn.cursor()

        # Get job_id and application status from the applications table
        cursor.execute('SELECT job_id, status FROM applications WHERE application_id = %s', (application_id,))
        result = cursor.fetchone()
        if not result:
            await query.answer("Job or application not found.", show_alert=True)
            return

        job_id, current_status = result

        # Update job status to closed in job_posts
        cursor.execute('UPDATE job_posts SET status_id = 6 WHERE job_id = %s', (job_id,))
        conn.commit()

        # Determine button labels based on the current application status
        hire_label = "Hired ✅" if current_status == "hired" else "Hire"

        # Updated keyboard without close/open buttons
        updated_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("Application Message", callback_data=f"view_shortlisted_app_message_{application_id}")],
            [InlineKeyboardButton("View Profile", callback_data=f"view_shortlisted_profile_{application_id}")],
            [InlineKeyboardButton("Chat", callback_data=f"start_chat_{application_id}")],
            [InlineKeyboardButton(hire_label, callback_data=f"hire_shortlisted_{application_id}")]
        ])

        await query.message.edit_reply_markup(reply_markup=updated_keyboard)
        await query.answer("Job successfully finalized.", show_alert=True)

    except Exception as e:
        logger.error(f"Error finalizing job action: {e}")
        await query.answer("Failed to finalize job action.", show_alert=True)

    finally:
        if conn:
            cursor.close()
            conn.close()

async def handle_keep_job_active(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    application_id = query.data.split("_")[-1]

    try:
        conn = psycopg2.connect(dbname="my_project_db", user="postgres", password="1201", host="localhost", port="5432")
        cursor = conn.cursor()

        # Get current application status from the applications table
        cursor.execute('SELECT status FROM applications WHERE application_id = %s', (application_id,))
        current_status = cursor.fetchone()
        if not current_status:
            await query.answer("Application not found.", show_alert=True)
            return

        current_status = current_status[0]  # Extract status from result

        # Determine button labels based on the current application status
        hire_label = "Hired ✅" if current_status == "hired" else "Hire"

        # Updated keyboard without close/open buttons
        updated_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("Application Message", callback_data=f"view_shortlisted_app_message_{application_id}")],
            [InlineKeyboardButton("View Profile", callback_data=f"view_shortlisted_profile_{application_id}")],
            [InlineKeyboardButton("Chat", callback_data=f"start_chat_{application_id}")],
            [InlineKeyboardButton(hire_label, callback_data=f"hire_shortlisted_{application_id}")]
        ])

        await query.message.edit_reply_markup(reply_markup=updated_keyboard)
        await query.answer("Job will remain active.", show_alert=True)

    except Exception as e:
        logger.error(f"Error keeping job active: {e}")
        await query.answer("Failed to keep job active.", show_alert=True)

    finally:
        if conn:
            cursor.close()
            conn.close()


async def back_to_shortlisted(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    application_id = int(query.data.split("_")[-1])  # Extract application_id from callback data

    logging.info(f"Fetching shortlisted applicant details for application_id: {application_id}")

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id, job details, and application status for the shortlisted applicant
        cursor.execute('''
            SELECT users.user_id, users.first_name, users.last_name, users.gender, 
                   job_posts.job_title, applications.status
            FROM applications
            JOIN users ON applications.user_id = users.user_id
            JOIN job_posts ON applications.job_id = job_posts.job_id
            WHERE applications.application_id = %s
        ''', (application_id,))
        applicant_row = cursor.fetchone()

        if not applicant_row:
            logging.warning(f"No shortlisted details found for application_id: {application_id}")
            await query.message.edit_text("Shortlisted applicant details not found.")
            return VIEW_SHORTLISTED_STATE

        user_id, first_name, last_name, gender, job_title, status = applicant_row

        # Determine gender icon
        gender_icon = "👨🏾" if gender.lower() == "male" else "👩🏾"

        # Build response text
        response_text = (
            f"*📌 Job Title: {escape_markdown_v2(job_title)}*\n"
            f"\n{gender_icon} *Name:* {escape_markdown_v2(first_name)} {escape_markdown_v2(last_name)}\n\n"
        )

        # Adjust button labels and visibility based on status
        hire_label = "Hired ✅" if status == "hired" else "Hire"
        buttons = [
            [InlineKeyboardButton("Application Message", callback_data=f"view_shortlisted_app_message_{application_id}")],
            [InlineKeyboardButton("View Profile", callback_data=f"view_shortlisted_profile_{application_id}")],
            [InlineKeyboardButton("Chat", callback_data=f"start_chat_{application_id}")],
            [InlineKeyboardButton(hire_label, callback_data=f"hire_shortlisted_{application_id}")]
        ]

        # Add "Remove from Shortlist" button only if not hired
        if status != "hired":
            buttons.append([InlineKeyboardButton("Remove from Shortlist", callback_data=f"remove_shortlist_{application_id}")])

        # Edit the message to show the shortlisted applicant
        await query.message.edit_text(
            response_text,
            parse_mode='MarkdownV2',
            reply_markup=InlineKeyboardMarkup(buttons)
        )
        await query.answer()  # Remove the spinner

    except Exception as e:
        logging.error(f"Error fetching shortlisted details for application_id {application_id}: {e}")
        await query.message.edit_text("An error occurred while retrieving shortlisted details.")
    finally:
        if conn:
            cursor.close()
            conn.close()

    return VIEW_SHORTLISTED_STATE


async def handle_remove_shortlist(update: Update, context: CallbackContext) -> None:
    """Remove an applicant from the shortlist and delete the message."""
    query = update.callback_query
    application_id = query.data.split("_")[-1]  # Extract application ID from callback data

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Update the application status to 'pending' (removing from shortlist)
        cursor.execute('''
            UPDATE applications
            SET status = 'pending'
            WHERE application_id = %s
        ''', (application_id,))
        conn.commit()

        # Notify the user
        await query.answer("Removed from shortlist.", show_alert=True)

        # Delete the message from the chat
        await query.message.delete()

    except Exception as e:
        logger.error(f"Error removing from shortlist: {e}")
        await query.answer("Failed to remove from shortlist.", show_alert=True)

    finally:
        if conn:
            cursor.close()
            conn.close()


from datetime import datetime

async def hired_applicants(update: Update, context: CallbackContext) -> int:
    employer_contact = update.effective_user.id  # Employer's chat ID

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch hired applicants for the employer
        cursor.execute('''
            SELECT ap.full_name, ap.location, ap.phone_number, ap.email, 
                   ap.dob, ap.gender, jp.job_title, jp.channel_username, jp.message_id
            FROM applications a
            JOIN applicant_profiles ap ON a.user_id = ap.user_id
            JOIN job_posts jp ON a.job_id = jp.job_id
            WHERE a.status = 'hired' AND jp.user_id = (
                SELECT user_id FROM users WHERE contact = %s
            )
        ''', (str(employer_contact),))
        hired_applicants = cursor.fetchall()

        if not hired_applicants:
            await update.message.reply_text(
                "No hired applicants found.",
                reply_markup=ReplyKeyboardMarkup(
                    [["🔙 Back"]],
                    resize_keyboard=True
                )
            )
            return VIEW_APPLICANTS_STATE  # Redirect back to applications menu if no applicants are found

        # Iterate over each hired applicant and display their profile
        for full_name, location, phone_number, email, dob, gender, job_title, channel_username, message_id in hired_applicants:
            # Determine icons dynamically
            full_name_icon = "👨🏾" if gender.lower() == "male" else "👩🏾" if gender.lower() == "female" else "⚥"
            gender_icon = "♂️" if gender.lower() == "male" else "♀️" if gender.lower() == "female" else "⚥"

            # Ensure the phone number starts with "+"
            formatted_phone_number = (
                phone_number if phone_number.startswith("+") else f"+{phone_number}" if phone_number else "N/A"
            )

            # Safely calculate age from DOB
            if dob:
                dob_datetime = datetime(dob.year, dob.month, dob.day)
                age = f"{int((datetime.now() - dob_datetime).days / 365)} years"
            else:
                age = "N/A"

            # Strip @ from channel_username and construct the job link
            clean_channel_username = channel_username.lstrip('@') if channel_username else None
            if clean_channel_username and message_id:
                job_link = f"https://t.me/{clean_channel_username}/{message_id}"
                job_title_text = f"[{job_title}]({job_link})"  # Markdown hyperlink
            else:
                job_title_text = job_title or "N/A"

            # Construct the applicant profile
            applicant_profile = (
                f"{full_name_icon} *Full Name:* {full_name}\n\n"
                f"📍 *Location:* {location or 'N/A'}\n\n"
                f"📱 *Phone:* {formatted_phone_number}\n\n"
                f"✉️ *Email:* {email or 'N/A'}\n\n"
                f"📅 *Age:* {age}\n\n"
                f"{gender_icon} *Gender:* {gender.capitalize()}\n\n"
                f"📌 *Job Title:* {job_title_text}\n"
            )

            await update.message.reply_text(
                applicant_profile,
                parse_mode='Markdown'
            )

        # Add "🔙 Back to Menu" button after listing all hired applicants
        await update.message.reply_text(
            "Would you like to return to the menu?",
            reply_markup=ReplyKeyboardMarkup(
                [["🔙 Back"]],
                resize_keyboard=True
            )
        )
        return VIEW_APPLICANTS_STATE

    except Exception as e:
        logger.error(f"Error fetching hired applicants: {e}")
        await update.message.reply_text("An error occurred while fetching hired applicants.")
    finally:
        if conn:
            cursor.close()
            conn.close()

    return APPLICATIONS  # Redirect to the applications menu



from telegram import Update
from telegram.ext import CallbackContext
import psycopg2
import logging

logger = logging.getLogger(__name__)

async def contact_applicants(update: Update, context: CallbackContext) -> int:
    employer_id = update.effective_user.id

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch applicants along with the job title and channel post details
        cursor.execute('''
            SELECT a.application_id, u.first_name, u.last_name, u.phone_number, 
                   u.email, u.contact, jp.job_title, jp.channel_username, jp.message_id
            FROM applications a
            JOIN users u ON a.user_id = u.user_id
            JOIN job_posts jp ON a.job_id = jp.job_id
            WHERE jp.user_id = (
                SELECT user_id FROM users WHERE contact = %s::TEXT
            )
        ''', (str(employer_id),))
        applicants = cursor.fetchall()

        if not applicants:
            await update.message.reply_text(
                "No applicants found for your jobs.",
                reply_markup=ReplyKeyboardMarkup(
                    [["🔙 Back"]],
                    resize_keyboard=True
                )
            )
            return VIEW_APPLICANTS_STATE  # Updated return state

        for application_id, first_name, last_name, phone_number, email, contact_id, job_title, channel_username, message_id in applicants:
            formatted_phone_number = (
                phone_number if phone_number.startswith("+") else f"+{phone_number}"
            )
            clean_channel_username = channel_username.lstrip('@') if channel_username else "N/A"

            applicant_text = (
                f"👤 *{first_name} {last_name}*\n"
                f"\n📌 *Applied for:* [{job_title}](https://t.me/{clean_channel_username}/{message_id})\n"
                f"\n📱 *Phone:* [{formatted_phone_number}](tel:{formatted_phone_number})\n"
                f"\n✉️ *Email:* [{email}](mailto:{email})\n"
                f"\n💬 *Telegram:* [Click here](tg://user?id={contact_id})" if contact_id else "💬 *Telegram:* N/A"
            )

            await update.message.reply_text(
                applicant_text,
                parse_mode='Markdown'
            )

        # Add "🔙 Back to Menu" button after listing all applicants
        await update.message.reply_text(
            "Would you like to return to the menu?",
            reply_markup=ReplyKeyboardMarkup(
                [["🔙 Back"]],
                resize_keyboard=True
            )
        )
        return VIEW_APPLICANTS_STATE  # Updated return state

    except Exception as e:
        logger.error(f"Error fetching applicants: {e}")
        await update.message.reply_text("An error occurred while fetching applicants.")
    finally:
        if conn:
            cursor.close()
            conn.close()

    return CONTACT_APPLICANTS_STATE




# Function to handle applicant feedback
async def applicant_feedback(update: Update, context: CallbackContext) -> int:
    # Logic to gather feedback for an applicant
    job_id = context.user_data.get('job_id')  # Assuming job_id is stored in user_data
    applicant_name = context.user_data.get('applicant_name', 'Applicant Name')  # Example applicant

    # Prompt the user to provide feedback for the selected applicant
    await update.message.reply_text(
        f"Provide feedback for {applicant_name} (Job ID: {job_id}):",
        reply_markup=ReplyKeyboardMarkup([["Cancel"]], resize_keyboard=True)
    )

    return APPLICANT_FEEDBACK_STATE  # Define the state for handling feedback input

# Function to handle the input provided for feedback
async def handle_feedback_input(update: Update, context: CallbackContext) -> int:
    feedback = update.message.text

    if feedback.lower() == "cancel":
        return await show_employer_menu(update, context)

    # Store the feedback in the database or perform other necessary actions
    job_id = context.user_data.get('job_id')
    applicant_name = context.user_data.get('applicant_name', 'Applicant Name')

    # Example of saving the feedback (replace with actual database logic)
    print(f"Feedback for {applicant_name} (Job ID: {job_id}): {feedback}")

    await update.message.reply_text(f"Feedback submitted for {applicant_name}.")

    return EMPLOYER_MENU  # Return to the employer menu after submitting feedback


# Database connection setup
def get_db_connection():
    """
    Establish and return a database connection.
    """
    return psycopg2.connect(
        dbname="my_project_db",
        user="postgres",
        password="1201",
        host="localhost",  # or '127.0.0.1' or the actual host
        port="5432"  # default PostgreSQL port
    )

async def search_applicants(update: Update, context: CallbackContext) -> int:
    """
    Ask the employer to input keywords for searching applicants with a disclaimer.
    """
    await update.message.reply_text(
        "🔍 *Search Applicants*\n\n"
        "Please enter keywords to search for applicants registered on the platform \n*Afro Joblink*.\n\n"
        "⚠️ *Disclaimer:* This section is for searching all applicants registered on Afro Joblink. "
        "You are *not* searching only the applicants who have applied for your jobs.\n\n"
        "💡 *Example Keywords:*\n"
        "- `addis ababa`\n"
        "- `5+ years of experience in full-stack development`\n"
        "- `Bachelor's Degree`\n"
        "- `Adigrat University`\n"
        "- `3.40`\n\n"
        "🔍 *Example Input:*\n"
        "`addis ababa, 5+ years of experience in full-stack development, bachelor's degree, Adigrat University, 3.40`",
        parse_mode="Markdown",
        reply_markup=ReplyKeyboardMarkup(
            [["🔙 Back"]],  # Back button for navigation
            resize_keyboard=True
        )
    )
    return SEARCH_APPLICANTS_STATE  # Define a state to capture the search input



from telegram import ReplyKeyboardMarkup, InlineKeyboardMarkup, InlineKeyboardButton

async def process_search_keywords(update: Update, context: CallbackContext) -> int:
    """
    Process the employer's keywords and search the database for matching applicants.
    Stores the results and message data in context.user_data for later retrieval.

    This version addresses the potential skill and language mismatch issue by:
    - Adding explicit checks for skill and language matches within the search query.
    - Using `ILIKE` for case-insensitive matching.
    - Improving error handling and logging.
    - Displaying search results with additional information (location).

    Returns:
        SEARCH_APPLICANTS_STATE: An integer representing the state after processing keywords.
    """

    keywords = update.message.text.lower().strip()  # Normalize keyword input

    if keywords.lower() in ["🔙 back"]:
        return await handle_back_to_search_filter(update, context)

    keyword_list = [kw.strip() for kw in keywords.split(",")]

    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        conditions = []
        params = []
        for keyword in keyword_list:
            conditions.append("""
                (
                    job_title ILIKE %s
                    OR location ILIKE %s
                    OR EXISTS (SELECT 1 FROM UNNEST(skills) s WHERE s ILIKE %s)  -- Check for skill match
                    OR employment_type ILIKE %s
                    OR highest_degree ILIKE %s
                    OR university ILIKE %s
                    OR EXISTS (SELECT 1 FROM UNNEST(languages) l WHERE l ILIKE %s)  -- Check for language match
                    OR college ILIKE %s
                    OR CAST(gpa AS TEXT) ILIKE %s
                    OR gender ILIKE %s
                )
            """)
            params.extend([f"%{keyword}%" for _ in range(10)])

        search_query = f"""
            SELECT DISTINCT applicant_id, full_name, job_title, location
            FROM applicant_profiles
            WHERE opt_out_search = FALSE AND {' AND '.join([f"({cond})" for cond in conditions])}
            LIMIT 10;
        """
        cursor.execute(search_query, tuple(params))
        results = cursor.fetchall()

        if not results:
            await update.message.reply_text(
                "🤷🏾‍♂️ No applicants found matching your search criteria. Please try again.",
                reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
            )
            context.user_data["search_results"] = []
            context.user_data["message_data"] = {}
            return

        context.user_data["search_results"] = results
        context.user_data["message_data"] = {}  # Initialize to track message IDs and texts

        for result in results:
            applicant_id, full_name, job_title, location = result
            job_title_text = f" - {job_title}" if job_title else ""
            display_name = f"👤 {full_name}{job_title_text}\n\n📍 {location or 'N/A'}"
            buttons = [[InlineKeyboardButton("View Profile", callback_data=f"view_profile_global_{applicant_id}")],
                       [InlineKeyboardButton("Chat", callback_data=f"process_chat_with_applicant_{applicant_id}")]
                       ]
            sent_message = await update.message.reply_text(
                text=display_name,
                reply_markup=InlineKeyboardMarkup(buttons),
            )
            context.user_data["message_data"][sent_message.message_id] = display_name

    except Exception as e:
        await update.message.reply_text("An error occurred while searching for applicants.")
        logging.error(f"Error: {e}")
    finally:
        if conn:
            cursor.close()
            conn.close()

    return SEARCH_APPLICANTS_STATE



import re
import logging
from datetime import datetime
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import CallbackContext, ConversationHandler
import psycopg2
from PIL import Image


def escape_markdown_v2(text):
    """Escapes special characters for Telegram's MarkdownV2 syntax."""
    if not isinstance(text, str):
        text = str(text)
    return re.sub(r'([_*[\]()~>#+\-=|{}.!])', r'\\\1', text)


def format_field(field, default='N/A'):
    """Formats field values and escapes MarkdownV2 special characters."""
    if field is None:
        return default
    if isinstance(field, datetime):
        return field.strftime('%Y-%m-%d')
    return escape_markdown_v2(str(field))


def process_field(field):
    """Handles both list and string fields dynamically."""
    if isinstance(field, list):
        return ", ".join(escape_markdown_v2(str(item)) for item in field)
    elif isinstance(field, str):
        return ", ".join(escape_markdown_v2(item.strip()) for item in field.split(","))
    return escape_markdown_v2(str(field).strip())


def resize_image(image_path, output_path, max_size=(300, 300)):
    """Resize the image to the given max size and save it to the output path."""
    with Image.open(image_path) as img:
        img.thumbnail(max_size)
        img.save(output_path, format="JPEG")


async def handle_global_applicant_profile(update: Update, context: CallbackContext) -> None:
    """
    Handle the 'View Profile' button callback to show the full applicant profile inline,
    with a Back button to return to the list of searched applicants.
    """
    query = update.callback_query
    await query.answer()
    callback_data = query.data

    # Validate callback data
    if not callback_data.startswith("view_profile_global_") or not callback_data.split("_")[-1].isdigit():
        logging.error(f"Invalid callback data received: {callback_data}")
        await query.edit_message_text("Invalid callback data.")
        return

    applicant_id = int(callback_data.split("_")[-1])
    logging.info(f"Fetching profile for applicant_id: {applicant_id}")

    conn = None
    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch applicant profile
        cursor.execute('''
            SELECT full_name, job_title, location, phone_number, email, experience_level,
                   skills, employment_type, availability, work_experience, highest_degree,
                   university, college, graduation_year, gpa, certifications, languages,
                   portfolio_link, resume, profile_picture
            FROM applicant_profiles
            WHERE applicant_id = %s
        ''', (applicant_id,))
        profile_data = cursor.fetchone()

        if not profile_data:
            logging.warning(f"No profile found for applicant_id: {applicant_id}")
            await query.edit_message_text("Applicant profile not found.")
            return

        # Build the profile summary
        profile_info = "\n\n*Personal Information*\n\n"
        profile_info += f"👤 *Full Name:* {format_field(profile_data[0])}\n\n"
        if profile_data[1]:  # Job Title
            profile_info += f"🏷️ *Job Title:* {format_field(profile_data[1])}\n\n"
        profile_info += f"📍 *Location:* {format_field(profile_data[2])}\n\n"

        profile_info += f"✉️ *Email:* {format_field(profile_data[4])}\n"

        # Professional Overview
        professional_overview = "\n\n*Professional Overview*\n\n"
        if profile_data[5]:
            professional_overview += f"🥇 *Experience Level:* {format_field(profile_data[5])}\n\n"
        if profile_data[6]:
            professional_overview += f"🛠️ *Skills:* {process_field(profile_data[6])}\n\n"
        if profile_data[7]:
            professional_overview += f"⏳ *Employment Type:* {format_field(profile_data[7])}\n\n"
        if profile_data[8]:
            professional_overview += f"📅 *Availability:* {format_field(profile_data[8])}\n"
        profile_info += professional_overview

        # Education
        education = "\n\n*Education*\n\n"
        if profile_data[10]:
            education += f"🎓 *Degrees:* {format_field(profile_data[10])}\n\n"
        if profile_data[11]:
            education += f"🏫 *University:* {format_field(profile_data[11])}\n\n"
        if profile_data[12]:
            education += f"🏛️ *College:* {format_field(profile_data[12])}\n\n"
        if profile_data[13]:
            education += f"📅 *Graduation Year:* {format_field(profile_data[13])}\n\n"
        if profile_data[14]:
            education += f"📚 *GPA:* {format_field(profile_data[14])}\n"
        profile_info += education

        # Certifications
        if profile_data[15]:
            profile_info += f"\n\n*Certifications*\n📜 {process_field(profile_data[15])}\n"

        # Languages
        if profile_data[16]:
            profile_info += f"\n\n*Languages*\n🌐 {process_field(profile_data[16])}\n"

        # Portfolio Links
        if profile_data[17]:
            formatted_links = "\n\n".join(f"🔗 {escape_markdown_v2(link.strip())}" for link in profile_data[17].split(","))
            profile_info += f"\n\n*Portfolio Links*\n{formatted_links}\n"


        # Inline buttons (Back button)
        buttons = [
            [InlineKeyboardButton("🔙 Back", callback_data="back_to_applicants")],
            [InlineKeyboardButton("Chat", callback_data=f"process_chat_with_applicant_{applicant_id}")]
        ]

        # Edit the original message to show the profile inline with the Back button
        await query.edit_message_text(
            profile_info,
            parse_mode='MarkdownV2',
            reply_markup=InlineKeyboardMarkup(buttons)
        )

    except Exception as e:
        logging.error(f"Error retrieving profile: {e}")
        await query.edit_message_text("An error occurred while retrieving the profile.")
    finally:
        if conn:
            cursor.close()
            conn.close()


async def process_chat_with_applicant(update: Update, context: CallbackContext) -> None:
    """
    Handles the "Chat" button click for a specific applicant.
    Triggers a private chat with the applicant (if possible) or provides contact information.

    Note: This function assumes you have a mechanism to initiate private chats
    within your Telegram bot framework.
    """
    query = update.callback_query
    await query.answer()

    try:
        applicant_id = int(query.data.split("_")[-1])

        # **1. Attempt to start a private chat with the applicant (if possible)**
        # This part depends heavily on your specific Telegram bot framework.
        # Example (using `context.bot.get_chat`):
        try:
            chat_id = await context.bot.get_chat(user_id=applicant_id).id
            await context.bot.send_message(chat_id=chat_id, text="Hello, [Applicant Name]! How can I assist you?")
            await query.edit_message_text("Chat initiated with the applicant.")
            return

        except Exception as e:
            logging.warning(f"Failed to start private chat with applicant {applicant_id}: {e}")

        # **2. If private chat fails, provide contact information:**

        # Establish database connection
        conn = get_db_connection()
        cursor = conn.cursor()

        # Fetch user information linked to this applicant_id
        cursor.execute("""
            SELECT u.first_name, u.last_name, u.username, u.phone_number
            FROM applicant_profiles ap
            JOIN users u ON ap.user_id = u.user_id
            WHERE ap.applicant_id = %s
        """, (applicant_id,))
        applicant_row = cursor.fetchone()

        if not applicant_row:
            await query.edit_message_text("Applicant not found in the database.")
            return

        applicant_first_name, applicant_last_name, applicant_username, applicant_phone = applicant_row
        applicant_name = f"{applicant_first_name} {applicant_last_name}"

        # Generate contact information
        if applicant_username:
            applicant_contact_info = f"Telegram: [@{applicant_username}](https://t.me/{applicant_username})"
        else:
            # Ensure the phone number starts with a "+"
            formatted_phone = f"+{applicant_phone.lstrip('+')}" if applicant_phone else "N/A"
            applicant_contact_info = f"Phone: {formatted_phone}"

        # Combine contact details and caution message in a single response
        message_content = (
            f"👤 Contact {applicant_name}:\n\n"
            f"{applicant_contact_info}\n\n"
            "⚠️ <i>Please use this contact information professionally and in compliance with our platform's policies.</i>\n\n"
            "❌ <i>Any misuse of this information will result in the termination of your account.</i>"
        )

        # Display applicant contact details with caution message
        await query.edit_message_text(
            message_content,
            parse_mode="HTML",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("🔙 Back", callback_data="back_to_applicants")]
            ])
        )

    except Exception as e:
        logging.error(f"Error in process_chat_with_applicant: {e}")
        await query.edit_message_text("An error occurred while processing the chat request.")
    finally:
        if conn:
            cursor.close()
            conn.close()

async def handle_back_to_applicants(update: Update, context: CallbackContext) -> None:
    """
    Handle the 'Back to Applicants' button callback to redisplay the search results
    with location information.

    This version incorporates location details into the displayed applicant information.
    """
    query = update.callback_query
    await query.answer()

    logging.info("handle_back_to_applicants triggered.")  # Debug log

    # Retrieve saved search results and message data from context
    search_results = context.user_data.get("search_results", [])
    message_data = context.user_data.get("message_data", {})  # {message_id: text}

    logging.info(f"search_results: {search_results}")  # Debug log
    logging.info(f"message_data: {message_data}")      # Debug log

    if not search_results or not message_data:
        logging.warning("No search results or message data found.")
        await query.edit_message_text("No previous search results found.")
        return

    # Redisplay each applicant inline using the saved message IDs and content
    for message_id, (applicant_id, full_name, job_title, location) in zip(message_data.keys(), search_results):
        job_title_text = f" - {job_title}" if job_title else ""
        display_name = f"👤 {full_name}{job_title_text}\n\n📍 {location or 'N/A'}"
        buttons = [[InlineKeyboardButton("View Profile", callback_data=f"view_profile_global_{applicant_id}")],
                   [InlineKeyboardButton("Chat", callback_data=f"process_chat_with_applicant_{applicant_id}")]]
        new_text = display_name

        logging.info(f"Updating message {message_id} with text: {new_text}")  # Debug log

        try:
            await context.bot.edit_message_text(
                chat_id=query.message.chat_id,
                message_id=message_id,
                text=new_text,
                reply_markup=InlineKeyboardMarkup(buttons),
            )
        except Exception as e:
            logging.error(f"Error editing message {message_id}: {e}")




# Function to handle the input provided for applicant search
async def handle_search_input(update: Update, context: CallbackContext) -> int:
    search_query = update.message.text

    if search_query.lower() == "cancel":
        return await show_employer_menu(update, context)

    # Perform search in the database based on the input keywords
    conn = sqlite3.connect('job_posts.db')
    cursor = conn.cursor()

    # Example query to search for applicants based on skills (you can customize this query)
    cursor.execute('''
        SELECT name, skills, experience FROM applicants WHERE skills LIKE ? OR experience LIKE ?
    ''', (f"%{search_query}%", f"%{search_query}%"))

    results = cursor.fetchall()
    conn.close()

    # Handle case where no results are found
    if not results:
        await update.message.reply_text(f"🤷🏾‍♂️ No applicants found matching: {search_query}")
        return SEARCH_APPLICANTS_STATE

    # Format the search results
    result_text = "\n".join([f"Name: {row[0]}, Skills: {row[1]}, Experience: {row[2]}" for row in results])
    await update.message.reply_text(f"Search Results:\n\n{result_text}")

    return EMPLOYER_MENU  # Return to the employer menu after showing search results




# Database connection function (update with your credentials)
def get_db_connection():
    import psycopg2
    return psycopg2.connect(
        dbname="my_project_db",
        user="postgres",
        password="1201",
        host="localhost",
        port="5432"
    )

async def start_filtering(update: Update, context: CallbackContext) -> int:
    """
    Start the step-by-step filtering process by asking the first filter criterion with a disclaimer.
    """
    context.user_data["filtered_results"] = None  # Store intermediate results
    context.user_data["filters"] = []  # Track applied filters
    context.user_data["current_filter"] = None  # Track current filter

    await update.message.reply_text(
        "🔍 *Filter Applicants*\n\n"
        "This section allows you to search through *all applicants registered on the platform Afro Joblink*.\n\n"
        "⚠️ *Disclaimer:* You are *not* filtering only the applicants who have applied for your job postings. "
        "Instead, you are accessing the entire pool of talented candidates available on our platform.\n\n"
        "💡 *Available Filtering Criteria:*\n"
        "- `Skills`\n"
        "- `Location`\n"
        "- `Experience Level`\n"
        "- `Gender`\n"
        "- `Employment Type`\n"
        "- `Degrees`\n"
        "- `University`\n"
        "- `Graduation Year`\n"
        "- `College`\n"
        "- `GPA`\n"
        "- `Language`\n\n"
        "🔍 *Example Input for Filters:*\n"
        "- `Skills: Python, Java`\n"
        "- `GPA: 3.4`\n"
        "- `Graduation Year: 2014`\n\n"
        "✅ *How to Narrow Down Your Search:*\n"
        "Choose specific criteria from the buttons below to refine your search and find the most suitable candidates based on your requirements.\n\n"
        "What criteria would you like to filter by first?",
        parse_mode="Markdown",
        reply_markup=ReplyKeyboardMarkup(
            [
                ["💪🏿 Skills", "📍 Location"],
                ["🎖️ Experience Level", "🚻 Gender"],
                ["💼 Employment Type", "🎓 Degree"],
                ["🏫 University", "📅 Graduation Year"],
                ["🏛️ College", "📚 GPA"],
                ["🗣️ Language", "🔙 Back to Menu"],

            ],
            resize_keyboard=True
        )
    )
    return FILTER_APPLICATIONS_STATE  # Define a state to capture filter selection


async def handle_back_to_search_filter(update: Update, context: CallbackContext) -> int:
    """
    Handle the 'Back to Menu' button to return the user to the Search & Filter menu.
    Clears context.user_data.
    """
    # Clear all user data in context
    context.user_data.clear()

    # Redirect to Search & Filter menu
    await update.message.reply_text(
        "Search & Filter: Please choose an action.",
        reply_markup=ReplyKeyboardMarkup([
            ["🔍 Search Applicants", "🔬 Filter Applicants"],
            ["🔙 Back"]
        ], resize_keyboard=True)
    )
    return SEARCH_FILTER


async def select_filter(update: Update, context: CallbackContext) -> int:
    """
    Capture the selected filter and prompt the user for input.
    """
    selected_filter = update.message.text.strip().lower()

    # Handle "Back" button
    if selected_filter == "🔙 back":
        context.user_data.clear()  # Clear context data when starting over
        await start_filtering(update, context)
        return FILTER_APPLICATIONS_STATE

    # Handle "Back to Menu" button
    if selected_filter == "🔙 back to menu":
        context.user_data.clear()  # Clear context data
        await update.message.reply_text(
            "Search & Filter: Please choose an action.",
            reply_markup=ReplyKeyboardMarkup([
                ["🔍 Search Applicants", "🔬 Filter Applicants"],
                ["🔙 Back"]
            ], resize_keyboard=True)
        )
        return SEARCH_FILTER


    # Define valid filters
    valid_filters = {
        "💪🏿 skills": "💪🏿 skills",
        "📍 location": "📍 location",
        "🎖 experience level": "🎖️ experience level",
        "🚻 gender": "🚻 gender",
        "💼 employment type": "💼 employment type",
        "🎓 degree": "🎓 degree",
        "🏫 university": "🏫 university",
        "📅 graduation year": "📅 graduation year",
        "🏛️ college": "🏛️ college",
        "📚 gpa": "📚 gpa",
        "🗣️ language": "🗣️ language"  # Added language as a filter option
    }

    # Check if the selected filter is valid
    if selected_filter not in valid_filters.values():
        await update.message.reply_text("⚠️ Invalid filter selected. Please choose a valid filter.")
        return FILTER_APPLICATIONS_STATE
    # Save the selected filter
    context.user_data["current_filter"] = selected_filter

    # Special cases for filters requiring predefined options
    if selected_filter == "🏫 university":
        try:
            # Connect to the PostgreSQL database
            conn = psycopg2.connect(
                dbname="my_project_db",
                user="postgres",
                password="1201",
                host="localhost",
                port="5432"
            )
            cursor = conn.cursor()

            # Fetch the list of universities from the universities table
            cursor.execute("SELECT university_name FROM universities ORDER BY university_name ASC;")
            universities = [row[0] for row in cursor.fetchall()]

            if not universities:
                # If no universities are found, send an appropriate message
                await update.message.reply_text(
                    "No universities are available at the moment. Please try another filter.",
                     )
                return FILTER_APPLICATIONS_STATE

            # Split the list into rows for the keyboard layout
            university_buttons = [universities[i:i + 2] for i in range(0, len(universities), 2)]

            # Send the dynamic list of universities to the user
            await update.message.reply_text(
                "Please select a university from the options below:",
                reply_markup=ReplyKeyboardMarkup(university_buttons, resize_keyboard=True)
            )
            return FILTER_CRITERIA_STATE

        except (Exception, psycopg2.DatabaseError) as error:
            logger.error(f"Database error while fetching universities: {error}")
            await update.message.reply_text(
                "An error occurred while fetching universities. Please try again later.",
                     )
            return FILTER_APPLICATIONS_STATE

        finally:
            if conn:
                cursor.close()
                conn.close()

    if selected_filter == "🏛️ college":
        try:
            # Connect to the PostgreSQL database
            conn = psycopg2.connect(
                dbname="my_project_db",
                user="postgres",
                password="1201",
                host="localhost",
                port="5432"
            )
            cursor = conn.cursor()

            # Fetch the list of colleges from the colleges table
            cursor.execute("SELECT college_name FROM colleges ORDER BY college_name ASC;")
            colleges = [row[0] for row in cursor.fetchall()]

            if not colleges:
                # If no colleges are found, send an appropriate message
                await update.message.reply_text(
                    "No colleges are available at the moment. Please try another filter.",
                      )
                return FILTER_APPLICATIONS_STATE

            # Split the list into rows for the keyboard layout
            college_buttons = [colleges[i:i + 2] for i in range(0, len(colleges), 2)]

            # Send the dynamic list of colleges to the user
            await update.message.reply_text(
                "Please select a college from the options below:",
                reply_markup=ReplyKeyboardMarkup(college_buttons, resize_keyboard=True)
            )
            return FILTER_CRITERIA_STATE

        except (Exception, psycopg2.DatabaseError) as error:
            logger.error(f"Database error while fetching colleges: {error}")
            await update.message.reply_text(
                "An error occurred while fetching colleges. Please try again later.",
                    )
            return FILTER_APPLICATIONS_STATE

        finally:
            if conn:
                cursor.close()
                conn.close()

    if selected_filter == "🚻 gender":
        gender_buttons = [["Male"], ["Female"]]
        await update.message.reply_text(
            "Please select a gender to filter by:",
            reply_markup=ReplyKeyboardMarkup(gender_buttons, resize_keyboard=True)
        )
        return FILTER_CRITERIA_STATE

    if selected_filter == "📍 location":
        try:
            # Connect to the PostgreSQL database
            conn = psycopg2.connect(
                dbname="my_project_db",
                user="postgres",
                password="1201",
                host="localhost",
                port="5432"
            )
            cursor = conn.cursor()

            # Fetch the list of city names from the locations table
            cursor.execute("SELECT city_name FROM locations ORDER BY city_name ASC;")
            cities = [row[0] for row in cursor.fetchall()]

            if not cities:
                # If no cities are found, send an appropriate message
                await update.message.reply_text(
                    "No cities are available at the moment. Please try another filter.",
                        )
                return FILTER_APPLICATIONS_STATE

            # Split the list into rows for the keyboard layout
            city_buttons = [cities[i:i + 2] for i in range(0, len(cities), 2)]

            # Send the dynamic list of cities to the user
            await update.message.reply_text(
                "Please select a location from the options below:",
                reply_markup=ReplyKeyboardMarkup(city_buttons, resize_keyboard=True)
            )
            return FILTER_CRITERIA_STATE

        except (Exception, psycopg2.DatabaseError) as error:
            logger.error(f"Database error while fetching cities: {error}")
            await update.message.reply_text(
                "An error occurred while fetching cities. Please try again later.",

            )
            return FILTER_APPLICATIONS_STATE

        finally:
            if conn:
                cursor.close()
                conn.close()

    if selected_filter == "💼 employment type":
        try:
            # Connect to the PostgreSQL database
            conn = psycopg2.connect(
                dbname="my_project_db",
                user="postgres",
                password="1201",
                host="localhost",
                port="5432"
            )
            cursor = conn.cursor()

            # Fetch the list of job types from the job_types table
            cursor.execute("SELECT job_type_name FROM job_types ORDER BY job_type_name ASC;")
            job_types = [row[0] for row in cursor.fetchall()]

            if not job_types:
                # If no job types are found, send an appropriate message
                await update.message.reply_text(
                    "No employment types are available at the moment. Please try another filter.",

                )
                return FILTER_APPLICATIONS_STATE

            # Split the list into rows for the keyboard layout
            employment_type_buttons = [job_types[i:i + 2] for i in range(0, len(job_types), 2)]

            # Send the dynamic list of employment types to the user
            await update.message.reply_text(
                "Please select an employment type from the options below:",
                reply_markup=ReplyKeyboardMarkup(employment_type_buttons, resize_keyboard=True)
            )
            return FILTER_CRITERIA_STATE

        except (Exception, psycopg2.DatabaseError) as error:
            logger.error(f"Database error while fetching employment types: {error}")
            await update.message.reply_text(
                "An error occurred while fetching employment types. Please try again later.",

            )
            return FILTER_APPLICATIONS_STATE

        finally:
            if conn:
                cursor.close()
                conn.close()

    if selected_filter == "📚 gpa":
        gpa_buttons = [
            ["2.0-2.5", "2.5-3.0"],
            ["3.0-3.5", "3.5-4.0"],
            [">2.0", ">3.0"],
        ]
        await update.message.reply_text(
            "Please select a GPA range from the options below:",
            reply_markup=ReplyKeyboardMarkup(gpa_buttons, resize_keyboard=True)
        )
        return FILTER_CRITERIA_STATE

    if selected_filter == "🎓 degree":

            """
            Filters applications based on the selected degree (education level).
            """
            try:
                # Connect to the PostgreSQL database
                conn = psycopg2.connect(
                    dbname="my_project_db",
                    user="postgres",
                    password="1201",
                    host="localhost",
                    port="5432"
                )
                cursor = conn.cursor()

                # Fetch the list of degrees (education levels) from the education_levels table
                cursor.execute("SELECT education_level_name FROM education_levels ORDER BY education_level_name ASC;")
                degrees = [row[0] for row in cursor.fetchall()]

                if not degrees:
                    # If no degrees are found, send an appropriate message
                    await update.message.reply_text(
                        "No education levels are available at the moment. Please try another filter.",

                    )
                    return FILTER_APPLICATIONS_STATE

                # Split the list into rows for the keyboard layout
                degree_buttons = [degrees[i:i + 2] for i in range(0, len(degrees), 2)]

                # Send the dynamic list of degrees to the user
                await update.message.reply_text(
                    "Please select an education level to filter by:",
                    reply_markup=ReplyKeyboardMarkup(degree_buttons, resize_keyboard=True)
                )
                return FILTER_CRITERIA_STATE

            except (Exception, psycopg2.DatabaseError) as error:
                logger.error(f"Database error while fetching education levels: {error}")
                await update.message.reply_text(
                    "An error occurred while fetching education levels. Please try again later.",

                )
                return FILTER_APPLICATIONS_STATE

            finally:
                if conn:
                    cursor.close()
                    conn.close()

    if selected_filter == "🗣️ language":
        try:
            # Connect to the PostgreSQL database
            conn = psycopg2.connect(
                dbname="my_project_db",
                user="postgres",
                password="1201",
                host="localhost",
                port="5432"
            )
            cursor = conn.cursor()

            # Fetch the list of languages from the languages table
            cursor.execute("SELECT language_name FROM languages ORDER BY language_name ASC;")
            languages = [row[0] for row in cursor.fetchall()]

            if not languages:
                # If no languages are found, send an appropriate message
                await update.message.reply_text(
                    "No languages are available at the moment. Please try another filter.",

                )
                return FILTER_APPLICATIONS_STATE

            # Split the list into rows for the keyboard layout
            language_buttons = [languages[i:i + 2] for i in range(0, len(languages), 2)]

            # Send the dynamic list of languages to the user
            await update.message.reply_text(
                "Please select a language to filter by:",
                reply_markup=ReplyKeyboardMarkup(language_buttons, resize_keyboard=True)
            )
            return FILTER_CRITERIA_STATE

        except (Exception, psycopg2.DatabaseError) as error:
            logger.error(f"Database error while fetching languages: {error}")
            await update.message.reply_text(
                "An error occurred while fetching languages. Please try again later.",

            )
            return FILTER_APPLICATIONS_STATE

        finally:
            if conn:
                cursor.close()
                conn.close()

    # Default case for other filters
    await update.message.reply_text(
        f"You selected '{selected_filter.capitalize()}'. Please provide the value to filter by.",
        reply_markup=ReplyKeyboardMarkup(
            [["🔙 Back"]],
            resize_keyboard=True
        )
    )
    return FILTER_CRITERIA_STATE


async def apply_filter(update: Update, context: CallbackContext) -> int:
    """
    Apply the specified filter based on user input and update the filtered results.
    Each applicant is displayed in a separate message with 'View Profile' and 'Chat' buttons.
    """
    user_input = update.message.text.strip().lower()

    # Handle "Back" button
    if user_input == "🔙 back":
        context.user_data.clear()  # Clear context data when starting over
        await start_filtering(update, context)
        return FILTER_APPLICATIONS_STATE

    current_filter = context.user_data.get("current_filter")
    filtered_results = context.user_data.get("filtered_results")
    applied_filters = context.user_data.setdefault("filters", {})

    if user_input == "✔️ done":
        if not filtered_results:
            await update.message.reply_text(
                "No matching applicants found based on your criteria.",
                reply_markup=ReplyKeyboardRemove()
            )
        else:
            # Display each applicant separately
            context.user_data["filtered_message_data"] = {}  # Store message_id for each applicant

            for result in filtered_results:
                applicant_id, full_name, job_title, location, *extra = result
                job_title_text = f" - {job_title}" if job_title else ""
                display_name = f"👤 {full_name}{job_title_text}\n\n📍 {location or 'N/A'}"

                # Buttons for interaction
                buttons = [
                    [InlineKeyboardButton("View Profile", callback_data=f"narrowed_global_applicants_profile_{applicant_id}")],
                    [InlineKeyboardButton("Chat", callback_data=f"narrow_chat_with_applicant_{applicant_id}")]
                ]

                # Send separate message for each applicant
                try:
                    sent_message = await update.message.reply_text(
                        display_name,
                        reply_markup=InlineKeyboardMarkup(buttons)
                    )
                    # Store message_id and content for potential future updates
                    context.user_data["filtered_message_data"][sent_message.message_id] = display_name
                except Exception as e:
                    logging.error(f"Error sending message for applicant_id {applicant_id}: {e}")

        # Clean up context data while preserving results
        for key in list(context.user_data.keys()):
            if key not in {"filtered_results", "filtered_message_data"}:
                del context.user_data[key]

        await update.message.reply_text(
            "Search completed. You can navigate back to view applicants.",
            reply_markup=ReplyKeyboardRemove()
        )
        return FILTER_APPLICATIONS_STATE

    # Ensure a filter is selected
    if not current_filter:
        await update.message.reply_text("No filter selected. Please choose a filter first.")
        return FILTER_APPLICATIONS_STATE

    # Validate user input
    if not user_input:
        await update.message.reply_text("No input provided. Please enter a valid value.")
        return FILTER_CRITERIA_STATE

    conn = None
    cursor = None

    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        # Prepare query and parameters
        query = None
        params = ()

        # Build the query dynamically based on the current filter
        if current_filter == "💪🏿 skills":
            skills = [skill.strip() for skill in user_input.split(",") if skill.strip()]
            if not skills:
                await update.message.reply_text("Please enter at least one valid skill.")
                return FILTER_CRITERIA_STATE
            query = """
                SELECT applicant_id, full_name, job_title, location, experience_level, skills
                WHERE opt_out_search = FALSE AND EXISTS (
                WHERE EXISTS (
                    SELECT 1
                    FROM unnest(skills) AS skill
                    WHERE LOWER(skill) = ANY(%s)
                )
            """
            params = (skills,)

        elif current_filter == "📍 location":
            query = """
                SELECT applicant_id, full_name, job_title, location, experience_level, skills
                FROM applicant_profiles
                WHERE opt_out_search = FALSE AND LOWER(location) LIKE %s
            """
            params = (f"%{user_input}%",)

        elif current_filter == "🎖️ experience level":
            query = """
                SELECT applicant_id, full_name, job_title, location, experience_level, skills
                FROM applicant_profiles
                WHERE opt_out_search = FALSE AND experience_level ILIKE %s
            """
            params = (f"%{user_input}%",)

        elif current_filter == "🚻 gender":
            if user_input not in ["male", "female"]:
                await update.message.reply_text("Please enter 'male' or 'female' for gender filtering.")
                return FILTER_CRITERIA_STATE
            query = """
                SELECT applicant_id, full_name, job_title, location, experience_level, gender
                FROM applicant_profiles
                WHERE opt_out_search = FALSE AND LOWER(gender) = %s
            """
            params = (user_input,)

        elif current_filter == "💼 employment type":
            query = """
                SELECT applicant_id, full_name, job_title, location, experience_level, employment_type
                FROM applicant_profiles
                WHERE opt_out_search = FALSE AND LOWER(employment_type) ILIKE %s
            """
            params = (f"%{user_input}%",)

        elif current_filter == "🎓 degree":
            query = """
                SELECT applicant_id, full_name, job_title, location, experience_level, highest_degree
                FROM applicant_profiles
                WHERE opt_out_search = FALSE AND LOWER(highest_degree) ILIKE %s
            """
            params = (f"%{user_input}%",)

        elif current_filter == "🏫 university":
            query = """
                SELECT applicant_id, full_name, job_title, location, experience_level, university
                FROM applicant_profiles
                WHERE opt_out_search = FALSE AND LOWER(university) ILIKE %s
            """
            params = (f"%{user_input}%",)

        elif current_filter == "📅 graduation year":
            if not user_input.isdigit():
                await update.message.reply_text("Please provide a valid graduation year.")
                return FILTER_CRITERIA_STATE
            query = """
                SELECT applicant_id, full_name, job_title, location, experience_level, graduation_year
                FROM applicant_profiles
                WHERE opt_out_search = FALSE AND graduation_year = %s
            """
            params = (int(user_input),)

        elif current_filter == "🏛️ college":
            query = """
                SELECT applicant_id, full_name, job_title, location, experience_level, college
                FROM applicant_profiles
                WHERE opt_out_search = FALSE AND LOWER(college) ILIKE %s
            """
            params = (f"%{user_input}%",)

        elif current_filter == "📚 gpa":
            gpa_ranges = {
                "2.0-2.5": "gpa BETWEEN 2.0 AND 2.5",
                "2.5-3.0": "gpa BETWEEN 2.5 AND 3.0",
                "3.0-3.5": "gpa BETWEEN 3.0 AND 3.5",
                "3.5-4.0": "gpa BETWEEN 3.5 AND 4.0",
                ">2.0": "gpa > 2.0",
                ">3.0": "gpa > 3.0"
            }
            if user_input not in gpa_ranges:
                await update.message.reply_text("⚠️ Invalid GPA range. Please select from the predefined options.")
                return FILTER_CRITERIA_STATE
            query = f"""
                SELECT applicant_id, full_name, job_title, location, experience_level, gpa
                FROM applicant_profiles
                WHERE opt_out_search = FALSE AND {gpa_ranges[user_input]}
            """

        elif current_filter == "🗣️ language":
            query = """
                SELECT applicant_id, full_name, job_title, location, experience_level, languages
                FROM applicant_profiles
                WHERE opt_out_search = FALSE AND EXISTS (
                    SELECT 1
                    FROM unnest(languages) AS lang
                    WHERE LOWER(lang) LIKE %s
                )
            """
            params = (f"%{user_input}%",)

        # Ensure the query is properly defined
        if not query:
            raise ValueError(f"Filter {current_filter} is not implemented or invalid.")

        # Apply filtering
        if filtered_results is not None:
            filtered_ids = [result[0] for result in filtered_results]
            cursor.execute(f"""
                WITH filtered_ids AS (
                    SELECT * FROM applicant_profiles WHERE applicant_id = ANY(%s::int[])
                )
                {query.replace('FROM applicant_profiles', 'FROM filtered_ids')}
            """, ([filtered_ids] + list(params)))
            results = cursor.fetchall()
        else:
            cursor.execute(query, params)
            results = cursor.fetchall()

        # Handle results
        if not results:
            await update.message.reply_text("🤷🏾‍♂️ No applicants found with the specified criteria.")

        else:
            context.user_data["filtered_results"] = results
            context.user_data["filtered_message_data"] = {}

            for result in results:
                applicant_id, full_name, job_title, location, *extra = result
                job_title_text = f" - {job_title}" if job_title else ""
                display_name = f"👤 {full_name}{job_title_text}\n\n📍 {location or 'N/A'}"

                # Buttons for interaction
                buttons = [
                    [InlineKeyboardButton("View Profile",
                                          callback_data=f"narrowed_global_applicants_profile_{applicant_id}")],
                    [InlineKeyboardButton("Chat", callback_data=f"narrow_chat_with_applicant_{applicant_id}")]
                ]

                # Send separate message for each applicant
                try:
                    sent_message = await update.message.reply_text(
                        display_name,
                        reply_markup=InlineKeyboardMarkup(buttons)
                    )
                    # Store message_id and content
                    context.user_data["filtered_message_data"][sent_message.message_id] = display_name
                except Exception as e:
                    logging.error(f"Error sending message for applicant_id {applicant_id}: {e}")



    except Exception as e:
        logging.error(f"Error applying filter: {e}")
        await update.message.reply_text("An error occurred while filtering.")
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

    # Ask for another filter
    await update.message.reply_text(
        "Do you want to apply another filter? Choose a criterion or type 'Done' to finish.",
        reply_markup=ReplyKeyboardMarkup(
            [
                ["💪🏿 Skills", "📍 Location"],
                ["🎖️ Experience Level", "🚻 Gender"],
                ["💼 Employment Type", "🎓 Degree"],
                ["🏫 University", "📅 Graduation Year"],
                ["🏛️ College", "📚 GPA"],
                ["🗣️ Language", "🔙 Back to Menu"],

            ],
            resize_keyboard=True
        )
    )
    return FILTER_APPLICATIONS_STATE

async def back_to_start(update: Update, context: CallbackContext) -> int:
    """
    Handle the 'Back' button to reset the filtering process.
    """
    # Clear user data for filtering
    context.user_data.clear()

    # Redirect to the start filtering function
    await start_filtering(update, context)
    return FILTER_APPLICATIONS_STATE

async def narrowed_global_applicants_profile(update: Update, context: CallbackContext) -> None:
    """
    Handle the 'Narrowed Global Applicants Profile' button click.
    Retrieve and display detailed applicant profile information in the same inline message.
    """
    query = update.callback_query
    await query.answer()

    # Extract applicant_id from callback data
    callback_data = query.data
    try:
        applicant_id = int(callback_data.split("_")[-1])
    except (ValueError, IndexError):
        logging.error("Invalid callback data for narrowed global applicants profile.")
        await query.edit_message_text("An error occurred while retrieving the applicant's profile.")
        return

    # Initialize connection and cursor
    conn = None
    cursor = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        # Query to fetch applicant profile
        cursor.execute("""
            SELECT full_name, profile_picture, job_title, location, phone_number, email, experience_level,
                   skills, employment_type, availability, work_experience, highest_degree, university, college, gpa,
                   graduation_year, certifications, languages, portfolio_link, resume, application_status
            FROM applicant_profiles
            WHERE applicant_id = %s
        """, (applicant_id,))
        result = cursor.fetchone()

        if not result:
            await query.edit_message_text("🤷🏾‍♂️ The applicant's profile could not be found.")
            return

        # Unpack the result
        (full_name, profile_picture, job_title, location, phone_number, email, experience_level, skills,
         employment_type, availability, work_experience, highest_degree, university, college, gpa, graduation_year,
         certifications, languages, portfolio_link, resume, application_status) = result


        # Build the profile message dynamically
        profile_message = f"👤 *Full Name:* {full_name or 'N/A'}\n\n"
        if job_title:
            profile_message += f"🏷️ *Job Title:* {job_title}\n\n"
        if location:
            profile_message += f"📍 *Location:* {location}\n\n"
        if email:
            profile_message += f"📧 *Email:* {email}\n\n"
        if experience_level:
            profile_message += f"🥇 *Experience Level:* {experience_level}\n\n"
        if skills:
            profile_message += f"🛠️ *Skills:* {', '.join(skills) if isinstance(skills, list) else skills}\n\n"
        if employment_type:
            profile_message += f"💼 *Employment Type:* {employment_type}\n\n"
        if availability:
            profile_message += f"📅 *Availability:* {availability}\n\n"
        if work_experience:
            profile_message += f"📜 *Work Experience:* {work_experience}\n\n"
        if highest_degree:
            profile_message += f"🎓 *Degrees:* {highest_degree}\n\n"
        if university:
            profile_message += f"🏫 *University:* {university}\n\n"
        if college:
            profile_message += f"🏛️ *College:* {college}\n\n"
        if gpa:
            profile_message += f"📚 *GPA:* {gpa}\n\n"
        if graduation_year:
            profile_message += f"🎓 *Graduation Year:* {graduation_year}\n\n"
        if certifications:
            profile_message += f"📜 *Certifications:* {', '.join(certifications) if isinstance(certifications, list) else certifications}\n\n"
        if languages:
            profile_message += f"🗣️ *Languages:* {', '.join(languages) if isinstance(languages, list) else languages}\n\n"
        # Portfolio Links
        if portfolio_link:
            # Split the portfolio_link by commas and format each link
            formatted_links = "\n\n".join(
                f"🔗 *Portfolio:* [{link.strip()}]({link.strip()})" for link in portfolio_link.split(","))
            profile_message += f"{formatted_links}\n\n"

        # Inline keyboard for further actions
        buttons = [
            [InlineKeyboardButton("🔙 Back", callback_data="back_to_filtered_applicants")],
            [InlineKeyboardButton("Chat", callback_data=f"narrow_chat_with_applicant_{applicant_id}")]
            
        ]

        # Update the current inline message with the profile details
        await query.edit_message_text(
            text=profile_message,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(buttons),
            disable_web_page_preview=True  # To prevent large previews for links
        )
    except Exception as e:
        logging.error(f"Error retrieving applicant profile: {e}")
        await query.edit_message_text("An error occurred while retrieving the applicant's profile.")
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()


async def narrow_chat_with_applicant(update: Update, context: CallbackContext) -> None:
    """
    Handle the 'Narrow Chat with Applicant' button click.
    Provide the applicant's contact information.
    """
    query = update.callback_query
    await query.answer()  # Acknowledge the callback query

    try:
        applicant_id = int(query.data.split("_")[-1])  # Extract applicant_id from the callback data

        # Establish database connection
        conn = get_db_connection()  # Ensure this is your configured database connection function
        cursor = conn.cursor()

        # Fetch user information linked to this applicant_id
        cursor.execute("""
            SELECT u.first_name, u.last_name, u.username, u.phone_number
            FROM applicant_profiles ap
            JOIN users u ON ap.user_id = u.user_id
            WHERE ap.applicant_id = %s
        """, (applicant_id,))
        applicant_row = cursor.fetchone()

        if not applicant_row:
            await query.edit_message_text("🤷🏾‍♂️ Applicant not found in the database.")
            return

        applicant_first_name, applicant_last_name, applicant_username, applicant_phone = applicant_row
        applicant_name = f"{applicant_first_name} {applicant_last_name}"

        # Generate contact information
        if applicant_username:
            applicant_contact_info = f"Telegram: [@{applicant_username}](https://t.me/{applicant_username})"
        else:
            # Ensure the phone number starts with a "+"
            formatted_phone = f"+{applicant_phone.lstrip('+')}" if applicant_phone else "N/A"
            applicant_contact_info = f"Phone: {formatted_phone}"

        # Combine contact details and caution message in a single response
        message_content = (
            f"👤 Contact {applicant_name}:\n\n"
            f"{applicant_contact_info}\n\n"
            "⚠️ <i>Please use this contact information professionally and in compliance with our platform's policies.</i>\n\n"
            "❌ <i>Any misuse of this information will result in the termination of your account.</i>"
        )

        # Display applicant contact details with caution message
        await query.edit_message_text(
            message_content,
            parse_mode="HTML",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("🔙 Back", callback_data="back_to_filtered_applicants")]
            ])
        )

    except Exception as e:
        logging.error(f"Error in narrow_chat_with_applicant: {e}")
        await query.edit_message_text("An error occurred while retrieving the applicant's contact information.")
    finally:
        if conn:
            cursor.close()
            conn.close()


async def narrow_back_to_applicants(update: Update, context: CallbackContext) -> None:
    """
    Handle the 'Narrow Back to Applicants' button click.
    Redisplay the filtered list of applicants inline using previously saved messages.
    """
    query = update.callback_query
    await query.answer()

    # Retrieve filtered results and saved message data
    filtered_results = context.user_data.get("filtered_results", [])
    message_data = context.user_data.get("filtered_message_data", {})  # {message_id: text}

    if not filtered_results or not message_data:
        await query.edit_message_text("No previous filtered results found.")
        return

    try:
        # Redisplay each applicant inline using saved message IDs and content
        for message_id, result in zip(message_data.keys(), filtered_results):
            # Unpack required fields, ignore extras
            applicant_id, full_name, job_title, location, *extra = result
            job_title_text = f" - {job_title}" if job_title else ""
            display_name = f"👤 {full_name}{job_title_text}\n\n📍 {location or 'N/A'}"

            buttons = [
                [InlineKeyboardButton("View Profile", callback_data=f"narrowed_global_applicants_profile_{applicant_id}")],
                [InlineKeyboardButton("Chat", callback_data=f"narrow_chat_with_applicant_{applicant_id}")]
            ]

            try:
                # Update the message inline
                await context.bot.edit_message_text(
                    chat_id=query.message.chat_id,
                    message_id=message_id,
                    text=display_name,
                    reply_markup=InlineKeyboardMarkup(buttons),
                )
            except Exception as e:
                logging.error(f"Error editing message {message_id}: {e}")
    except Exception as e:
        logging.error(f"Error displaying filtered applicants: {e}")
        await query.message.reply_text("An error occurred while displaying the applicants.")


# Function to handle viewing applicant profiles
async def view_applicant_profiles(update: Update, context: CallbackContext) -> int:
    # Example of fetching and displaying applicant profiles
    conn = sqlite3.connect('applicants.db')  # Assuming your applicant data is stored here
    cursor = conn.cursor()

    # Fetching applicant profiles from the database (customize query based on your schema)
    cursor.execute('SELECT applicant_name, skills, experience_level FROM applicants LIMIT 10')
    applicants = cursor.fetchall()
    conn.close()

    # Construct the response message listing applicant profiles
    profiles_summary = "\n".join([f"👤 *{applicant[0]}*\nSkills: {applicant[1]}\nExperience Level: {applicant[2]}" for applicant in applicants])

    if profiles_summary:
        await update.message.reply_text(f"Here are some applicant profiles:\n\n{profiles_summary}", parse_mode='Markdown')
    else:
        await update.message.reply_text("🤷🏾‍♂️ No applicant profiles found.")

    return SEARCH_FILTER  # Return to the search and filter menu, or other appropriate state



import re
import logging
import psycopg2
from telegram import ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import CallbackContext, ConversationHandler
from datetime import date

# Function to escape special characters for Telegram's MarkdownV2
def escape_markdown_v2(text):
    """Escapes special characters for Telegram's MarkdownV2 syntax."""
    return re.sub(r'([_*\[\]()~`>#+\-=|{}.!])', r'\\\1', str(text))

# Function to allow the employer to edit or register their profile
async def edit_employer_profile(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id  # Get the user's Telegram chat_id

   

    # Check if the user pressed the "Back" button
    if update.message.text == "🔙 Back":
        # Return to the PROFILE_MANAGEMENT state
        await update.message.reply_text(
            "Profile Management: Please choose an action.",
            reply_markup=ReplyKeyboardMarkup([
                ["➕🪪 Add Profile", "🏢 Company Profile"],
                ["➕📞 Add Contact", "🔙 Back"]

            ], resize_keyboard=True)
        )
        return PROFILE_MANAGEMENT

    # Connect to PostgreSQL database
    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Map chat_id to user_id in the `users` table
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return

        user_id = user_row[0]
        context.user_data["user_id"] = user_id  # Save user_id to context for later use

        # Fetch employer (company) profile for the current user, including employer details
        cursor.execute('''
            SELECT company_name, company_founding_year, company_ceo_name, 
                   industry, company_size, number_of_open_positions, 
                   average_salary_range, employee_benefits, company_description, 
                   company_logo, company_certifications, employer_name, 
                   employer_position, employer_contact
            FROM company_profiles
            WHERE user_id = %s
        ''', (user_id,))
        profile_data = cursor.fetchone()

        if not profile_data:
            await update.message.reply_text("You do not have a company profile yet. Let's create one!")
        else:
            # Correctly map field names to their corresponding data
            field_names = [
                "🏢 Company Name", "📅 Founding Year", "👔 CEO Name", "🏭 Industry",
                "👥 Company Size", "📋 Open Positions", "💵 Salary Range",
                "🎁 Employee Benefits", "📝 Description", "👤 Employer Name",
                "💼 Employer Position", "📞 Employer Contact"
            ]

            # Correctly map profile data fields from the query in the requested order
            profile_fields = [
                profile_data[0],  # company_name
                profile_data[1],  # company_founding_year
                profile_data[2],  # company_ceo_name
                profile_data[3],  # industry
                profile_data[4],  # company_size
                profile_data[5],  # number_of_open_positions
                profile_data[6],  # average_salary_range
                profile_data[7],  # employee_benefits
                profile_data[8],  # company_description
                profile_data[11],  # employer_name
                profile_data[12],  # employer_position
                profile_data[13],  # employer_contact
            ]

            # Only include non-empty fields in the profile summary
            profile_info = "\n\n".join(
                f"*{escape_markdown_v2(field_name)}:* {escape_markdown_v2(str(field_value).strip()) if isinstance(field_value, str) else field_value}"
                for field_name, field_value in zip(field_names, profile_fields)
                if field_value  # Ensures it's not None or empty
            )

            # Adding company logo and certifications as available if they exist
            verification_files = "\n\n*Verification Files*\n\n" if profile_data[9] or profile_data[10] else ""

            if profile_data[9]:  # Company Logo
                verification_files += f"🖼️ *Company Logo:* Available\n\n"

            if profile_data[10]:  # Company Certifications
                verification_files += f"📜 *Certifications:* Available\n"

            # If no fields are set, show a specific message
            if not profile_info:
                profile_info = "No profile information has been registered yet."

            # Send the profile summary using MarkdownV2 format with inline buttons if available
            inline_buttons = []
            if profile_data[9]:
                inline_buttons.append([InlineKeyboardButton("Download Logo", callback_data=f"download_logo_{user_id}")])
            if profile_data[10]:
                inline_buttons.append([InlineKeyboardButton("Download Certifications", callback_data=f"download_certifications_{user_id}")])

            await update.message.reply_text(
                f"Here is your current company profile:\n\n{profile_info}{verification_files}",
                parse_mode='MarkdownV2',
                reply_markup=InlineKeyboardMarkup(inline_buttons) if inline_buttons else None
            )

    except (Exception, psycopg2.DatabaseError) as error:
        logging.error(f"Error fetching company profile: {error}")
        await update.message.reply_text("An error occurred while retrieving your profile.")
        return

    finally:
        if conn:
            cursor.close()
            conn.close()

    # Ask which field the user would like to edit, adding the new fields for employer details
    await update.message.reply_text(
        "Which field would you like to update?",
        reply_markup=ReplyKeyboardMarkup([
            ["🏢 Company Name", "📅 Founding Year"],
            ["📝 Description", "🏭 Industry"],
            ["👔 CEO Name", "👥 Company Size"],
            ["🎁 Benefits", "📋 Open Positions"],
            ["💵 Salary Range", "🖼️ Company Logo"],
            ["👤 Employer Name", "💼 Employer Position"],
            ["📞 Employer Contact", "📜 Certifications"],
            ["🔙 Back"]
        ], resize_keyboard=True)
    )

    return PROFILE_EDIT_MENU


# Show the employer profile edit menu
async def show_employer_profile_edit_menu(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Which field would you like to edit or add next?",
        reply_markup=ReplyKeyboardMarkup([
            ["🏢 Company Name", "📅 Founding Year"],
            ["📝 Description", "🏭 Industry"],
            ["👔 CEO Name", "👥 Company Size"],
            ["🎁 Benefits", "📋 Open Positions"],
            ["💵 Salary Range", "🖼️ Company Logo"],
            ["👤 Employer Name", "💼 Employer Position"],
            ["📞 Employer Contact", "📜 Certifications"],
            ["🔙 Back"]
        ], resize_keyboard=True)
    )
    return PROFILE_EDIT_MENU


# Functions to ask for each input
async def ask_for_company_name(update: Update, context: CallbackContext) -> int:
    # Provide a "Back" button when asking for the company name
    await update.message.reply_text(
        "Please enter the Company Name (or press 'Back' to return):",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)  # Add "Back" button
    )
    return COMPANY_NAME


# Function to ask for industry dynamically from the database, showing one column
async def ask_for_industry(update: Update, context: CallbackContext) -> int:
    """
    Prompts the user to select an industry dynamically fetched from the job_categories table, displayed in a single column.
    """
    conn = None
    cursor = None
    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch the list of industries from the job_categories table
        cursor.execute("SELECT category_name FROM job_categories WHERE is_active = TRUE ORDER BY category_name ASC;")
        industries = [row[0] for row in cursor.fetchall()]

        if not industries:
            await update.message.reply_text(
                "No industries are available at the moment. Please try again later."
            )
            return INDUSTRY

        # Prepare reply markup dynamically with fetched industries (one column layout)
        industry_buttons = [[industry] for industry in industries]
        industry_buttons.append(["🔙 Back"])  # Add "Back" button at the end

        # Send the dynamic industry list to the user
        await update.message.reply_text(
            "Please select the Industry the company operates in:",
            reply_markup=ReplyKeyboardMarkup(industry_buttons, resize_keyboard=True)
        )
        return INDUSTRY

    except (Exception, psycopg2.DatabaseError) as error:
        logging.error(f"Error fetching industries: {error}")
        await update.message.reply_text(
            "An error occurred while retrieving the industries. Please try again later."
        )
        return INDUSTRY

    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()


from telegram import ReplyKeyboardMarkup

# Function to ask for company size with a "Back" button
async def ask_for_company_size(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please enter the Company Size:",
        reply_markup=ReplyKeyboardMarkup([
            ["🔙 Back"]  # Adding a Back button for the user to go back to the main menu
        ], resize_keyboard=True)
    )
    return COMPANY_SIZE




# Function to ask for company logo with a "Back" button
async def ask_for_company_logo(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please upload the Company Logo (image file):",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return COMPANY_LOGO



from telegram import ReplyKeyboardMarkup

# Function to ask for company description with a "Back" button
async def ask_for_company_description(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please enter the Company Description:",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return COMPANY_DESCRIPTION


# Function to ask for company founding year with a "Back" button
async def ask_for_company_founding_year(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please enter the Company Founding Year:",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return COMPANY_FOUNDING_YEAR

# Function to ask for CEO name with a "Back" button
async def ask_for_company_ceo_name(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please enter the CEO's Name:",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return COMPANY_CEO_NAME

# Function to ask for open positions with a "Back" button
async def ask_for_open_positions(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please enter the Open Positions at the company:",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return OPEN_POSITIONS  # Adjust this to the appropriate constant used in your code


# Function to ask for company certifications with a "Back" button
async def ask_for_company_certifications(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please enter any Company Certifications:",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return COMPANY_CERTIFICATIONS

# Function to ask for employee benefits with a "Back" button
async def ask_for_employee_benefits(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please enter the Employee Benefits offered by the company:",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return EMPLOYEE_BENEFITS

# Function to ask for average salary range with a "Back" button
async def ask_for_average_salary_range(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please enter the Average Salary Range for the company:",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return AVERAGE_SALARY_RANGE

async def ask_for_employer_name(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please enter the Employer Name:",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)  # Adding a Back button
    )
    return EMPLOYER_NAME

async def ask_for_employer_position(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please enter the Employer Position (e.g., HR Manager):",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)  # Adding a Back button
    )
    return EMPLOYER_POSITION


async def ask_for_employer_contact(update: Update, context: CallbackContext) -> int:
    # Create a button that requests contact info
    contact_button = KeyboardButton(text="📞 Share Contact", request_contact=True)

    # Send message with button to request contact
    await update.message.reply_text(
        "Please press the button below to share your contact information via Telegram.",
        reply_markup=ReplyKeyboardMarkup([[contact_button], ["🔙 Back"]], resize_keyboard=True)
    )

    return EMPLOYER_CONTACT


import psycopg2
from telegram import ReplyKeyboardMarkup, Update
from telegram.ext import CallbackContext

# Function to save the company name and handle the "Back" button
async def save_company_name(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    company_name = update.message.text  # This is the company name the user entered

    # Check if the user pressed the "Back" button
    if company_name.lower() == "🔙 back":
        logger.debug(f"User pressed 'Back' in company name field")
        return await show_employer_profile_edit_menu(update, context)  # Return to the employer profile edit menu

    try:
        # Step 1: Connect to PostgreSQL database
        logger.debug("Connecting to database to save company name")
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 2: Fetch the user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Step 3: Insert or update the company name in company_profiles
        cursor.execute('''
            INSERT INTO company_profiles (user_id, company_name)
            VALUES (%s, %s)
            ON CONFLICT (user_id) 
            DO UPDATE SET company_name = EXCLUDED.company_name
        ''', (user_id, company_name))

        conn.commit()

        # Notify the user that the company name has been saved
        await update.message.reply_text(f"Company Name '{company_name}' has been saved successfully.")

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating company_name: {error}")
        await update.message.reply_text("An error occurred while updating your company name.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    # Return to the profile summary after successfully updating the company name
    return await edit_employer_profile(update, context)




import psycopg2
import re
from telegram import ReplyKeyboardMarkup, Update
from telegram.ext import CallbackContext

# Function to save the industry with validation against fetched values
async def save_industry(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    industry = update.message.text.strip()  # Get the industry the user entered

    try:
        # Step 1: Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 2: Fetch the list of valid industries from the database
        cursor.execute("SELECT category_name FROM job_categories WHERE is_active = TRUE ORDER BY category_name ASC;")
        valid_industries = [row[0] for row in cursor.fetchall()]

        # Add a "Back" option
        valid_industries.append("🔙 Back")

        # Validate user input against the list of valid industries
        if industry not in valid_industries:
            await update.message.reply_text(
                "⚠️ Invalid input. Please select an industry from the options provided.",
                reply_markup=ReplyKeyboardMarkup(
                    [[ind] for ind in valid_industries], resize_keyboard=True, one_time_keyboard=True
                )
            )
            return INDUSTRY  # Keep the user in the same state

        # Handle "Back" button
        if industry == "🔙 Back":
            await update.message.reply_text(
                "Which field would you like to update?",
                reply_markup=ReplyKeyboardMarkup([
                    ["🏢 Company Name", "📅 Founding Year"],
                    ["📝 Description", "🏭 Industry"],
                    ["👔 CEO Name", "👥 Company Size"],
                    ["🎁 Benefits", "📋 Open Positions"],
                    ["💵 Salary Range", "🖼️ Company Logo"],
                    ["👤 Employer Name", "💼 Employer Position"],
                    ["📞 Employer Contact", "📜 Certifications"],
                    ["🔙 Back"]
                ], resize_keyboard=True)
            )
            return PROFILE_EDIT_MENU

        # Step 3: Fetch the user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Step 4: Fetch the existing company_name to ensure it is not null
        cursor.execute('SELECT company_name FROM company_profiles WHERE user_id = %s', (user_id,))
        company_profile = cursor.fetchone()

        if not company_profile or not company_profile[0]:
            await update.message.reply_text("Please enter your Company Name first.")
            return COMPANY_NAME

        company_name = company_profile[0]  # Get the current company name

        # Step 5: Insert or update the industry in company_profiles, keeping company_name
        cursor.execute('''
            INSERT INTO company_profiles (user_id, company_name, industry)
            VALUES (%s, %s, %s)
            ON CONFLICT (user_id) 
            DO UPDATE SET industry = EXCLUDED.industry
        ''', (user_id, company_name, industry))

        conn.commit()

        # Notify the user that the industry has been saved
        await update.message.reply_text(f"Industry '{industry}' has been saved successfully.")

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating industry: {error}")
        await update.message.reply_text("An error occurred while updating your industry.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    # Return to the profile summary after successfully updating the industry
    return await edit_employer_profile(update, context)


import psycopg2
from telegram import ReplyKeyboardMarkup, Update
from telegram.ext import CallbackContext

# Function to save company size with validation for company_name
async def save_company_size(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    company_size = update.message.text  # Get the company size entered by the user

    # Check if the user pressed the "Back" button
    if company_size.lower() == "🔙 back":
        logger.debug(f"User pressed 'Back' in company name field")
        await update.message.reply_text(
            "Which field would you like to update?",
            reply_markup=ReplyKeyboardMarkup([
                ["🏢 Company Name", "📅 Founding Year"],
                ["📝 Description", "🏭 Industry"],
                ["👔 CEO Name", "👥 Company Size"],
                ["🎁 Benefits", "📋 Open Positions"],
                ["💵 Salary Range", "🖼️ Company Logo"],
                ["👤 Employer Name", "💼 Employer Position"],
                ["📞 Employer Contact", "📜 Certifications"],
                ["🔙 Back"]
            ], resize_keyboard=True)
        )
        return PROFILE_EDIT_MENU  # Return to the profile edit menu

    try:
        # Step 1: Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 2: Fetch the user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Step 3: Fetch the existing company_name to ensure it is not null
        cursor.execute('SELECT company_name FROM company_profiles WHERE user_id = %s', (user_id,))
        company_profile = cursor.fetchone()

        if not company_profile or not company_profile[0]:
            # If company_name is null, prompt the user to enter it first
            await update.message.reply_text("Please enter your Company Name first.")
            return COMPANY_NAME

        company_name = company_profile[0]  # Get the current company name

        # Step 4: Insert or update the company_size in company_profiles, keeping company_name
        cursor.execute('''
            INSERT INTO company_profiles (user_id, company_name, company_size)
            VALUES (%s, %s, %s)
            ON CONFLICT (user_id) 
            DO UPDATE SET company_size = EXCLUDED.company_size
        ''', (user_id, company_name, company_size))

        conn.commit()

        # Notify the user that the company size has been saved
        await update.message.reply_text(f"Company Size '{company_size}' has been saved successfully.")

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating company_size: {error}")
        await update.message.reply_text("An error occurred while updating your company size.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    # Return to the profile summary after successfully updating company size
    return await edit_employer_profile(update, context)



import os
import logging
import psycopg2
from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import CallbackContext

# Directory to store uploaded logos
UPLOAD_DIR = os.path.join(os.path.dirname(__file__), "logo_uploads")

# Ensure the directory exists
if not os.path.exists(UPLOAD_DIR):
    os.makedirs(UPLOAD_DIR)
    logging.info(f"Created directory: {UPLOAD_DIR}")

# Function to save the company logo and handle the "Back" button
async def save_company_logo(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id

    # Check if the user pressed the "Back" button
    if update.message.text and update.message.text.lower() == "🔙 back":
        logging.debug(f"User pressed 'Back' in company logo field")
        return await show_employer_profile_edit_menu(update, context)  # Return to profile summary

    # Handle file upload (photo)
    if update.message.photo:
        try:
            # Step 1: Connect to PostgreSQL database
            logging.debug("Connecting to database to save company logo")
            conn = psycopg2.connect(
                dbname="my_project_db",
                user="postgres",
                password="1201",
                host="localhost",
                port="5432"
            )
            cursor = conn.cursor()

            # Step 2: Fetch the user_id based on chat_id
            cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
            user_row = cursor.fetchone()

            if not user_row:
                await update.message.reply_text("You are not registered. Please register.")
                return PROFILE_EDIT_MENU

            user_id = user_row[0]

            # Step 3: Handle the file upload
            photo_file = update.message.photo[-1].file_id
            new_file = await context.bot.get_file(photo_file)

            # Generate the file path for saving
            file_path = os.path.join(UPLOAD_DIR, f"company_logo_{user_chat_id}.jpg")
            await new_file.download_to_drive(file_path)

            # Step 4: Insert or update the company logo in company_profiles
            cursor.execute('''
                INSERT INTO company_profiles (user_id, company_logo)
                VALUES (%s, %s)
                ON CONFLICT (user_id) 
                DO UPDATE SET company_logo = EXCLUDED.company_logo
            ''', (user_id, file_path))

            conn.commit()

            # Notify the user that the company logo has been saved
            await update.message.reply_text("✅ Your company logo has been uploaded successfully.")

        except (Exception, psycopg2.DatabaseError) as error:
            logging.error(f"Error updating company_logo: {error}")
            await update.message.reply_text("An error occurred while updating your company logo.")

        finally:
            if conn:
                cursor.close()
                conn.close()

        # Return to the profile summary after successfully uploading
        return await edit_employer_profile(update, context)

    else:
        # No photo was uploaded, ask again
        await update.message.reply_text("❌ Please upload a valid image file for the company logo.")
        return COMPANY_LOGO  # Stay in the current state if no photo is uploaded



# Function to save company description with validation for company_name
async def save_company_description(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    company_description = update.message.text  # Get the company description entered by the user

    # Check if the user pressed the "Back" button
    if company_description.lower() == "🔙 back":
        logger.debug(f"User pressed 'Back' in company name field")
        await update.message.reply_text(
            "Which field would you like to update?",
            reply_markup=ReplyKeyboardMarkup([
                ["🏢 Company Name", "📅 Founding Year"],
                ["📝 Description", "🏭 Industry"],
                ["👔 CEO Name", "👥 Company Size"],
                ["🎁 Benefits", "📋 Open Positions"],
                ["💵 Salary Range", "🖼️ Company Logo"],
                ["👤 Employer Name", "💼 Employer Position"],
                ["📞 Employer Contact", "📜 Certifications"],
                ["🔙 Back"]
            ], resize_keyboard=True)
        )
        return PROFILE_EDIT_MENU  # Return to the profile edit menu

    try:
        # Step 1: Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 2: Fetch the user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Step 3: Fetch the existing company_name to ensure it is not null
        cursor.execute('SELECT company_name FROM company_profiles WHERE user_id = %s', (user_id,))
        company_profile = cursor.fetchone()

        if not company_profile or not company_profile[0]:
            # If company_name is null, prompt the user to enter it first
            await update.message.reply_text("Please enter your Company Name first.")
            return COMPANY_NAME

        company_name = company_profile[0]  # Get the current company name

        # Step 4: Insert or update the company_description in company_profiles, keeping company_name
        cursor.execute('''
            INSERT INTO company_profiles (user_id, company_name, company_description)
            VALUES (%s, %s, %s)
            ON CONFLICT (user_id) 
            DO UPDATE SET company_description = EXCLUDED.company_description
        ''', (user_id, company_name, company_description))

        conn.commit()

        # Notify the user that the company description has been saved
        await update.message.reply_text("Company Description has been saved successfully.")

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating company_description: {error}")
        await update.message.reply_text("An error occurred while updating your company description.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    # Return to the profile summary directly
    return await edit_employer_profile(update, context)



import psycopg2
from telegram import ReplyKeyboardMarkup, Update
from telegram.ext import CallbackContext

# Function to save the company founding year with validation for company_name
async def save_company_founding_year(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    company_founding_year = update.message.text  # Get the founding year entered by the user

    # Check if the user pressed the "Back" button
    if company_founding_year.lower() == "🔙 back":
        logger.debug(f"User pressed 'Back' in company founding year field")
        return await show_employer_profile_edit_menu(update, context)  # Return to the employer profile edit menu

    # Verify that the input is a valid year (assuming the company founding year is in the past)
    if not company_founding_year.isdigit() or int(company_founding_year) > 2024:
        await update.message.reply_text("Please enter a valid year (e.g., 1990).")
        return COMPANY_FOUNDING_YEAR  # Return to asking for company founding year

    try:
        # Step 1: Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 2: Fetch the user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Step 3: Fetch the existing company_name to ensure it is not null
        cursor.execute('SELECT company_name FROM company_profiles WHERE user_id = %s', (user_id,))
        company_profile = cursor.fetchone()

        if not company_profile or not company_profile[0]:
            # If company_name is null, prompt the user to enter it first
            await update.message.reply_text("Please enter your Company Name first.")
            return COMPANY_NAME  # Redirect to the company name input

        company_name = company_profile[0]  # Get the current company name

        # Step 4: Insert or update the company_founding_year in company_profiles, keeping company_name
        cursor.execute('''
            INSERT INTO company_profiles (user_id, company_name, company_founding_year)
            VALUES (%s, %s, %s)
            ON CONFLICT (user_id) 
            DO UPDATE SET company_founding_year = EXCLUDED.company_founding_year
        ''', (user_id, company_name, company_founding_year))

        conn.commit()

        # Notify the user that the founding year has been saved
        await update.message.reply_text(f"Company Founding Year '{company_founding_year}' has been saved successfully.")

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating company_founding_year: {error}")
        await update.message.reply_text("An error occurred while updating your company founding year.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    # Return to the profile summary after saving
    return await edit_employer_profile(update, context)


import psycopg2
from telegram import ReplyKeyboardMarkup, Update
from telegram.ext import CallbackContext

# Function to save the CEO name with validation for company_name
async def save_company_ceo_name(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    company_ceo_name = update.message.text  # Get the CEO name entered by the user

    # Check if the user pressed the "Back" button
    if company_ceo_name.lower() == "🔙 back":
        logger.debug(f"User pressed 'Back' in company name field")
        await update.message.reply_text(
            "Which field would you like to update?",
            reply_markup=ReplyKeyboardMarkup([
                ["🏢 Company Name", "📅 Founding Year"],
                ["📝 Description", "🏭 Industry"],
                ["👔 CEO Name", "👥 Company Size"],
                ["🎁 Benefits", "📋 Open Positions"],
                ["💵 Salary Range", "🖼️ Company Logo"],
                ["👤 Employer Name", "💼 Employer Position"],
                ["📞 Employer Contact", "📜 Certifications"],
                ["🔙 Back"]
            ], resize_keyboard=True)
        )
        return PROFILE_EDIT_MENU  # Return to the profile edit menu

    try:
        # Step 1: Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 2: Fetch the user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Step 3: Fetch the existing company_name to ensure it is not null
        cursor.execute('SELECT company_name FROM company_profiles WHERE user_id = %s', (user_id,))
        company_profile = cursor.fetchone()

        if not company_profile or not company_profile[0]:
            # If company_name is null, prompt the user to enter it first
            await update.message.reply_text("Please enter your Company Name first.")
            return COMPANY_NAME  # Redirect to the company name input

        company_name = company_profile[0]  # Get the current company name

        # Step 4: Insert or update the company_ceo_name in company_profiles, keeping company_name
        cursor.execute('''
            INSERT INTO company_profiles (user_id, company_name, company_ceo_name)
            VALUES (%s, %s, %s)
            ON CONFLICT (user_id) 
            DO UPDATE SET company_ceo_name = EXCLUDED.company_ceo_name
        ''', (user_id, company_name, company_ceo_name))

        conn.commit()

        # Notify the user that the CEO name has been saved
        await update.message.reply_text(f"CEO Name '{company_ceo_name}' has been saved successfully.")

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating company_ceo_name: {error}")
        await update.message.reply_text("An error occurred while updating your company CEO name.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    # Return to the profile summary directly
    return await edit_employer_profile(update, context)



import re
import psycopg2
from telegram import ReplyKeyboardMarkup, Update
from telegram.ext import CallbackContext

# Function to save open positions with validation and handle "Back" button
async def save_open_positions(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    open_positions = update.message.text  # Get the open positions entered by the user

    # Check if the user pressed the "Back" button
    if open_positions.lower() == "🔙 back":
        logger.debug(f"User pressed 'Back' in open positions field")
        return await show_employer_profile_edit_menu(update, context)  # Return to the employer profile edit menu

    # Verify that the input is a valid positive integer
    if not open_positions.isdigit() or int(open_positions) <= 0:
        await update.message.reply_text("Please enter a valid positive number for open positions.")
        return OPEN_POSITIONS  # Adjust the constant as necessary

    try:
        # Step 1: Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 2: Fetch the user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Step 3: Insert or update the open positions in company_profiles
        cursor.execute('''
            INSERT INTO company_profiles (user_id, number_of_open_positions)
            VALUES (%s, %s)
            ON CONFLICT (user_id) 
            DO UPDATE SET number_of_open_positions = EXCLUDED.number_of_open_positions
        ''', (user_id, open_positions))

        conn.commit()

        # Notify the user that the open positions have been saved
        await update.message.reply_text(f"Open positions '{open_positions}' have been saved successfully.")

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating open_positions: {error}")
        await update.message.reply_text("An error occurred while updating the open positions.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    # Return to the profile summary immediately
    return await edit_employer_profile(update, context)



import os
import logging
import psycopg2
from telegram import Update
from telegram.ext import CallbackContext

# Ensure the directory exists for certifications uploads
CERTIFICATIONS_UPLOAD_DIR = os.path.join(os.path.dirname(__file__), "certifications_uploads")
if not os.path.exists(CERTIFICATIONS_UPLOAD_DIR):
    os.makedirs(CERTIFICATIONS_UPLOAD_DIR)
    logging.info(f"Created directory: {CERTIFICATIONS_UPLOAD_DIR}")

# Function to save the company certifications (photos, PDFs, DOCX) and handle the "Back" button
async def save_company_certifications(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id

    # Check if the user pressed the "Back" button
    if update.message.text and update.message.text.lower() == "🔙 back":
        return await edit_employer_profile(update, context)

    # Handle photo upload
    if update.message.photo:
        try:
            photo_file = update.message.photo[-1].file_id
            new_file = await context.bot.get_file(photo_file)

            # Generate the file path for saving
            file_path = os.path.join(CERTIFICATIONS_UPLOAD_DIR, f"company_certification_{user_chat_id}.jpg")
            await new_file.download_to_drive(file_path)
            logging.info(f"Photo downloaded to: {file_path}")

        except Exception as e:
            logging.error(f"Error saving photo: {e}")
            await update.message.reply_text("An error occurred while saving the photo.")
            return COMPANY_CERTIFICATIONS

    # Handle document upload (e.g., PDF, DOCX, etc.)
    elif update.message.document:
        try:
            document_file = update.message.document.file_id
            new_file = await context.bot.get_file(document_file)

            # Get the original file name and extension (like .pdf, .docx)
            file_name = update.message.document.file_name
            file_path = os.path.join(CERTIFICATIONS_UPLOAD_DIR, f"company_certification_{user_chat_id}_{file_name}")
            await new_file.download_to_drive(file_path)
            logging.info(f"Document downloaded to: {file_path}")

        except Exception as e:
            logging.error(f"Error saving document: {e}")
            await update.message.reply_text("An error occurred while saving the document.")
            return COMPANY_CERTIFICATIONS

    # If no valid file was uploaded
    else:
        await update.message.reply_text("❌ Please upload a valid image or document file (PDF, DOCX, etc.).")
        return COMPANY_CERTIFICATIONS  # Stay in the current state if no valid file is uploaded

    try:
        # Step 1: Connect to PostgreSQL database
        logging.debug("Connecting to database to save company certifications")
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 2: Fetch the user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Step 3: Insert or update the company certifications in the database
        cursor.execute('''
            INSERT INTO company_profiles (user_id, company_certifications)
            VALUES (%s, %s)
            ON CONFLICT (user_id) 
            DO UPDATE SET company_certifications = EXCLUDED.company_certifications
        ''', (user_id, file_path))

        conn.commit()

        # Notify the user that the company certifications have been saved
        await update.message.reply_text("✅ Your company certifications have been uploaded successfully.")
        logging.debug("Certification upload and database update successful.")

    except (Exception, psycopg2.DatabaseError) as error:
        logging.error(f"Error updating company_certifications: {error}")
        await update.message.reply_text("An error occurred while updating your company certifications.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    # After saving, go directly back to the profile summary
    return await edit_employer_profile(update, context)



import psycopg2
from telegram import Update
from telegram.ext import CallbackContext

# Function to save employee benefits with validation for company_name
async def save_employee_benefits(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    employee_benefits = update.message.text  # Get the employee benefits entered by the user

    # Check if the user pressed the "Back" button
    if employee_benefits.lower() == "🔙 back":
        logger.debug(f"User pressed 'Back' in employee benefits field")
        return await show_employer_profile_edit_menu(update, context)  # Return to the employer profile edit menu

    try:
        # Step 1: Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 2: Fetch the user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Step 3: Check if company_name is set
        cursor.execute('SELECT company_name FROM company_profiles WHERE user_id = %s', (user_id,))
        company_profile = cursor.fetchone()

        if not company_profile or not company_profile[0]:
            # If company_name is null, prompt the user to enter it first
            await update.message.reply_text("Please enter your Company Name first.")
            return COMPANY_NAME  # Redirect to the company name input

        company_name = company_profile[0]  # Get the current company name

        # Step 4: Insert or update the employee_benefits in company_profiles, keeping company_name
        cursor.execute('''
            INSERT INTO company_profiles (user_id, company_name, employee_benefits)
            VALUES (%s, %s, %s)
            ON CONFLICT (user_id) 
            DO UPDATE SET employee_benefits = EXCLUDED.employee_benefits
        ''', (user_id, company_name, employee_benefits))

        conn.commit()

        # Notify the user that the employee benefits have been saved
        await update.message.reply_text(f"Employee Benefits '{employee_benefits}' have been saved successfully.")

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating employee_benefits: {error}")
        await update.message.reply_text("An error occurred while updating your employee benefits.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    # Return to the profile summary after saving the employee benefits
    return await edit_employer_profile(update, context)



import psycopg2
from telegram import ReplyKeyboardMarkup, Update
from telegram.ext import CallbackContext

# Function to save average salary range with verification of company_name and handle "Back" button
async def save_average_salary_range(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id
    average_salary_range = update.message.text  # Get the average salary range entered by the user

    # Check if the user pressed the "Back" button
    if average_salary_range.lower() == "🔙 back":
        logger.debug(f"User pressed 'Back' in average salary range field")
        return await show_employer_profile_edit_menu(update, context)  # Return to the employer profile edit menu

    try:
        # Step 1: Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 2: Fetch the user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return PROFILE_EDIT_MENU

        user_id = user_row[0]

        # Step 3: Check if company_name is set
        cursor.execute('SELECT company_name FROM company_profiles WHERE user_id = %s', (user_id,))
        company_profile = cursor.fetchone()

        if not company_profile or not company_profile[0]:
            # If company_name is null, prompt the user to enter it first
            await update.message.reply_text("Please enter your Company Name first.")
            return COMPANY_NAME  # Redirect to the company name input

        company_name = company_profile[0]  # Get the current company name

        # Step 4: Insert or update the average_salary_range in company_profiles
        cursor.execute('''
            INSERT INTO company_profiles (user_id, company_name, average_salary_range)
            VALUES (%s, %s, %s)
            ON CONFLICT (user_id)
            DO UPDATE SET average_salary_range = EXCLUDED.average_salary_range
        ''', (user_id, company_name, average_salary_range))

        conn.commit()

        # Notify the user that the average salary range has been saved
        await update.message.reply_text(f"Average Salary Range '{average_salary_range}' has been saved successfully.")

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating average_salary_range: {error}")
        await update.message.reply_text("An error occurred while updating the average salary range.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    # Return to the profile summary after saving
    return await edit_employer_profile(update, context)


import psycopg2
from telegram import Update
from telegram.ext import CallbackContext

# Function to save employer name and handle "Back" button
async def save_employer_name(update: Update, context: CallbackContext) -> int:
    employer_name = update.message.text.strip()  # Strip whitespace for cleaner input

    # Check for "Back" button
    if employer_name.lower() == "🔙 back":
        return await show_employer_profile_edit_menu(update, context)  # Go back to profile editing without summary

    user_id = context.user_data.get("user_id")

    # Verify that user_id exists in context
    if not user_id:
        await update.message.reply_text("User ID not found. Please start the process again.")
        return PROFILE_EDIT_MENU

    # Save the employer name to the database
    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Update employer_name in company_profiles table
        cursor.execute('''
            UPDATE company_profiles 
            SET employer_name = %s 
            WHERE user_id = %s
        ''', (employer_name, user_id))
        conn.commit()

        # Notify the user that the employer name has been saved
        await update.message.reply_text(f"Employer Name '{employer_name}' has been saved successfully.")

    except (Exception, psycopg2.DatabaseError) as error:
        print(f"Error saving employer name: {error}")
        await update.message.reply_text("An error occurred while saving the employer name. Please try again.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    # Return to the profile edit menu after saving employer name
    return await show_employer_profile_edit_menu(update, context)


import psycopg2
from telegram import Update
from telegram.ext import CallbackContext

# Function to save employer position and handle "Back" button
async def save_employer_position(update: Update, context: CallbackContext) -> int:
    employer_position = update.message.text.strip()  # Strip whitespace for cleaner input

    # Check for "Back" button
    if employer_position.lower() == "🔙 back":
        return await show_employer_profile_edit_menu(update, context)  # Go back to profile editing without summary

    user_id = context.user_data.get("user_id")

    # Ensure user_id exists in context before proceeding
    if not user_id:
        await update.message.reply_text("User ID not found. Please start the process again.")
        return PROFILE_EDIT_MENU

    # Save the employer position to the database
    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Update employer_position in company_profiles table
        cursor.execute('''
            UPDATE company_profiles 
            SET employer_position = %s 
            WHERE user_id = %s
        ''', (employer_position, user_id))
        conn.commit()

        # Notify the user that the employer position has been saved
        await update.message.reply_text(f"Employer Position '{employer_position}' has been saved successfully.")

    except (Exception, psycopg2.DatabaseError) as error:
        # Log the error and notify the user
        print(f"Error saving employer position: {error}")
        await update.message.reply_text("An error occurred while saving the employer position. Please try again.")

    finally:
        # Ensure the database connection is closed
        if conn:
            cursor.close()
            conn.close()

    # Return to the profile edit menu after saving the employer position
    return await show_employer_profile_edit_menu(update, context)


import psycopg2
from telegram import Update, Contact
from telegram.ext import CallbackContext

# Function to save employer contact and handle the "Back" button
async def save_employer_contact(update: Update, context: CallbackContext) -> int:
    # Check if the user pressed the "Back" button
    if update.message.text == "🔙 back":
        return await edit_employer_profile(update, context)  # Go back to profile editing

    # Check if the contact was shared
    if update.message.contact:
        employer_contact = update.message.contact.phone_number
        user_id = context.user_data.get("user_id")

        # Ensure user_id is present in context
        if not user_id:
            await update.message.reply_text("User ID not found. Please start the process again.")
            return PROFILE_EDIT_MENU

        # Save the employer contact info to the database
        try:
            # Connect to PostgreSQL database
            conn = psycopg2.connect(
                dbname="my_project_db",
                user="postgres",
                password="1201",
                host="localhost",
                port="5432"
            )
            cursor = conn.cursor()

            # Update employer contact in company_profiles table
            cursor.execute('''
                UPDATE company_profiles 
                SET employer_contact = %s 
                WHERE user_id = %s
            ''', (employer_contact, user_id))
            conn.commit()

            # Notify the user that the contact has been saved
            await update.message.reply_text(f"Employer contact '{employer_contact}' has been saved successfully.")

        except (Exception, psycopg2.DatabaseError) as error:
            # Log the error and notify the user
            print(f"Error saving employer contact: {error}")
            await update.message.reply_text("An error occurred while saving the employer contact. Please try again.")

        finally:
            # Ensure the database connection is closed
            if conn:
                cursor.close()
                conn.close()

        # Return to the profile editing menu
        return await edit_employer_profile(update, context)

    else:
        # Handle case where user didn't share contact info
        await update.message.reply_text("❌ Please use the button to share your contact information.")
        return EMPLOYER_CONTACT  # Stay in the current state to prompt contact sharing again


async def save_field(update: Update, context: CallbackContext, field_name: str, next_state: int) -> int:
    user_id = context.user_data.get("user_id")
    field_value = update.message.text

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Check if company_name exists for this user
        cursor.execute('SELECT company_name FROM company_profiles WHERE user_id = %s', (user_id,))
        company_name = cursor.fetchone()

        if not company_name or company_name[0] is None:
            # If company_name is missing, prompt the user to set it first
            await update.message.reply_text(
                "You need to set the Company Name before updating other fields. Please enter the Company Name:")
            return COMPANY_NAME  # Redirect to set the company name

        # Insert or update the specific field in the `company_profiles` table
        cursor.execute(f'''
            INSERT INTO company_profiles (user_id, {field_name}) VALUES (%s, %s)
            ON CONFLICT (user_id) DO UPDATE SET {field_name} = EXCLUDED.{field_name}
        ''', (user_id, field_value))

        conn.commit()
        await update.message.reply_text(f"{field_name.replace('_', ' ').title()} updated to: {field_value}")

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating {field_name}: {error}")
        await update.message.reply_text(f"An error occurred while updating {field_name.replace('_', ' ').title()}.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    # Return to the profile edit menu with options for the next field
    await update.message.reply_text(
        "Which field would you like to update next?",
        reply_markup=ReplyKeyboardMarkup([
            ["🏢 Company Name", "📅 Founding Year"],
            ["📝 Description", "🏭 Industry"],
            ["👔 CEO Name", "👥 Company Size"],
            ["🎁 Benefits", "📋 Open Positions"],
            ["💵 Salary Range", "🖼️ Company Logo"],
            ["📜 Certifications", "🔙 Back"]
        ], resize_keyboard=True)
    )

    return PROFILE_EDIT_MENU


# Fallback function for canceling the edit
async def cancel_editing(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text("Profile editing has been canceled.", reply_markup=ReplyKeyboardRemove())
    return


import re
from telegram import ReplyKeyboardMarkup

# Function to escape special characters for Telegram's MarkdownV2
def escape_markdown_v2(text):
    """Escapes special characters for Telegram's MarkdownV2 syntax."""
    return re.sub(r'([_*[\]()~>#+\-=|{}.!])', r'\\\1', text)

# Function to retrieve and display the company's contact information
async def add_company_contact_information(update, context):
    user_chat_id = update.message.chat_id  # Get the user's Telegram chat_id

    # Check if the user pressed the "🔙 Back" button
    if update.message.text == "🔙 Back":
        # Return to the PROFILE_MANAGEMENT state
        await update.message.reply_text(
            "Profile Management: Please choose an action.",
            reply_markup=ReplyKeyboardMarkup([
                ["➕🪪 Add Profile", "🏢 Company Profile"],
                ["➕📞 Add Contact", "🔙 Back"]

            ], resize_keyboard=True)
        )
        return PROFILE_MANAGEMENT

    # Connect to PostgreSQL database
    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Map chat_id to user_id in the users table
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return

        user_id = user_row[0]
        context.user_data["user_id"] = user_id  # Save user_id to context for later use

        # Fetch the company's contact information including phone number
        cursor.execute('''
            SELECT company_email, company_address, company_website, company_phone, company_country, company_city
            FROM company_profiles
            WHERE user_id = %s
        ''', (user_id,))
        profile_data = cursor.fetchone()

        # Prepare a list to hold the summary dynamically, only for non-empty fields
        profile_info_lines = []

        if profile_data:
            company_email, company_address, company_website, company_phone, company_country, company_city = profile_data

            if company_email:
                profile_info_lines.append(f"📧 *Email:* {escape_markdown_v2(company_email)}")
            if company_address:
                profile_info_lines.append(f"🏠 *Address:* {escape_markdown_v2(company_address)}")
            if company_phone:
                profile_info_lines.append(f"📞 *Phone:* {escape_markdown_v2(company_phone)}")
            if company_website:
                profile_info_lines.append(f"🌐 *Website:* {escape_markdown_v2(company_website)}")
            if company_country:
                profile_info_lines.append(f"🌍 *Country:* {escape_markdown_v2(company_country)}")
            if company_city:
                profile_info_lines.append(f"🏙️ *City:* {escape_markdown_v2(company_city)}")
        else:
            # If no profile data is found, notify the user
            await update.message.reply_text("No contact information found for this company.")

        # Join all non-empty fields into a single string separated by new lines
        if profile_info_lines:
            profile_info = "\n\n".join(profile_info_lines)
            await update.message.reply_text(f"Here is the contact information:\n\n{profile_info}", parse_mode='MarkdownV2')

    except (Exception, psycopg2.DatabaseError) as error:
        print(f"Error fetching contact information: {error}")
        await update.message.reply_text("An error occurred while retrieving your contact information.")
        return

    finally:
        if conn:
            cursor.close()
            conn.close()

    # The buttons to update contact information should appear regardless of data
    await update.message.reply_text(
        "Which field would you like to update?",
        reply_markup=ReplyKeyboardMarkup([
            ["📧 Email", "🏠 Address"],
            ["📞 Phone", "🌐 Website"],
            ["🌍 Country", "🏙️ City"],
            ["🔙 Back"]
        ], resize_keyboard=True)
    )

    return PROFILE_CONTACT_MENU

from telegram import ReplyKeyboardMarkup

# Function to show the company contact information menu
async def show_company_contact_information_menu(update, context) -> int:
    await update.message.reply_text(
        "Which field would you like to update?",
        reply_markup=ReplyKeyboardMarkup([
            ["📧 Email", "🏠 Address"],
            ["📞 Phone", "🌐 Website"],
            ["🌍 Country", "🏙️ City"],
            ["🔙 Back"]
        ], resize_keyboard=True)
    )

    return PROFILE_CONTACT_MENU

from telegram import ReplyKeyboardMarkup

# Function to show the contact information menu
def contact_information_menu():
    return ReplyKeyboardMarkup([
        ["📧 Email", "🏠 Address"],
        ["📞 Phone", "🌐 Website"],
        ["🌍 Country", "🏙️ City"],
        ["🔙 Back"]
    ], resize_keyboard=True)


from telegram import ReplyKeyboardMarkup
import re

# Function to ask for company email
async def ask_for_company_email(update, context):
    await update.message.reply_text(
        "Please enter the new Company Email (or press 'Back' to return):",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return COMPANY_EMAIL


# Function to ask for company address
async def ask_for_company_address(update, context):
    await update.message.reply_text(
        "Please enter the Company Address (or press 'Back' to return):",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return COMPANY_ADDRESS


# Function to ask for company phone
async def ask_for_company_phone(update, context):
    await update.message.reply_text(
        "Please enter the Company Phone Number (or press 'Back' to return):",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return COMPANY_PHONE


# Function to ask for company website
async def ask_for_company_website(update, context):
    await update.message.reply_text(
        "Please enter the Company Website (or press 'Back' to return):",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return COMPANY_WEBSITE


async def ask_for_company_country(update: Update, context: CallbackContext) -> int:
    """
    Fetch and display countries dynamically from the database for company country input.
    """
    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch active countries from the database
        cursor.execute("SELECT country_name FROM countries WHERE is_active = TRUE ORDER BY country_name ASC;")
        countries = [row[0] for row in cursor.fetchall()]

        if not countries:
            # No active countries available
            await update.message.reply_text(
                "No active countries are available at the moment. Please try again later."
            )
            return  # End the conversation if no data is available

        # Save valid countries to context for validation
        context.user_data["valid_countries"] = countries

        # Prepare keyboard buttons (2 columns per row)
        country_buttons = [countries[i:i+2] for i in range(0, len(countries), 2)]
        country_buttons.append(["🔙 Back"])  # Add a "Back" button for navigation

        # Create reply markup with country buttons
        reply_markup = ReplyKeyboardMarkup(country_buttons, resize_keyboard=True)

        # Send the country selection prompt
        await update.message.reply_text(
            "Please select the Country:",
            reply_markup=reply_markup
        )
        return COMPANY_COUNTRY  # State to capture country input

    except (Exception, psycopg2.DatabaseError) as error:
        # Log and handle database errors
        logger.error(f"Database error while fetching countries: {error}")
        await update.message.reply_text(
            "An error occurred while fetching countries. Please try again later."
        )
        return   # End the conversation gracefully on error

    finally:
        # Ensure the database connection is closed
        if conn:
            cursor.close()
            conn.close()



async def ask_for_company_city(update: Update, context: CallbackContext) -> int:
    """
    Fetch and display cities dynamically from the database for company city input.
    """
    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432",
        )
        cursor = conn.cursor()

        # Fetch cities from the database
        cursor.execute("SELECT city_name FROM locations ORDER BY city_name ASC;")
        cities = [row[0] for row in cursor.fetchall()]

        if not cities:
            # No cities found in the database
            await update.message.reply_text(
                "No cities are available at the moment. Please try again later."
            )
            return COMPANY_MENU  # Return to the main company menu

        # Save valid cities to context for validation
        context.user_data["valid_cities"] = cities

        # Prepare keyboard buttons (2 columns per row)
        city_buttons = [cities[i:i+2] for i in range(0, len(cities), 2)]
        city_buttons.append(["Other"])  # Add an "Other" option for manual input
        city_buttons.append(["🔙 Back"])  # Add a "Back" button

        # Create the reply markup with city buttons
        reply_markup = ReplyKeyboardMarkup(city_buttons, resize_keyboard=True)

        # Send the city selection prompt
        await update.message.reply_text(
            "Please select the City or choose 'Other' to manually enter:",
            reply_markup=reply_markup
        )
        return COMPANY_CITY  # State to capture city input

    except (Exception, psycopg2.DatabaseError) as error:
        # Log and handle any database errors
        logger.error(f"Database error while fetching cities: {error}")
        await update.message.reply_text(
            "An error occurred while fetching cities. Please try again later."
        )
        return COMPANY_MENU  # Return to the main company menu

    finally:
        # Close the database connection
        if conn:
            cursor.close()
            conn.close()



import re
import psycopg2

# Function to save the company email to the database
async def save_company_email(update, context):
    user_chat_id = update.message.chat_id
    new_email = update.message.text  # Get the new email entered by the user

    # Check if the user pressed the "Back" button
    if new_email.lower() == "🔙 back":
        return await show_company_contact_information_menu(update, context)

    # Verify that the input is a valid email
    if not re.match(r"[^@]+@[^@]+\.[^@]+", new_email):
        await update.message.reply_text("Please enter a valid email address.")
        return COMPANY_EMAIL

    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch the user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return

        user_id = user_row[0]

        # Update the company email in the database
        cursor.execute('UPDATE company_profiles SET company_email = %s WHERE user_id = %s', (new_email, user_id))
        conn.commit()

        # Notify the user that the email has been updated
        await update.message.reply_text(f"The company email has been updated to: {new_email}")

    except (Exception, psycopg2.DatabaseError) as error:
        print(f"Error updating company email: {error}")
        await update.message.reply_text("An error occurred while updating the company email.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    # After saving, take the user back to the Profile Contact Menu
    return await show_company_contact_information_menu(update, context)


# Function to save the company address to the database
async def save_company_address(update, context):
    user_chat_id = update.message.chat_id
    new_address = update.message.text  # Get the new address entered by the user

    # Check if the user pressed the "Back" button
    if new_address.lower() == "🔙 back":
        return await show_company_contact_information_menu(update, context)

    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch the user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return

        user_id = user_row[0]

        # Update the company address in the database
        cursor.execute('UPDATE company_profiles SET company_address = %s WHERE user_id = %s', (new_address, user_id))
        conn.commit()

        # Notify the user that the address has been updated
        await update.message.reply_text(f"The company address has been updated to: {new_address}")

    except (Exception, psycopg2.DatabaseError) as error:
        print(f"Error updating company address: {error}")
        await update.message.reply_text("An error occurred while updating the company address.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    # After saving, take the user back to the Profile Contact Menu
    return await show_company_contact_information_menu(update, context)


# Function to save the company phone number to the database
async def save_company_phone(update, context):
    user_chat_id = update.message.chat_id
    new_phone = update.message.text  # Get the new phone number entered by the user

    # Check if the user pressed the "Back" button
    if new_phone.lower() == "🔙 back":
        return await show_company_contact_information_menu(update, context)

    # Verify that the input is a valid phone number (basic validation)
    if not re.match(r'^\+?[0-9\s\-]+$', new_phone):
        await update.message.reply_text("Please enter a valid phone number.")
        return COMPANY_PHONE

    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch the user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return

        user_id = user_row[0]

        # Update the company phone number in the database
        cursor.execute('UPDATE company_profiles SET company_phone = %s WHERE user_id = %s', (new_phone, user_id))
        conn.commit()

        # Notify the user that the phone number has been updated
        await update.message.reply_text(f"The company phone number has been updated to: {new_phone}")

    except (Exception, psycopg2.DatabaseError) as error:
        print(f"Error updating company phone: {error}")
        await update.message.reply_text("An error occurred while updating the company phone.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    # After saving, take the user back to the Profile Contact Menu
    return await show_company_contact_information_menu(update, context)


import re
from telegram import ReplyKeyboardMarkup

# Function to save the company website to the database
async def save_company_website(update, context):
    user_chat_id = update.message.chat_id
    new_website = update.message.text  # Get the new website URL entered by the user

    # Check if the user pressed the "Back" button
    if new_website.lower() == "🔙 back":
        return await show_company_contact_information_menu(update, context)

    # Improved URL validation regex pattern
    url_pattern = re.compile(
        r'^(https?://)?(www\.)?([a-zA-Z0-9-]+\.[a-zA-Z]{2,})(/[^\s]*)?$'
    )

    # Verify that the input is a valid URL
    if not re.match(url_pattern, new_website):
        await update.message.reply_text("Please enter a valid website URL.")
        return COMPANY_WEBSITE

    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch the user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return

        user_id = user_row[0]

        # Update the company website in the database
        cursor.execute('UPDATE company_profiles SET company_website = %s WHERE user_id = %s', (new_website, user_id))
        conn.commit()

        # Notify the user that the website has been updated
        await update.message.reply_text(f"The company website has been updated to: {new_website}")

    except (Exception, psycopg2.DatabaseError) as error:
        print(f"Error updating company website: {error}")
        await update.message.reply_text("An error occurred while updating the company website.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    # After saving, take the user back to the Profile Contact Menu
    return await show_company_contact_information_menu(update, context)



# Function to save the company country with validation against database values
async def save_company_country(update: Update, context: CallbackContext) -> int:
    """
    Save the selected company country to the database.
    """
    user_chat_id = update.message.chat_id
    selected_country = update.message.text.strip()  # Get the selected country

    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 1: Fetch the list of valid countries from the database
        cursor.execute("SELECT DISTINCT country_name FROM countries ORDER BY country_name ASC;")
        valid_countries = [row[0] for row in cursor.fetchall()]

        # Add the "Back" option
        valid_countries.append("🔙 Back")

        # Step 2: Validate user input
        if selected_country not in valid_countries:
            await update.message.reply_text(
                "⚠️ Invalid input. Please select a country from the options provided.",
                reply_markup=ReplyKeyboardMarkup(
                    [[country] for country in valid_countries],
                    resize_keyboard=True,
                    one_time_keyboard=True
                )
            )
            return COMPANY_COUNTRY  # Keep the user in the same state for re-selection

        # Step 3: Handle the "Back" button
        if selected_country == "🔙 Back":
            return await show_company_contact_information_menu(update, context)

        # Step 4: Fetch the user_id based on chat_id
        cursor.execute("SELECT user_id FROM users WHERE contact = %s", (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text(
                "🤷🏾‍♂️ You are not registered in our system. Please complete your registration."
            )
            return

        user_id = user_row[0]

        # Step 5: Update the company country in the database
        cursor.execute(
            "UPDATE company_profiles SET company_country = %s, updated_at = NOW() WHERE user_id = %s",
            (selected_country, user_id)
        )
        conn.commit()

        # Notify the user of the successful update
        await update.message.reply_text(
            f"The company country has been successfully updated to: *{selected_country}*.",
            parse_mode="Markdown"
        )

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating company country: {error}")
        await update.message.reply_text(
            "🤷🏾‍♂️ An error occurred while updating the company country. Please try again later."
        )

    finally:
        # Ensure the database connection is closed
        if conn:
            cursor.close()
            conn.close()

    # After saving, navigate back to the Profile Contact Menu
    return await show_company_contact_information_menu(update, context)


async def save_company_city(update: Update, context: CallbackContext) -> int:
    """
    Save the company city to the database based on the user's choice.
    """
    user_chat_id = update.message.chat_id
    selected_city = update.message.text.strip()  # Get the selected city

    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Step 1: Fetch the list of valid cities from the database
        cursor.execute("SELECT DISTINCT city_name FROM locations ORDER BY city_name ASC;")
        valid_cities = [row[0] for row in cursor.fetchall()]

        # Add the "Back" option
        valid_cities.append("🔙 Back")

        # Step 2: Validate user input
        if selected_city not in valid_cities:
            await update.message.reply_text(
                "⚠️ Invalid input. Please select a city from the options provided.",
                reply_markup=ReplyKeyboardMarkup(
                    [[city] for city in valid_cities],
                    resize_keyboard=True,
                    one_time_keyboard=True
                )
            )
            return COMPANY_CITY  # Keep the user in the same state for re-selection

        # Step 3: Handle the "Back" button
        if selected_city == "🔙 Back":
            return await show_company_contact_information_menu(update, context)

        # Step 4: Fetch the user_id based on chat_id
        cursor.execute("SELECT user_id FROM users WHERE contact = %s", (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text(
                "🤷🏾‍♂️ You are not registered in our system. Please complete your registration."
            )
            return

        user_id = user_row[0]

        # Step 5: Update the company city in the database
        cursor.execute(
            "UPDATE company_profiles SET company_city = %s, updated_at = NOW() WHERE user_id = %s",
            (selected_city, user_id)
        )
        conn.commit()

        # Notify the user of the successful update
        await update.message.reply_text(
            f"The company city has been successfully updated to: *{selected_city}*.",
            parse_mode="Markdown"
        )

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Error updating company city: {error}")
        await update.message.reply_text(
            "🤷🏾‍♂️ An error occurred while updating the company city. Please try again later."
        )

    finally:
        # Ensure the database connection is closed
        if conn:
            cursor.close()
            conn.close()

    # Return the user to the Profile Contact Menu
    return await show_company_contact_information_menu(update, context)

import re
import logging
import psycopg2
from telegram import ReplyKeyboardMarkup, InlineKeyboardButton, Update
from telegram.ext import CallbackContext, ConversationHandler
from datetime import date

# Function to escape special characters for Telegram's MarkdownV2
def escape_markdown_v2(text):
    """Escapes special characters for Telegram's MarkdownV2 syntax."""
    return re.sub(r'([_*[\]()~`>#+\-=|{}.!])', r'\\\1', str(text))

# Function to show the employer profile without editing options
async def show_employer_profile(update: Update, context: CallbackContext) -> int:
    user_chat_id = update.message.chat_id

    # Check if the user pressed the "🔙 Back" button
    if update.message.text == "🔙 Back":
        return show_profile_management_menu(update, context)

    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch the user_id and verification status based on chat_id
        cursor.execute('''
            SELECT users.user_id, company_profiles.is_verified
            FROM users
            LEFT JOIN company_profiles ON users.user_id = company_profiles.user_id
            WHERE users.contact = %s
        ''', (str(user_chat_id),))
        user_data = cursor.fetchone()

        if not user_data:
            await update.message.reply_text("You are not registered. Please register.")
            return

        user_id, is_verified = user_data

        # Handle "Get Verified" button press
        if update.message.text == "✅ Get Verified":
            if is_verified:
                await update.message.reply_text("You are already verified! ✅")
                return VIEW_PROFILE
            else:
                await update.message.reply_text(
                    "✋🏾 Your verification request is being processed. Please wait for an admin to review.")
                await request_verification(update, context)
                return VIEW_PROFILE

        # Fetch employer (company) profile details for the current user
        cursor.execute('''
            SELECT company_name, company_ceo_name, company_founding_year, industry, company_size, 
                   employee_benefits, average_salary_range, number_of_open_positions, company_email, 
                   company_phone, company_website, company_country, company_city, company_address, 
                   social_media_links, company_video_url, company_logo, company_certifications, 
                   company_description, employer_name, employer_position, employer_contact, 
                   employer_gender, employer_city, employer_country, employer_email, employer_dob, 
                   employer_contact, is_verified
            FROM company_profiles
            WHERE user_id = %s
        ''', (user_id,))
        profile_data = cursor.fetchone()

        if not profile_data:
            await update.message.reply_text("You do not have a company profile yet.")
        else:
            # Determine if the company is verified and add badge if true
            underscore_line = f"{'\\_' * 30}\n\n"  # Escaped underscores
            verified_badge = f"{underscore_line}✅ *Verified Company*\n\n" if profile_data[-1] else ""

            # Company Overview Section (only show if data exists)
            company_overview = f"*Company Overview*\n\n" \
                               f"🏢 *Company Name:* {escape_markdown_v2(profile_data[0])}\n\n" if profile_data[0] else ""
            location = f"📍 *Location:* {escape_markdown_v2(profile_data[12])}, {escape_markdown_v2(profile_data[11])}\n\n" if profile_data[11] and profile_data[12] else ""
            address = f"🏠 *Address:* {escape_markdown_v2(profile_data[13])}\n\n" if profile_data[13] else ""
            website = f"🌐 *Website:* {escape_markdown_v2(profile_data[10])}\n\n" if profile_data[10] else ""
            # Add "+" sign to phone numbers if not present
            phone_number = profile_data[9]
            if phone_number and not phone_number.startswith("+"):
                phone_number = f"+{phone_number}"

            phone = f"📞 *Phone Number:* {escape_markdown_v2(phone_number)}\n\n" if phone_number else ""
            email = f"✉️ *Email:* {escape_markdown_v2(profile_data[8])}\n\n" if profile_data[8] else ""

            # Company Description Section (only show if data exists)
            company_description = f"\n*Company Description*\n\n" \
                                  f"📝 *Description:* {escape_markdown_v2(profile_data[18])}\n\n" if profile_data[18] else ""
            company_size = f"👥 *Company Size:* {escape_markdown_v2(profile_data[4])}\n\n" if profile_data[4] else ""
            founding_year = f"📅 *Founded:* {escape_markdown_v2(profile_data[2])}\n\n" if profile_data[2] else ""
            industry = f"🏭 *Industry:* {escape_markdown_v2(profile_data[3])}\n\n" if profile_data[3] else ""
            ceo_name = f"👔 *CEO:* {escape_markdown_v2(profile_data[1])}\n\n" if profile_data[1] else ""
            benefits = f"🎁 *Benefits:* {escape_markdown_v2(profile_data[5])}\n\n" if profile_data[5] else ""
            open_positions = f"📋 *Open Positions:* {escape_markdown_v2(profile_data[7])}\n\n" if profile_data[7] else ""
            salary_range = f"💵 *Salary Range:* {escape_markdown_v2(profile_data[6])}\n\n" if profile_data[6] else ""

            # Employer Information Section (only show if data exists)
            employer_gender = profile_data[22]  # Corrected indexing for employer gender
            gender_icon = {
                "male": "👨🏾",
                "female": "👩🏾"
            }.get(employer_gender.strip().lower(), "👤") if employer_gender else "👤"

            employer_info = f"\n*Employer Information*\n\n" \
                            f"{gender_icon} *Employer Name:* {escape_markdown_v2(profile_data[19])}\n\n" if profile_data[19] else ""
            employer_position = f"💼 *Position:* {escape_markdown_v2(profile_data[20])}\n\n" if profile_data[20] else ""
            employer_contact = f"📞 *Contact:* {escape_markdown_v2(profile_data[27])}\n\n" if profile_data[27] else "📞 *Contact:* Not available\n\n"
            employer_email = f"✉️ *Email:* {escape_markdown_v2(profile_data[25])}\n\n" if profile_data[25] else ""
            employer_city = f"🏙️ *City:* {escape_markdown_v2(profile_data[23])}\n\n" if profile_data[24] else ""
            employer_country = f"🌍 *Country:* {escape_markdown_v2(profile_data[24])}\n\n" if profile_data[23] else ""

            # Verification Files Section (only show if data exists)
            verification_files = "\n*Verification Files*\n\n" if profile_data[16] or profile_data[17] else ""
            inline_buttons = []

            if profile_data[16]:  # Company Logo
                verification_files += f"🖼️ *Company Logo:* Available\n\n"
                inline_buttons.append([InlineKeyboardButton("Download Logo", callback_data=f"download_logo_{user_id}")])

            if profile_data[17]:  # Company Certifications
                verification_files += f"📜 *Certifications:* Available\n"
                inline_buttons.append([InlineKeyboardButton("Download Certifications", callback_data=f"download_certifications_{user_id}")])

            # Add invisible section at the bottom
            invisible_section = "\u200B\n"  # Zero-width space

            # Combine all sections into the final profile with verified badge at the end
            profile_info = f"{company_overview}{location}{address}{website}{phone}{email}" \
                           f"{company_description}{company_size}{founding_year}{industry}{ceo_name}{benefits}{open_positions}{salary_range}" \
                           f"{employer_info}{employer_position}{employer_contact}{employer_email}{employer_city}{employer_country}{verification_files}{verified_badge}{invisible_section}"

            # Send profile summary with dynamic buttons
            await update.message.reply_text(
                f"Here is your company profile:\n\n{profile_info}",
                parse_mode='MarkdownV2',
                reply_markup=InlineKeyboardMarkup(inline_buttons) if inline_buttons else None
            )

    except (Exception, psycopg2.DatabaseError) as error:
        logging.error(f"Error fetching company profile: {error}")
        await update.message.reply_text("An error occurred while retrieving your profile.")
        return

    finally:
        if conn:
            cursor.close()
            conn.close()

    # Show the "Back" and "Get Verified" buttons
    await update.message.reply_text(
        "Choose an option:",
        reply_markup=ReplyKeyboardMarkup([
            ["🔙 Back", "✅ Get Verified"]
        ], resize_keyboard=True)
    )

    return VIEW_PROFILE




from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import CallbackContext
import psycopg2
import logging

# Handler for downloading the company logo
async def handle_download_logo(update: Update, context: CallbackContext) -> None:
    """Handle the download of the company logo."""
    query = update.callback_query
    user_id = query.data.split("_")[-1]  # Extract the user_id from callback data

    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve the company logo file for the user
        cursor.execute('SELECT company_logo FROM company_profiles WHERE user_id = %s', (user_id,))
        logo_row = cursor.fetchone()

        if not logo_row or not logo_row[0]:
            await query.answer("No logo file found.", show_alert=True)
            return

        logo_file = logo_row[0]

        # Send the logo file to the user as a reply
        await context.bot.send_document(
            chat_id=query.message.chat_id,
            document=logo_file,
            caption="Here is the company logo.",
            reply_to_message_id=query.message.message_id
        )

        await query.answer()  # Acknowledge button press

    except Exception as e:
        logging.error(f"Error downloading logo: {e}")
        await query.message.reply_text("An error occurred while retrieving the logo.")
    finally:
        if conn:
            cursor.close()
            conn.close()


# Handler for downloading the company certifications
async def handle_download_certifications(update: Update, context: CallbackContext) -> None:
    """Handle the download of company certifications."""
    query = update.callback_query
    user_id = query.data.split("_")[-1]  # Extract the user_id from callback data

    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve the company certifications file for the user
        cursor.execute('SELECT company_certifications FROM company_profiles WHERE user_id = %s', (user_id,))
        cert_row = cursor.fetchone()

        if not cert_row or not cert_row[0]:
            await query.answer("🤷🏾‍♂️ No certifications file found.", show_alert=True)
            return

        cert_file = cert_row[0]

        # Send the certifications file to the user as a reply
        await context.bot.send_document(
            chat_id=query.message.chat_id,
            document=cert_file,
            caption="Here are the company certifications.",
            reply_to_message_id=query.message.message_id
        )

        await query.answer()  # Acknowledge button press

    except Exception as e:
        logging.error(f"Error downloading certifications: {e}")
        await query.message.reply_text("An error occurred while retrieving the certifications.")
    finally:
        if conn:
            cursor.close()
            conn.close()


from telegram import InlineKeyboardButton, InlineKeyboardMarkup

async def request_verification(update: Update, context: CallbackContext):
    user_chat_id = update.message.chat_id

    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch the user_id based on chat_id
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(user_chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register.")
            return

        user_id = user_row[0]

        # Fetch employer (company) profile for the current user
        cursor.execute('''
            SELECT company_name, company_ceo_name, company_founding_year, industry, company_size, 
                   employee_benefits, average_salary_range, number_of_open_positions, company_email, 
                   company_phone, company_website, company_country, company_city, company_address, 
                   social_media_links, company_video_url, company_logo, company_certifications, 
                   company_description, employer_name, employer_position, employer_contact, 
                   employer_gender, employer_city, employer_country, employer_email, employer_dob
            FROM company_profiles
            WHERE user_id = %s
        ''', (user_id,))
        profile_data = cursor.fetchone()

        if not profile_data:
            await update.message.reply_text("You do not have a company profile yet.")
            return

        # Check if required fields are filled (including checking for empty strings)
        required_fields = [
            profile_data[0],  # company_name
            profile_data[9],  # company_phone
            profile_data[3],  # industry
            profile_data[11], # company_country
            profile_data[12], # company_city
            profile_data[18], # company_description
            profile_data[17], # company_certifications
            profile_data[19], # employer_name
            profile_data[20], # employer_position
            profile_data[21], # employer_contact
            profile_data[24], # employer_email
            profile_data[23]  # employer_gender
        ]

        # Check for any NULL or empty string in the required fields
        missing_fields = []

        # Check if required fields are NULL or empty
        for field, name in zip(required_fields, [
            "Company Name", "Company Phone Number", "Industry", "Country", "City", "Description",
            "Certifications", "Employer Name", "Employer Position", "Employer Contact",
            "Employer Email", "Employer Gender"
        ]):
            if not field or (isinstance(field, str) and field.strip() == ""):
                missing_fields.append(f"- {name}")  # Add dot before each field name

        # Special check for company_certifications (file path must exist and be non-empty)
        if not profile_data[17] or (isinstance(profile_data[17], str) and profile_data[17].strip() == ""):
            missing_fields.append("- Certifications (Must be uploaded)")

        if missing_fields:
            # Notify the user of missing fields
            missing_fields_message = "\n".join(missing_fields)
            await update.message.reply_text(f"⚠️ Your profile is missing the following information:\n{missing_fields_message}.\n💡 Please complete your profile before requesting verification.")
            return

        # Construct the verification message with all profile fields organized under section headers
        gender_icon = {
            "male": "👨🏾",
            "female": "👩🏾"
        }.get(profile_data[22].strip().lower(), "👤") if profile_data[22] else "👤"

        verification_message = (
            f"*Verification Request*\n\n"

            # Company Overview Section
            f"*Company Overview*\n\n"
            f"🏢 *Company Name:* {escape_markdown_v2(str(profile_data[0]))}\n\n"
            f"📍 *Location:* {escape_markdown_v2(str(profile_data[12]))}, {escape_markdown_v2(str(profile_data[11]))}\n\n"
            f"🏠 *Address:* {escape_markdown_v2(str(profile_data[13]))}\n\n"
            f"🌐 *Website:* {escape_markdown_v2(str(profile_data[10]))}\n\n"
            f"📞 *Phone Number:* {escape_markdown_v2(str(profile_data[9]))}\n\n"
            f"✉️ *Email:* {escape_markdown_v2(str(profile_data[8]))}\n\n\n"  # Additional newline between sections

            # Company Description Section
            f"*Company Description*\n\n"
            f"📝 *Description:* {escape_markdown_v2(str(profile_data[18]))}\n\n"
            f"👥 *Company Size:* {escape_markdown_v2(str(profile_data[4]))}\n\n"
            f"📅 *Founded:* {escape_markdown_v2(str(profile_data[2]))}\n\n"
            f"🏭 *Industry:* {escape_markdown_v2(str(profile_data[3]))}\n\n"
            f"👔 *CEO:* {escape_markdown_v2(str(profile_data[1]))}\n\n"
            f"🎁 *Benefits:* {escape_markdown_v2(str(profile_data[5]))}\n\n"
            f"📋 *Open Positions:* {escape_markdown_v2(str(profile_data[7]))}\n\n"
            f"💵 *Salary Range:* {escape_markdown_v2(str(profile_data[6]))}\n\n\n"  # Additional newline between sections

            # Employer Information Section
            f"*Employer Information*\n\n"
            f"{gender_icon} *Employer Name:* {escape_markdown_v2(str(profile_data[19]))}\n\n"
            f"💼 *Position:* {escape_markdown_v2(str(profile_data[20]))}\n\n"
            f"📞 *Contact:* {escape_markdown_v2(str(profile_data[21]))}\n\n"
            f"🏙️ *City:* {escape_markdown_v2(str(profile_data[23]))}\n\n"
            f"🌍 *Country:* {escape_markdown_v2(str(profile_data[24]))}\n\n"
            f"✉️ *Email:* {escape_markdown_v2(str(profile_data[25]))}\n\n"
            f"📅 *Date of Birth:* {escape_markdown_v2(str(profile_data[26]))}\n\n\n"  # Additional newline between sections

            # Verification Files Section
            f"*Verification Files*\n\n"
        )

        # Inline keyboard with buttons for downloads, approve, and deny
        inline_buttons = []

        # Add the download buttons if logo or certifications exist
        if profile_data[16]:  # company_logo
            verification_message += f"🖼️ *Company Logo:* Available\n\n"
            inline_buttons.append([InlineKeyboardButton("Download Logo", callback_data=f"download_logo_{user_id}")])

        if profile_data[17]:  # company_certifications
            verification_message += f"📜 *Certifications:* Available\n"
            inline_buttons.append([InlineKeyboardButton("Download Certifications", callback_data=f"download_certifications_{user_id}")])

        # Add the Approve and Deny buttons
        inline_buttons.append([
            InlineKeyboardButton("Approve", callback_data=f"approve_verification_{user_id}"),
            InlineKeyboardButton("Deny", callback_data=f"deny_verification_{user_id}")
        ])

        reply_markup = InlineKeyboardMarkup(inline_buttons)

        # Send the verification request to admin with the inline keyboard
        await context.bot.send_message(
            chat_id=ADMIN_ID,
            text=verification_message,
            parse_mode='MarkdownV2',
            reply_markup=reply_markup
        )

        # Notify the user
        await update.message.reply_text(
            "🙋🏾‍♂️ Your verification request has been sent to the admin. You will be notified once verified.")

    except (Exception, psycopg2.DatabaseError) as error:
        logging.error(f"Error during verification request: {error}")
        await update.message.reply_text("An error occurred while processing your verification request.")
    finally:
        if conn:
            cursor.close()
            conn.close()



from telegram import Update
from telegram.ext import CallbackContext
import psycopg2


# Callback function for approving verification
async def approve_verification(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    # Extract user_id from callback data (e.g., "approve_verification_{user_id}")
    data = query.data
    user_id = int(data.split("_")[-1])

    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Update the verification status in the company_profiles table
        cursor.execute('''
            UPDATE company_profiles
            SET is_verified = TRUE
            WHERE user_id = %s
        ''', (user_id,))
        conn.commit()

        # Notify the admin of successful approval
        await query.edit_message_text("The company has been successfully verified.")

        # Notify the user about the verification approval
        cursor.execute('SELECT contact FROM users WHERE user_id = %s', (user_id,))
        user_contact = cursor.fetchone()

        if user_contact:
            user_chat_id = user_contact[0]
            await context.bot.send_message(
                chat_id=user_chat_id,
                text="Congratulations! Your company has been verified by the admin."
            )

    except (Exception, psycopg2.DatabaseError) as error:
        logging.error(f"Error during company verification approval: {error}")
        await query.edit_message_text("An error occurred while approving the verification.")

    finally:
        if conn:
            cursor.close()
            conn.close()


# Function to handle verification denial
async def deny_verification(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    # Extract user_id from callback data (e.g., "deny_verification_{user_id}")
    data = query.data
    user_id = int(data.split("_")[-1])

    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Update the verification status if needed (e.g., set `is_verified` to `FALSE`)
        cursor.execute('''
            UPDATE company_profiles
            SET is_verified = FALSE
            WHERE user_id = %s
        ''', (user_id,))
        conn.commit()

        # Notify the admin of the denial action
        await query.edit_message_text("The verification request has been denied.")

        # Retrieve the user's contact info to notify them
        cursor.execute('SELECT contact FROM users WHERE user_id = %s', (user_id,))
        user_contact = cursor.fetchone()

        if user_contact:
            user_chat_id = user_contact[0]
            # Send a notification to the user about the denial
            await context.bot.send_message(
                chat_id=user_chat_id,
                text="We regret to inform you that your company verification request has been denied. Please contact support for further assistance."
            )

    except (Exception, psycopg2.DatabaseError) as error:
        logging.error(f"Error during verification denial: {error}")
        await query.edit_message_text("An error occurred while processing the denial request.")

    finally:
        if conn:
            cursor.close()
            conn.close()



from telegram import InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import ConversationHandler

import asyncio  # Required for adding delay


import asyncio
from telegram import ReplyKeyboardMarkup, InlineKeyboardMarkup, InlineKeyboardButton

async def handle_manage_job_payments(update, context):
    """Fetch and display unpaid job postings for payment management with pagination."""
    # Check if the Back button is pressed
    if update.message.text == "🔙 Back":
        return await handle_back_button_for_job_payments(update, context)

    # Determine if the update is a CallbackQuery or a Message
    if hasattr(update, "effective_user"):
        telegram_chat_id = update.effective_user.id  # For Message objects
        is_initial_request = True  # Indicates this is the initial request
    else:
        telegram_chat_id = update.from_user.id  # For CallbackQuery objects
        is_initial_request = False  # Indicates this is a subsequent request (Show More)

    logger.debug(f"Telegram Chat ID: {telegram_chat_id}")

    # Initialize or reset pagination offset
    if "unpaid_jobs_offset" not in context.user_data:
        context.user_data["unpaid_jobs_offset"] = 0

    offset = context.user_data["unpaid_jobs_offset"]

    # Set up the Back button keyboard
    back_keyboard = ReplyKeyboardMarkup(
        [["🔙 Back"]],
        resize_keyboard=True
    )

    # Display the countdown message if it's the initial request
    if is_initial_request:
        countdown_seconds = 4
        countdown_message = await update.message.reply_text(
            (
                "📋 *Pending Job Payments:*\n\n"
                "Below is the list of jobs awaiting payment to go live. Please review the details and complete the payment process to publish your job postings.\n\n"
                f"⌛ *This message will disappear in {countdown_seconds} seconds...*"
            ),
            parse_mode="Markdown"
        )

        # Update the message every second to show the countdown
        for i in range(countdown_seconds - 1, 0, -1):
            await asyncio.sleep(1)
            try:
                await countdown_message.edit_text(
                    text=(
                        "📋 *Pending Job Payments:*\n\n"
                        "Below is the list of jobs awaiting payment to go live. Please review the details and complete the payment process to publish your job postings.\n\n"
                        f"⌛ *This message will disappear in {i} seconds...*"
                    ),
                    parse_mode="Markdown"
                )
            except Exception as e:
                logger.error(f"Error updating countdown message: {e}")
                break

        # Delete the message after the countdown
        await asyncio.sleep(1)
        try:
            await countdown_message.delete()
        except Exception as e:
            logger.error(f"Error deleting message: {e}")

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve user_id from the database
        cursor.execute('''
            SELECT user_id
            FROM users
            WHERE contact = %s::text
        ''', (telegram_chat_id,))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text(
                "🤷🏾‍♂️ User not found. Please register first.",
                reply_markup=back_keyboard
            )
            return MANAGE_JOB_PAYMENTS

        user_id = user_row[0]
        logger.debug(f"User ID retrieved: {user_id}")

        # Log total unpaid jobs for the user
        cursor.execute('''
            SELECT COUNT(*)
            FROM job_posts
            WHERE user_id = %s AND payment_status = 'Unpaid'
        ''', (user_id,))
        total_jobs = cursor.fetchone()[0]
        logger.debug(f"Total unpaid jobs for user {user_id}: {total_jobs}")

        # Fetch paginated unpaid job posts
        cursor.execute('''
            SELECT jp.job_id, jp.job_title, jp.created_at, jp.payment_status
            FROM job_posts jp
            WHERE jp.user_id = %s AND jp.payment_status = 'Unpaid'
            ORDER BY jp.created_at ASC
            LIMIT %s OFFSET %s
        ''', (user_id, ITEMS_PER_PAGE, offset))
        job_posts = cursor.fetchall()

        logger.debug(f"Unpaid jobs retrieved with LIMIT={ITEMS_PER_PAGE}, OFFSET={offset}: {job_posts}")

        # Check if there are unpaid job posts to display
        if not job_posts:
            if offset == 0:
                await update.message.reply_text(
                    "You have no unpaid job postings to manage payments for.",
                    reply_markup=back_keyboard
                )
            else:
                await update.message.reply_text(
                    "No more unpaid job postings to display.",
                    reply_markup=back_keyboard
                )
            return MANAGE_JOB_PAYMENTS

        # Display each unpaid job post with a "Make Payment" button
        for job_id, job_title, posted_date, payment_status in job_posts:
            posted_date_str = posted_date.strftime("%Y-%m-%d") if posted_date else "Not Available"
            message = (
                f"🏷️ *Job Title:* {job_title or 'N/A'}\n\n"
                f"📄 *Job ID:* {job_id}\n\n"
                f"📅 *Posted Date:* {posted_date_str}\n\n"
                f"💳 *Payment Status:* {payment_status}\n"
            )

            keyboard = InlineKeyboardMarkup(
                [[InlineKeyboardButton("Make Payment", callback_data=f"make_payment:{job_id}")]]
            )
            await update.message.reply_text(
                text=message,
                reply_markup=keyboard,
                parse_mode="Markdown"
            )

        # Update offset for pagination
        context.user_data["unpaid_jobs_offset"] += ITEMS_PER_PAGE

        # Display Show More button if more unpaid job posts exist
        if context.user_data["unpaid_jobs_offset"] < total_jobs:
            show_more_keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("Show More", callback_data="show_more_unpaid_jobs")]
            ])
            await update.message.reply_text(
                "Press Show More to load more unpaid job postings.",
                reply_markup=show_more_keyboard
            )
        else:
            await update.message.reply_text(
                "No more unpaid job postings to display.",
                reply_markup=back_keyboard
            )

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error: {error}")
        await update.message.reply_text(
            "An error occurred while retrieving job postings. Please try again later.",
            reply_markup=back_keyboard
        )
    finally:
        if conn:
            cursor.close()
            conn.close()

    # Ensure Back button message is at the bottom
    await update.message.reply_text(
        "The following jobs are pending payment. Please complete the payment process to proceed.",
        reply_markup=back_keyboard
    )

    return MANAGE_JOB_PAYMENTS


async def handle_back_button_for_job_payments(update, context):
    """
    Handle the Back button press, clear context.user_data, and navigate to the Billing & Payments menu.
    """
    # Clear the context.user_data to reset user-specific state
    context.user_data.clear()

    # Redirect the user to the Billing & Payments menu
    return await handle_back_to_billing(update, context)


async def handle_show_more_unpaid_jobs(update, context):
    query = update.callback_query
    await query.answer()

    # Call handle_manage_job_payments for the next batch
    return await handle_manage_job_payments(query, context)


async def handle_back_to_billing(update, context):
    # Define the Billing & Payments menu keyboard
    billing_keyboard = ReplyKeyboardMarkup([
        ["💳 Make Payments", "📜 Payment History"],
        ["⭐ Upgrade to Premium", "📈 Payment Stat"],
        ["🔙 Back"]
    ], resize_keyboard=True)

    # Send a message with the billing keyboard
    await update.message.reply_text(
        "You are back in the Billing & Payments menu. Please choose an option:",
        reply_markup=billing_keyboard
    )

    # End the current state to allow other handlers to take over
    return BILLING_PAYMENTS



import psycopg2
from telegram import InlineKeyboardMarkup, InlineKeyboardButton, Update
from telegram.ext import CallbackContext

DB_CONFIG = {
    "dbname": "my_project_db",
    "user": "postgres",
    "password": "1201",
    "host": "localhost",
    "port": "5432",
}

# Function to fetch payment details from the database
def fetch_payment_details():
    """Fetch payment details from the database."""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()
        query = "SELECT bank_name, account_name, account_number, amount FROM payment_details LIMIT 1;"
        cursor.execute(query)
        payment_details = cursor.fetchone()
        cursor.close()
        conn.close()
        return payment_details
    except Exception as e:
        print(f"Error fetching payment details: {e}")
        return None

async def handle_make_payment(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    # Extract the job_id from the callback data
    _, job_id = query.data.split(":")

    # Fetch payment details from the database
    payment_details = fetch_payment_details()
    if not payment_details:
        await query.edit_message_text(
            text="Payment details are not available at the moment. Please try again later.",
            parse_mode="Markdown"
        )
        return

    # Extract payment details
    bank_name, account_name, account_number, amount = payment_details

    # Construct the payment instructions
    message = (
        f"💳 *Payment Instructions*\n\n"
        f"🏦 *Bank Name:* {bank_name}\n\n"
        f"👤 *Account Name:* {account_name}\n\n"
        f"🔢 *Account Number:* {account_number}\n\n"
        f"💵 *Amount to Pay:* {amount}\n\n"
        f"Once you've made the payment, please upload the screenshot of your payment confirmation using the button below."
    )

    # Inline button to upload payment screenshot
    keyboard = InlineKeyboardMarkup(
        [[InlineKeyboardButton("Upload Payment Screenshot", callback_data=f"upload_payment_job:{job_id}")]]
    )

    # Edit the inline message to include payment instructions
    await query.edit_message_text(
        text=message,
        reply_markup=keyboard,
        parse_mode="Markdown"
    )
    return UPLOAD_PAYMENT_SCREENSHOT  # Correct state

async def handle_upload_payment(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    # Extract job_id from the callback data
    _, job_id = query.data.split(":")
    logger.debug(f"Extracted job_id for payment upload: {job_id}")

    # Save job_id in the context for tracking
    context.user_data['payment_job_id'] = job_id
    logger.debug(f"Saved payment_job_id in context: {context.user_data}")

    # Prompt the user to upload the screenshot
    await query.edit_message_text(
        text=(
            "📤 *Upload Payment Screenshot*\n\n"
            "To complete your payment process, please upload the payment confirmation screenshot for your job post.\n\n"
            "1. Tap on the attachment icon (📎) located near the message input field.\n"
            "2. Select the *photo* option to upload your screenshot.\n"
            "3. Once the upload is complete, we will verify your payment and update the status.\n\n"
            "If you encounter any issues, please contact our support team."
        ),
        parse_mode="Markdown",
        reply_markup=None  # Remove the inline keyboard
    )

    return UPLOAD_PAYMENT_SCREENSHOT  # Ensure this state is mapped correctly in ConversationHandler



from telegram import ReplyKeyboardMarkup, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import ConversationHandler

async def handle_payment_screenshot(update, context):
    logger.debug(f"Context user data: {context.user_data}")

    # Set up the Back button keyboard
    back_keyboard = ReplyKeyboardMarkup(
        [["🔙 Back"]],
        resize_keyboard=True
    )

    # Retrieve job_id from context
    job_id = context.user_data.get('payment_job_id')
    if not job_id:
        logger.error("payment_job_id is missing from context.user_data.")
        await update.message.reply_text("An error occurred. No job ID found. Please try again.", reply_markup=back_keyboard)
        return

    logger.debug(f"Handling payment screenshot for job_id: {job_id}")

    # Verify that a photo is uploaded
    if update.message.photo:
        # Get the highest resolution photo
        photo = update.message.photo[-1]
        file_id = photo.file_id
        logger.debug(f"Received photo with file_id: {file_id}")
    else:
        logger.error("No photo found in the update message.")
        await update.message.reply_text("Please upload a valid image file.", reply_markup=back_keyboard)
        return UPLOAD_PAYMENT_SCREENSHOT

    try:
        # Database connection
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Verify job exists
        logger.debug("Checking for job details in the database.")
        cursor.execute('''
            SELECT jp.job_title, jp.user_id, u.contact
            FROM job_posts jp
            JOIN users u ON jp.user_id = u.user_id
            WHERE jp.job_id = %s
        ''', (job_id,))
        row = cursor.fetchone()

        if not row:
            logger.error(f"No job found in the database for job_id: {job_id}.")
            await update.message.reply_text("🤷🏾‍♂️ No job found for this ID. Please contact support.", reply_markup=back_keyboard)
            return

        job_title, user_id, employer_contact = row
        logger.debug(f"Job found: {job_title}, User ID: {user_id}, Employer Contact: {employer_contact}")

        # Insert payment record
        logger.debug("Inserting payment details into the database.")
        cursor.execute('''
            INSERT INTO job_payments (job_id, user_id, payment_screenshot, payment_status, payment_date)
            VALUES (%s, %s, %s, %s, NOW())
            RETURNING payment_id
        ''', (job_id, user_id, file_id, "pending"))
        payment_id = cursor.fetchone()[0]
        conn.commit()
        logger.debug(f"Payment record created with payment_id: {payment_id}")

        # Notify the user
        await update.message.reply_text(
            (
                "✅ *Payment Screenshot Uploaded!*\n\n"
                "Thank you for uploading your payment confirmation. Our admin team will review it shortly.\n\n"
                "If you need assistance or have questions, feel free to contact support using the menu options.\n\n"
                "🔙 Press *Back* to return to the previous menu."
            ),
            parse_mode="Markdown",
            reply_markup=back_keyboard  # Add Back button here
        )

        # Notify the admin
        admin_message = (
            f"💳 *New Payment Submitted*\n\n"
            f"🏷️ *Job Title:* {job_title}\n"
            f"📄 *Job ID:* {job_id}\n"
            f"💰 *Payment ID:* {payment_id}\n"
            f"📄 *Payment Status:* Pending"
        )
        admin_buttons = InlineKeyboardMarkup([
            [InlineKeyboardButton("✅ Confirm Payment", callback_data=f"confirm_payment:{job_id}:{payment_id}:{employer_contact}")],
            [InlineKeyboardButton("❌ Reject Payment", callback_data=f"reject_payment:{job_id}:{payment_id}:{employer_contact}")]
        ])
        await context.bot.send_photo(
            chat_id=ADMIN_ID,
            photo=file_id,
            caption=admin_message,
            reply_markup=admin_buttons,
            parse_mode="Markdown"
        )

    except psycopg2.Error as e:
        logger.error(f"Database error: {e}")
        await update.message.reply_text("An error occurred while saving the payment screenshot. Please try again.", reply_markup=back_keyboard)
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        await update.message.reply_text("An unexpected error occurred. Please try again.", reply_markup=back_keyboard)
    finally:
        if conn:
            cursor.close()
            conn.close()

    # Return to the same state to allow handling further actions (like pressing Back)
    return UPLOAD_PAYMENT_SCREENSHOT



async def handle_confirm_payment(update, context):
    query = update.callback_query
    await query.answer()

    # Extract job_id, payment_id, and employer_contact from callback data
    _, job_id, payment_id, employer_contact = query.data.split(":")
    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Update payment status in job_posts and job_payments
        cursor.execute('''
            UPDATE job_posts
            SET payment_status = 'paid'
            WHERE job_id = %s
        ''', (job_id,))
        cursor.execute('''
            UPDATE job_payments
            SET payment_status = 'paid'
            WHERE payment_id = %s
        ''', (payment_id,))
        conn.commit()

        # Fetch job details
        cursor.execute('''
            SELECT job_title, payment_status
            FROM job_posts
            WHERE job_id = %s
        ''', (job_id,))
        job_details = cursor.fetchone()

        if not job_details:
            await query.edit_message_caption(
                caption="❌ An error occurred: Job details not found.",
                parse_mode="Markdown"
            )
            return

        job_title, payment_status = job_details

        # Update the admin's message
        updated_message = (
            f"✅ *Payment Confirmed!*\n\n"
            f"🏷️ *Job Title:* {job_title}\n"
            f"📄 *Job ID:* {job_id}\n"
            f"💰 *Payment ID:* {payment_id}\n"
            f"📄 *Payment Status:* {payment_status}\n"
        )

        await query.edit_message_caption(
            caption=updated_message,
            parse_mode="Markdown",
            reply_markup=None  # Remove the inline buttons
        )

        # Notify the employer
        await context.bot.send_message(
            chat_id=int(employer_contact),
            text=(
                "✅ *Payment Confirmed!*\n\n"
                "We have successfully verified your payment. Your job post is now live and visible to potential applicants.\n\n"
                "Thank you for choosing our platform to connect with top talent!"
            ),
            parse_mode="Markdown"
        )

    except Exception as e:
        logger.error(f"Error during payment confirmation: {e}")
        await query.edit_message_caption(
            caption="❌ An error occurred while confirming the payment.",
            parse_mode="Markdown"
        )
    finally:
        if conn:
            cursor.close()
            conn.close()

async def handle_reject_payment(update, context):
    query = update.callback_query
    await query.answer()

    # Extract job_id, payment_id, and employer_contact from callback data
    _, job_id, payment_id, employer_contact = query.data.split(":")
    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Update payment status in job_payments
        cursor.execute('''
            UPDATE job_payments
            SET payment_status = 'rejected'
            WHERE payment_id = %s
        ''', (payment_id,))
        conn.commit()

        # Notify the admin
        await query.edit_message_caption(
            caption="❌ Payment rejected. The employer has been notified.",
            parse_mode="Markdown"
        )

        # Notify the employer
        await context.bot.send_message(
            chat_id=int(employer_contact),
            text="❌ Your payment has been rejected. Please contact support for more details."
        )

    except Exception as e:
        logger.error(f"Database error: {e}")
        await query.edit_message_caption(
            caption="❌ An error occurred while rejecting the payment.",
            parse_mode="Markdown"
        )
    finally:
        if conn:
            cursor.close()
            conn.close()

ITEMS_PER_PAGE = 2

async def handle_view_payment_history(update, context):
    # Check if the Back button is pressed
    if update.message.text == "🔙 Back":
        return await handle_back_button(update, context)

    # Determine if the update is a CallbackQuery or a Message
    if hasattr(update, "effective_user"):
        telegram_chat_id = update.effective_user.id  # For Message objects
    else:
        telegram_chat_id = update.from_user.id  # For CallbackQuery objects

    logger.debug(f"Telegram Chat ID: {telegram_chat_id}")

    # Initialize or reset pagination offset
    if not context.user_data.get("payment_history_offset"):
        context.user_data["payment_history_offset"] = 0

    offset = context.user_data["payment_history_offset"]

    # Set up the Back button keyboard
    back_keyboard = ReplyKeyboardMarkup(
        [["🔙 Back"]],
        resize_keyboard=True
    )

    # Send the back button immediately
    await update.message.reply_text(
        "Loading your payment history...",
        reply_markup=back_keyboard
    )

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve user_id from the users table
        cursor.execute('''
            SELECT user_id
            FROM users
            WHERE contact = %s::text
        ''', (telegram_chat_id,))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text(
                "User not found. Please register first."
            )
            return VIEW_PAYMENT_HISTORY

        user_id = user_row[0]
        logger.debug(f"User ID retrieved: {user_id}")

        # Fetch all job payment history
        cursor.execute('''
            SELECT 'job_payment' AS type, jp.job_title, jp.job_id, jp.created_at, 
                   p.payment_date, COALESCE(p.amount, 100) AS amount, 
                   COALESCE(p.currency, 'ETB') AS currency, p.payment_status, 
                   COALESCE(p.payment_method, 'manual') AS payment_method
            FROM job_payments p
            JOIN job_posts jp ON p.job_id = jp.job_id
            WHERE p.user_id = %s
            ORDER BY p.payment_date DESC
        ''', (user_id,))
        job_payment_history = cursor.fetchall()
        logger.debug(f"Job payment history retrieved: {job_payment_history}")

        # Fetch all premium package history
        cursor.execute('''
            SELECT 'package' AS type, package_name, purchase_date, 
                   expiration_date, package_type, amount, payment_status
            FROM premium_payments
            WHERE user_id = %s
            ORDER BY purchase_date DESC
        ''', (user_id,))
        package_history = cursor.fetchall()
        logger.debug(f"Premium package purchase history retrieved: {package_history}")

        # Combine both histories into one list
        combined_history = job_payment_history + package_history
        logger.debug(f"Combined history before pagination: {combined_history}")

        # Apply pagination
        paginated_history = combined_history[offset:offset + ITEMS_PER_PAGE]

        # Check if there is any history to display
        if not paginated_history:
            if offset == 0:
                await update.message.reply_text(
                    "You have no payment or purchase history."
                )
            else:
                await update.message.reply_text(
                    "No more entries to display."
                )
            return VIEW_PAYMENT_HISTORY

        # Display paginated history
        for entry in paginated_history:
            entry_type = entry[0]
            if entry_type == 'job_payment':
                # Unpack job payment entry
                _, job_title, job_id, created_at, payment_date, amount, currency, payment_status, payment_method = entry
                created_at_str = created_at.strftime("%Y-%m-%d") if created_at else "Not Available"
                payment_date_str = payment_date.strftime("%Y-%m-%d %H:%M:%S") if payment_date else "Not Available"
                amount_str = f"{amount:.2f} {currency}"

                message = (
                    f"🏷️ *Job Title:* {job_title or 'N/A'}\n"
                    f"📄 *Job ID:* {job_id}\n"
                    f"📅 *Job Created Date:* {created_at_str}\n"
                    f"💳 *Payment Date:* {payment_date_str}\n"
                    f"💰 *Amount:* {amount_str}\n"
                    f"📄 *Payment Status:* {payment_status}\n"
                    f"💳 *Payment Method:* {payment_method}\n"
                )
            elif entry_type == 'package':
                # Unpack premium package entry
                _, package_name, purchase_date, expiration_date, package_type, amount, payment_status = entry
                purchase_date_str = purchase_date.strftime("%Y-%m-%d %H:%M:%S") if purchase_date else "Not Available"
                expiration_date_str = expiration_date.strftime("%Y-%m-%d %H:%M:%S") if expiration_date else "Not Available"
                amount_str = f"{amount:.2f} ETB"

                message = (
                    f"📦 *Package Name:* {package_name}\n"
                    f"📅 *Purchase Date:* {purchase_date_str}\n"
                    f"⏳ *Expiration Date:* {expiration_date_str}\n"
                    f"📝 *Package Type:* {package_type}\n"
                    f"💰 *Amount:* {amount_str}\n"
                    f"📄 *Payment Status:* {payment_status}\n"
                )
            await update.message.reply_text(
                text=message,
                parse_mode="Markdown"
            )

        # Update offset for pagination
        context.user_data["payment_history_offset"] += ITEMS_PER_PAGE

        # Display Show More button if more entries exist
        if context.user_data["payment_history_offset"] < len(combined_history):
            show_more_keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("Show More", callback_data="show_more_payment_history")]
            ])
            await update.message.reply_text(
                "Press Show More to load more entries, or Back to return.",
                reply_markup=show_more_keyboard
            )
        else:
            await update.message.reply_text(
                "No more entries to display."
            )

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error: {error}")
        await update.message.reply_text(
            "An error occurred while retrieving your history. Please try again later."
        )
    finally:
        if conn:
            cursor.close()
            conn.close()

    return VIEW_PAYMENT_HISTORY

async def handle_back_button(update, context):
    """
    Handle the Back button press, reset context.user_data, and navigate to the Billing & Payments menu.
    """
    # Clear the context.user_data to reset user-specific state
    context.user_data.clear()

    # Redirect the user to the Billing & Payments menu
    return await handle_back_to_billing(update, context)


async def handle_show_more_payment_history(update, context):
    query = update.callback_query
    await query.answer()

    # Call handle_view_payment_history for the next batch
    return await handle_view_payment_history(query, context)

from telegram import ReplyKeyboardMarkup

async def handle_payment_stat(update, context):
    telegram_chat_id = update.effective_user.id  # Fetch the Telegram chat ID

    logger.debug(f"Telegram Chat ID: {telegram_chat_id}")

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve user_id from the users table
        cursor.execute('''
            SELECT user_id
            FROM users
            WHERE contact = %s::text
        ''', (telegram_chat_id,))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("User not found. Please register first.")
            return

        user_id = user_row[0]
        logger.debug(f"User ID retrieved: {user_id}")

        # Calculate the total amount paid for single job posts
        cursor.execute('''
            SELECT COALESCE(SUM(amount), 0) AS total_amount
            FROM job_payments
            WHERE user_id = %s AND payment_status = 'paid'
        ''', (user_id,))
        job_payment_total = cursor.fetchone()
        job_payment_amount = job_payment_total[0] if job_payment_total else 0

        logger.debug(f"Total amount for job posts: {job_payment_amount}")

        # Calculate the total amount paid for packages
        cursor.execute('''
            SELECT COALESCE(SUM(amount), 0) AS total_amount
            FROM premium_payments
            WHERE user_id = %s AND payment_status = 'Paid'
        ''', (user_id,))
        package_payment_total = cursor.fetchone()
        package_payment_amount = package_payment_total[0] if package_payment_total else 0

        logger.debug(f"Total amount for packages: {package_payment_amount}")

        # Retrieve the active package details
        cursor.execute('''
            SELECT package_name, job_post_limit, repost_limit, featured_visibility_limit, package_expiration
            FROM package_usage
            WHERE user_id = %s AND package_expiration > NOW()
            LIMIT 1
        ''', (user_id,))
        package_details = cursor.fetchone()

        if package_details:
            package_name, job_post_limit, repost_limit, featured_visibility_limit, package_expiration = package_details
            package_section = (
                f"📦 *Active Package:* {package_name}\n"
                f"📝 *Job Posts Remaining:* {job_post_limit}\n"
                f"♻️ *Reposts Remaining:* {repost_limit}\n"
                f"🌟 *Featured Visibility Remaining:* {featured_visibility_limit}\n"
                f"⏳ *Expiration Date:* {package_expiration.strftime('%Y-%m-%d')}\n\n"
            )
        else:
            package_section = "📦 *Active Package:* None\n🔔 Consider purchasing a package for more benefits!\n\n"

        # Prepare the message
        message = (
            "*Payment Statistics:*\n\n"
            f"💼 *Total Paid for Job Posts:* {job_payment_amount:.2f} ETB\n"
            f"📦 *Total Paid for Packages:* {package_payment_amount:.2f} ETB\n"
            f"💳 *Grand Total Paid:* {job_payment_amount + package_payment_amount:.2f} ETB\n\n"
            f"{package_section}"
        )

        # Back button keyboard
        back_keyboard = ReplyKeyboardMarkup(
            [["🔙 Back"]],
            resize_keyboard=True
        )

        # Send the statistics with the Back button
        await update.message.reply_text(
            text=message,
            parse_mode="Markdown",
            reply_markup=back_keyboard
        )

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error: {error}")
        await update.message.reply_text("An error occurred while retrieving your payment statistics. Please try again later.")
    finally:
        if conn:
            cursor.close()
            conn.close()

    # Return the new state
    return PAYMENT_STAT_BACK

async def handle_back_from_payment_stat(update, context):
    """
    Handle the Back button press from the Payment Statistics state.
    """
    # Clear user-specific state
    context.user_data.clear()

    # Redirect to the billing menu
    return await handle_back_to_billing(update, context)




import asyncio
import psycopg2
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update, ReplyKeyboardMarkup
from telegram.ext import CallbackContext

DB_CONFIG = {
    "dbname": "my_project_db",
    "user": "postgres",
    "password": "1201",
    "host": "localhost",
    "port": "5432",
}

# Function to fetch premium packages from the database
def fetch_premium_packages():
    """Fetch all premium packages from the database."""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()
        query = "SELECT name, price, features, callback_data FROM packages ORDER BY package_id;"
        cursor.execute(query)
        packages = cursor.fetchall()
        cursor.close()
        conn.close()

        # Transform fetched data into a list of dictionaries
        return [
            {
                "name": package[0],
                "price": package[1],
                "features": package[2],
                "callback_data": package[3],
            }
            for package in packages
        ]
    except Exception as e:
        print(f"Error fetching packages: {e}")
        return []

async def show_premium_packages(update: Update, context: CallbackContext) -> int:
    """Display premium packages dynamically fetched from the database."""
    # Fetch packages from the database
    packages = fetch_premium_packages()
    if not packages:
        await update.message.reply_text("No premium packages are available at the moment.")
        return SELECT_PREMIUM_PACKAGE

    # Display the introductory message with a countdown
    countdown_seconds = 4
    intro_message = await update.message.reply_text(
        text=(
            f"🎉 *Discover Our Premium Packages!*\n\n"
            f"🔑 Choose the package that fits your hiring needs:\n"
            f"- *Basic Package:* For startups and small businesses.\n"
            f"- *Standard Package:* For growing companies.\n"
            f"- *Premium Package:* For enterprises with large-scale hiring.\n\n"
            f"⌛ *This message will disappear in {countdown_seconds} seconds...*\n"
        ),
        parse_mode="Markdown"
    )

    # Update the message every second to show the countdown
    for i in range(countdown_seconds - 1, 0, -1):
        await asyncio.sleep(1)
        try:
            await context.bot.edit_message_text(
                chat_id=update.message.chat_id,
                message_id=intro_message.message_id,
                text=(
                    f"🎉 *Discover Our Premium Packages!*\n\n"
                    f"🔑 Choose the package that fits your hiring needs:\n"
                    f"- *Basic Package:* For startups and small businesses.\n"
                    f"- *Standard Package:* For growing companies.\n"
                    f"- *Premium Package:* For enterprises with large-scale hiring.\n\n"
                    f"⌛ *This message will disappear in {i} seconds...*\n"
                ),
                parse_mode="Markdown"
            )
        except Exception as e:
            print(f"Error updating countdown message: {e}")
            break

    # Delete the message after the countdown
    await asyncio.sleep(1)
    try:
        await context.bot.delete_message(chat_id=update.message.chat_id, message_id=intro_message.message_id)
    except Exception as e:
        print(f"Error deleting message: {e}")

    # Define Back button keyboard
    back_keyboard = ReplyKeyboardMarkup(
        [["🔙 Back"]],
        resize_keyboard=True
    )

    # Display Back button message
    await update.message.reply_text(
        "Here are the packages tailored to your needs.",
        parse_mode="Markdown",
        reply_markup=back_keyboard
    )

    # Send each package as a separate message with its own button
    for package in packages:
        features_formatted = "\n".join(package["features"])  # Format features as a list
        message = f"""
*{package['name']}*  
💵 *Price:* {package['price']} ETB/year  
📜 *Features:*  
{features_formatted}
        """
        inline_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(f"🛒 Buy {package['name']}", callback_data=package["callback_data"])]
        ])
        await update.message.reply_text(
            text=message.strip(),
            reply_markup=inline_keyboard,
            parse_mode="Markdown"
        )

    return SELECT_PREMIUM_PACKAGE



async def handle_back_button_for_premium_packages(update, context):
    """
    Handle the Back button press from the Premium Packages menu and redirect to Billing & Payments.
    """
    # Clear context.user_data to reset any premium package-related state
    context.user_data.clear()

    # Redirect the user to the Billing & Payments menu
    return await handle_back_to_billing(update, context)



async def handle_package_purchase(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()  # Acknowledge the callback query

    # Extract the selected package from the callback data
    selected_package = query.data.split(":")[1]

    # Package details
    packages = {
        "basic": {"name": "Basic Package", "amount": 5000},
        "standard": {"name": "Standard Package", "amount": 10000},
        "premium": {"name": "Premium Package", "amount": 15000},
    }

    if selected_package not in packages:
        await query.edit_message_text("Invalid package selection. Please try again.")
        return

    package_details = packages[selected_package]
    context.user_data['selected_package'] = selected_package  # Save the selected package

    # Professional payment instructions
    payment_instructions = f"""
*You selected the {package_details['name']}.*

💳 *Amount to Pay:* {package_details['amount']} ETB

Please make the payment to the following bank account:

🏦 *Bank Name:* XYZ Bank  

📄 *Account Name:* Afro JobLink  

🔢 *Account Number:* 1234567890

After making the payment, please upload the payment screenshot by clicking the button below.

*Note:* Payments are processed manually and may take up to 24 hours for verification.
"""

    # Send payment instructions with an "Upload Payment Screenshot" button
    await query.edit_message_text(
        text=payment_instructions,
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("Upload Payment Screenshot", callback_data=f"upload_payment:{selected_package}")],
        ]),
        parse_mode="Markdown"
    )

    return UPLOAD_PACKAGE_PAYMENT_SCREENSHOT  # Define this state for handling payment screenshots


async def handle_upload_payment_screenshot(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()

    # Retrieve the selected package from the context
    selected_package = context.user_data.get('selected_package')

    if not selected_package:
        await query.edit_message_text(
            text="An error occurred. Please start the process again."
        )
        return

    # Edit the existing message to prompt the user for the payment screenshot
    await query.edit_message_text(
        text= "📤 *Upload Payment Screenshot*\n\n"
            "To complete your payment process, please upload the payment confirmation screenshot for your job post.\n\n"
            "1. Tap on the attachment icon (📎) located near the message input field.\n"
            "2. Select the *photo* option to upload your screenshot.\n"
            "3. Once the upload is complete, we will verify your payment and update the status.\n\n"
            "If you encounter any issues, please contact our support team.",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("Cancel", callback_data="cancel_upload")]
        ])
    )

    return UPLOAD_PACKAGE_PAYMENT_SCREENSHOT



from telegram import ReplyKeyboardMarkup

from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import CallbackContext, ConversationHandler
import psycopg2
import logging

logger = logging.getLogger(__name__)

async def process_payment_screenshot(update: Update, context: CallbackContext) -> int:
    if update.message.photo:
        photo = update.message.photo[-1]
        file_id = photo.file_id

        try:
            # Connect to the database
            conn = psycopg2.connect(
                dbname="my_project_db",
                user="postgres",
                password="1201",
                host="localhost",
                port="5432"
            )
            cursor = conn.cursor()

            # Fetch user_id from the Telegram user_id
            telegram_user_id = update.message.from_user.id
            cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(telegram_user_id),))
            user_row = cursor.fetchone()

            if not user_row:
                await update.message.reply_text("User not found in the database. Please register first.")
                return

            user_id = user_row[0]

            # Fetch employer details
            cursor.execute('''
                SELECT u.first_name, u.last_name, u.phone_number, 
                       COALESCE(c.company_name, 'Not Available') AS company_name
                FROM users u
                LEFT JOIN company_profiles c ON u.user_id = c.user_id
                WHERE u.user_id = %s
            ''', (user_id,))
            employer_details = cursor.fetchone()

            if not employer_details:
                logger.error(f"No employer details found for user_id: {user_id}")
                await update.message.reply_text("Unable to fetch employer details. Please try again.")
                return

            first_name, last_name, phone_number, company_name = employer_details

            # Add "+" sign to phone number
            phone_number = f"+{phone_number}"

            # Fetch selected package details dynamically from the database
            selected_package = context.user_data.get('selected_package', 'basic')  # Default to 'basic' if not set
            cursor.execute('''
                SELECT TRIM(BOTH ' ' FROM REGEXP_REPLACE(name, '^[^a-zA-Z]+', '')) AS package_name, price 
                FROM packages WHERE callback_data = %s
            ''', (f"buy_package:{selected_package}",))
            package_row = cursor.fetchone()

            if not package_row:
                await update.message.reply_text("Invalid package selection. Please try again.")
                return

            package_name, amount = package_row

            # Insert payment record
            cursor.execute('''
                INSERT INTO premium_payments (user_id, package_name, amount, purchase_date, expiration_date, package_type, payment_screenshot, payment_status)
                VALUES (%s, %s, %s, NOW(), NOW() + INTERVAL '1 year', %s, %s, %s)
                RETURNING payment_id
            ''', (user_id, package_name, amount, 'Yearly', file_id, 'pending'))
            payment_id = cursor.fetchone()[0]
            conn.commit()

            # Build the admin message
            admin_message = (
                "💳 *New Payment Submitted*\n\n"
                f"*👤 Employer Name:* {first_name} {last_name}\n"
                f"*📱 Phone Number:* {phone_number}\n"
            )

            if company_name != "Not Available":
                admin_message += f"*🏢 Company Name:* {company_name}\n"

            admin_message += (
                f"*📦 Package:* {package_name}\n"
                f"*💰 Amount:* {amount} ETB\n"
                f"*📄 Payment ID:* {payment_id}\n"
                f"*📄 Payment Status:* Pending"
            )

            # Admin keyboard
            admin_keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("✅ Confirm", callback_data=f"confirm_payment:{payment_id}"),
                 InlineKeyboardButton("❌ Reject", callback_data=f"reject_payment:{payment_id}")]
            ])

            # Notify admin
            await context.bot.send_photo(
                chat_id=ADMIN_ID,
                photo=file_id,
                caption=admin_message,
                reply_markup=admin_keyboard,
                parse_mode="Markdown"
            )

            # Back button keyboard
            back_keyboard = ReplyKeyboardMarkup(
                [["🔙 Back"]],
                resize_keyboard=True
            )

            # Notify user with success message and Back button
            await update.message.reply_text(
                "Your payment screenshot has been uploaded successfully. "
                "Our team will review your payment within 24 hours.",
                reply_markup=back_keyboard
            )
        except Exception as e:
            logger.error(f"Error processing payment: {e}")
            await update.message.reply_text("An error occurred while saving your payment. Please try again.")
        finally:
            if conn:
                cursor.close()
                conn.close()
    else:
        await update.message.reply_text("Please upload a valid image file.")

    # Keep the user in the current state for Back button handling
    return UPLOAD_PACKAGE_PAYMENT_SCREENSHOT


import json
import re

async def confirm_premium_payment(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()  # Acknowledge the callback query

    try:
        # Extract payment_id from the callback data
        payment_id = query.data.split(":")[1]
    except IndexError:
        logger.error("Invalid callback data format. Expected 'confirm_payment:<payment_id>'")
        await query.message.reply_text("Invalid request format. Please try again.")
        return

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch payment details and employer chat_id
        cursor.execute(
            '''
            SELECT p.user_id, u.first_name, u.last_name, u.contact AS chat_id, 
                   COALESCE(c.company_name, 'Not Available') AS company_name,
                   p.package_name, p.amount, p.payment_status, u.phone_number
            FROM premium_payments p
            JOIN users u ON p.user_id = u.user_id
            LEFT JOIN company_profiles c ON u.user_id = c.user_id
            WHERE p.payment_id = %s
            ''',
            (payment_id,)
        )
        payment_details = cursor.fetchone()

        if not payment_details:
            await query.message.reply_text("Payment details not found. Please try again.")
            return

        user_id, first_name, last_name, chat_id, company_name, package_name, amount, payment_status, phone_number = payment_details

        if payment_status == "Paid":
            await query.message.reply_text("This payment is already confirmed.")
            return

        # Fetch package details dynamically from the packages table
        cursor.execute(
            '''
            SELECT REGEXP_REPLACE(name, '^[^a-zA-Z]+', '') AS normalized_name, features
            FROM packages
            WHERE REGEXP_REPLACE(name, '^[^a-zA-Z]+', '') = %s
            ''',
            (package_name,)
        )
        package_row = cursor.fetchone()

        if not package_row:
            await query.message.reply_text("Package details not found. Please try again.")
            return

        _, features = package_row

        # Parse the features and extract numeric values
        if isinstance(features, str):
            feature_list = json.loads(features)  # Parse stringified JSON
        elif isinstance(features, list):
            feature_list = features  # Already a Python list
        else:
            raise ValueError("Unsupported features format in the database.")

        # Remove emojis and extract numbers for each feature
        def extract_number(feature):
            # Remove all non-digit characters and return the integer value
            match = re.search(r'\d+', feature)
            return int(match.group()) if match else 0

        job_post_limit = extract_number(next((f for f in feature_list if "job posts" in f.lower()), "0"))
        repost_limit = extract_number(next((f for f in feature_list if "reposts" in f.lower()), "0"))
        featured_visibility_limit = extract_number(next((f for f in feature_list if "featured" in f.lower()), "0"))

        # Update the payment status to "Paid"
        cursor.execute(
            "UPDATE premium_payments SET payment_status = %s WHERE payment_id = %s",
            ("Paid", payment_id)
        )
        conn.commit()

        # Update or insert package usage
        cursor.execute(
            '''
            INSERT INTO package_usage (user_id, payment_id, job_post_limit, repost_limit, featured_visibility_limit, package_expiration, package_name)
            VALUES (%s, %s, %s, %s, %s, NOW() + INTERVAL '1 year', %s)
            ON CONFLICT (user_id) 
            DO UPDATE SET 
                job_post_limit = package_usage.job_post_limit + EXCLUDED.job_post_limit,
                repost_limit = package_usage.repost_limit + EXCLUDED.repost_limit,
                featured_visibility_limit = package_usage.featured_visibility_limit + EXCLUDED.featured_visibility_limit,
                package_expiration = EXCLUDED.package_expiration,
                package_name = EXCLUDED.package_name
            ''',
            (
                user_id,
                payment_id,
                job_post_limit,
                repost_limit,
                featured_visibility_limit,
                package_name,
            )
        )
        conn.commit()

        # Reset the notification_sent flag to FALSE
        cursor.execute(
            '''
            UPDATE package_usage
            SET notification_sent = FALSE
            WHERE user_id = %s
            ''',
            (user_id,)
        )
        conn.commit()

        # Construct the updated admin message
        admin_message = (
            "💳 *Payment Confirmed*\n\n"
            f"*👤 Employer Name:* {first_name} {last_name}\n"
            f"*📱 Phone Number:* {phone_number}\n"
        )

        if company_name != "Not Available":
            admin_message += f"*🏢 Company Name:* {company_name}\n"

        admin_message += (
            f"*📦 Package:* {package_name}\n"
            f"*💰 Amount:* {amount:.2f} ETB\n"
            f"*📄 Payment ID:* {payment_id}\n"
            f"*📄 Payment Status:* Paid"
        )

        # Update the admin message with the new status
        await query.edit_message_caption(
            caption=admin_message,
            parse_mode="Markdown",
            reply_markup=None  # Remove buttons after confirmation
        )

        # Notify the employer
        await context.bot.send_message(
            chat_id=int(chat_id),  # Use Telegram chat_id
            text=(
                f"🎉 Hello {first_name} {last_name},\n\n"
                f"Your payment (ID: {payment_id}) for the {package_name} package has been successfully confirmed. "
                f"Your usage limits have been updated. Thank you for choosing our premium services!"
            )
        )

    except Exception as e:
        logger.error(f"Error confirming payment: {e}")
        await query.message.reply_text("An error occurred while confirming the payment. Please try again.")
    finally:
        if conn:
            cursor.close()
            conn.close()


import psycopg2
from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import CallbackContext

async def job_application_alerts(update: Update, context: CallbackContext, repeat_message: bool = True) -> int:
    user_contact = update.message.chat_id  # Match this with `contact` in the users table

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Find user_id in users table using contact (chat_id)
        cursor.execute("""
            SELECT user_id FROM users WHERE contact = %s::TEXT
        """, (user_contact,))
        user_id_row = cursor.fetchone()

        if not user_id_row:
            await update.message.reply_text("Your user record could not be found. Please register first.")
            return JOB_APPLICATION_ALERTS_MENU

        user_id = user_id_row[0]  # Extract the user_id

        # Fetch the current application_alerts status
        cursor.execute("""
            SELECT application_alerts FROM company_profiles WHERE user_id = %s
        """, (user_id,))
        alert_status_row = cursor.fetchone()

        if not alert_status_row:
            await update.message.reply_text("Company profile not found. Please complete your profile first.")
            return JOB_APPLICATION_ALERTS_MENU

        alert_status = alert_status_row[0]  # TRUE or FALSE

        # Dynamically adjust the keyboard
        turn_on_label = "✔️ Turn On Alerts" if alert_status else "Turn On Alerts"
        turn_off_label = "✔️ Turn Off Alerts" if not alert_status else "Turn Off Alerts"

        # Send the initial menu message only if `repeat_message` is True
        if repeat_message:
            await update.message.reply_text(
                """
<b>📬 Job Application Alerts</b>

📢 <b>Manage notifications for new job applications!</b>

This feature lets you choose how you want to be notified every time applicants apply for the jobs you’ve posted:

<b>Turn On Job Application Alerts</b>: Receive notifications with regular Telegram sounds and vibrations whenever a new application is submitted.

<b>Turn Off Job Application Alerts</b>: Receive notifications silently, without sound or vibration.

⚡ Customize your alert preferences to stay updated on applications in the way that suits you best.

👇🏾 <b>Select an option below to update your settings:</b>
                """,
                parse_mode="HTML",  # Use HTML for bold formatting
                reply_markup=ReplyKeyboardMarkup(
                    [[turn_on_label, turn_off_label], ["🔙 Back"]],
                    resize_keyboard=True
                ),
            )

        else:
            # Resend only the keyboard
            await update.message.reply_text(
                "Choose an option:",
                reply_markup=ReplyKeyboardMarkup(
                    [[turn_on_label, turn_off_label], ["🔙 Back"]],
                    resize_keyboard=True
                ),
            )
        return JOB_APPLICATION_ALERTS_MENU

    except psycopg2.Error as e:
        await update.message.reply_text("An error occurred while loading your preferences. Please try again.")
        print(f"Database error: {e}")
        return JOB_APPLICATION_ALERTS_MENU

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()


async def handle_back_button_for_job_alert(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Choose a notification option:",
        reply_markup=ReplyKeyboardMarkup(
            [
                ["📢 Application Alerts", "⏳ Post Expiry Alerts"],
                ["🔙 Back"]
            ],
            resize_keyboard=True
        )
    )
    return NOTIFICATIONS  # Define this as a state in the conversation handler


async def handle_alert_selection(update: Update, context: CallbackContext) -> int:
    user_contact = update.message.chat_id  # Match this with `contact` in the users table
    user_response = update.message.text.strip()

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Find user_id in users table using contact (chat_id)
        cursor.execute("""
            SELECT user_id FROM users WHERE contact = %s::TEXT
        """, (user_contact,))
        user_id_row = cursor.fetchone()

        if not user_id_row:
            await update.message.reply_text("Your user record could not be found. Please register first.")
            return JOB_APPLICATION_ALERTS_MENU

        user_id = user_id_row[0]  # Extract the user_id

        if user_response.startswith("Turn On Alerts") or user_response.startswith("✔️ Turn On Alerts"):
            # Update the database to enable alerts
            cursor.execute("""
                UPDATE company_profiles
                SET application_alerts = TRUE
                WHERE user_id = %s
            """, (user_id,))
            conn.commit()

            await update.message.reply_text("Job application alerts have been turned on.")
            return await job_application_alerts(update, context, repeat_message=False)

        elif user_response.startswith("Turn Off Alerts") or user_response.startswith("✔️ Turn Off Alerts"):
            # Update the database to disable alerts
            cursor.execute("""
                UPDATE company_profiles
                SET application_alerts = FALSE
                WHERE user_id = %s
            """, (user_id,))
            conn.commit()

            await update.message.reply_text("Job application alerts have been turned off.")
            return await job_application_alerts(update, context, repeat_message=False)

        elif user_response == "🔙 Back":
            return await handle_back_button_for_job_alert(update, context)  # Redirect to the back menu

        else:
            # Handle invalid response
            await update.message.reply_text("⚠️ Invalid response. Please select a valid option.")
            return JOB_APPLICATION_ALERTS_MENU

    except psycopg2.Error as e:
        await update.message.reply_text("An error occurred while updating your preferences. Please try again.")
        print(f"Database error: {e}")
        return JOB_APPLICATION_ALERTS_MENU

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()



async def post_expiry_alerts(update: Update, context: CallbackContext, repeat_message: bool = True) -> int:
    user_contact = update.message.chat_id  # Match this with `contact` in the users table

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Find user_id in users table using contact (chat_id)
        cursor.execute("""
            SELECT user_id FROM users WHERE contact = %s::TEXT
        """, (user_contact,))
        user_id_row = cursor.fetchone()

        if not user_id_row:
            await update.message.reply_text("Your user record could not be found. Please register first.")
            return POST_EXPIRY_ALERTS_MENU

        user_id = user_id_row[0]  # Extract the user_id

        # Fetch the current expiry_alerts status
        cursor.execute("""
            SELECT expiry_alerts FROM company_profiles WHERE user_id = %s
        """, (user_id,))
        alert_status_row = cursor.fetchone()

        if not alert_status_row:
            await update.message.reply_text("Company profile not found. Please complete your profile first.")
            return POST_EXPIRY_ALERTS_MENU

        alert_status = alert_status_row[0]  # TRUE or FALSE

        # Dynamically adjust the keyboard
        turn_on_label = "✔️ Turn On Alerts" if alert_status else "Turn On Alerts"
        turn_off_label = "✔️ Turn Off Alerts" if not alert_status else "Turn Off Alerts"

        # Send the initial menu message only if `repeat_message` is True
        if repeat_message:
            await update.message.reply_text(
                """
                <b>⚠️ Post Expiry Alerts</b>

📢 <b>Manage your notifications for expiring job posts!</b>

This feature lets you control whether you want to receive <b>normal notifications</b> or <b>silent alerts</b> for job posts nearing their application deadline.

<b>Turn On Expiry Alerts</b>: Receive reminders with regular Telegram notifications, including sound and vibration.

<b>Turn Off Expiry Alerts</b>: Receive reminders silently, without sound or vibration.

⚡ Customize your notification preference to stay informed about your job posts' deadlines in the way that works best for you.

👇🏾 <b>Choose an option below to update your preference:</b>
                """,
                parse_mode="HTML",  # Use HTML for formatting
                reply_markup=ReplyKeyboardMarkup(
                    [[turn_on_label, turn_off_label], ["🔙 Back"]],
                    resize_keyboard=True
                ),
            )

        else:
            # Resend only the keyboard
            await update.message.reply_text(
                "Choose an option:",
                reply_markup=ReplyKeyboardMarkup(
                    [[turn_on_label, turn_off_label], ["🔙 Back"]],
                    resize_keyboard=True
                ),
            )
        return POST_EXPIRY_ALERTS_MENU

    except psycopg2.Error as e:
        await update.message.reply_text("An error occurred while loading your preferences. Please try again.")
        print(f"Database error: {e}")
        return POST_EXPIRY_ALERTS_MENU

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

async def handle_expiry_alert_selection(update: Update, context: CallbackContext) -> int:
    user_contact = update.message.chat_id  # Match this with `contact` in the users table
    user_response = update.message.text.strip()

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Find user_id in users table using contact (chat_id)
        cursor.execute("""
            SELECT user_id FROM users WHERE contact = %s::TEXT
        """, (user_contact,))
        user_id_row = cursor.fetchone()

        if not user_id_row:
            await update.message.reply_text("Your user record could not be found. Please register first.")
            return POST_EXPIRY_ALERTS_MENU

        user_id = user_id_row[0]  # Extract the user_id

        if user_response.startswith("Turn On Alerts") or user_response.startswith("✔️ Turn On Alerts"):
            # Update the database to enable expiry alerts
            cursor.execute("""
                UPDATE company_profiles
                SET expiry_alerts = TRUE
                WHERE user_id = %s
            """, (user_id,))
            conn.commit()

            await update.message.reply_text("Post expiry alerts have been turned on.")
            return await post_expiry_alerts(update, context, repeat_message=False)

        elif user_response.startswith("Turn Off Alerts") or user_response.startswith("✔️ Turn Off Alerts"):
            # Update the database to disable expiry alerts
            cursor.execute("""
                UPDATE company_profiles
                SET expiry_alerts = FALSE
                WHERE user_id = %s
            """, (user_id,))
            conn.commit()

            await update.message.reply_text("Post expiry alerts have been turned off.")
            return await post_expiry_alerts(update, context, repeat_message=False)

        elif user_response == "🔙 Back":
            return await handle_back_button_for_job_alert(update, context)  # Redirect to the back menu


        else:
            # Handle invalid response
            await update.message.reply_text("⚠️ Invalid response. Please select a valid option.")
            return POST_EXPIRY_ALERTS_MENU

    except psycopg2.Error as e:
        await update.message.reply_text("An error occurred while updating your preferences. Please try again.")
        print(f"Database error: {e}")
        return POST_EXPIRY_ALERTS_MENU

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()



async def follow_up_notifications(update: Update, context: CallbackContext) -> int:
    user_id = update.message.chat_id

    # Example content for follow-up notifications management
    follow_up_info = """
    Applicant Follow-up Notifications:

    You can turn on or off follow-up notifications for applicants you are tracking.

    Please choose an option:
    1. Turn On Follow-up Notifications
    2. Turn Off Follow-up Notifications
    """

    await update.message.reply_text(follow_up_info, reply_markup=ReplyKeyboardMarkup([
        ["Turn On Follow-up Notifications", "Turn Off Follow-up Notifications"],
        ["Cancel"]
    ], resize_keyboard=True))

    return FOLLOW_UP_NOTIFICATIONS_MENU  # Define this state in the conversation handler


async def handle_follow_up_selection(update: Update, context: CallbackContext) -> int:
    user_response = update.message.text.strip()

    if user_response == "Turn On Follow-up Notifications":
        # Logic to turn on follow-up notifications
        await update.message.reply_text("Follow-up notifications have been turned on.")
        return await show_employer_menu(update, context)  # Go back to the employer menu
    elif user_response == "Turn Off Follow-up Notifications":
        # Logic to turn off follow-up notifications
        await update.message.reply_text("Follow-up notifications have been turned off.")
        return await show_employer_menu(update, context)  # Go back to the employer menu
    elif user_response == "Cancel":
        await update.message.reply_text("Follow-up notifications management has been canceled.")
        return await show_employer_menu(update, context)  # Go back to the employer menu
    else:
        # Handle invalid response
        await update.message.reply_text("Invalid response. Please select a valid option.")
        return FOLLOW_UP_NOTIFICATIONS_MENU  # Stay in the follow-up notifications menu state


async def toggle_notifications(update: Update, context: CallbackContext) -> int:
    user_id = update.message.chat_id

    # Example response for toggling notifications
    toggle_message = """
    Toggle Notifications:

    You can turn notifications on or off for the job application process.

    Please choose an option:
    1. Turn On Notifications
    2. Turn Off Notifications
    """

    await update.message.reply_text(toggle_message, reply_markup=ReplyKeyboardMarkup([
        ["Turn On Notifications", "Turn Off Notifications"],
        ["Cancel"]
    ], resize_keyboard=True))

    return TOGGLE_NOTIFICATIONS_MENU  # Set this state in the ConversationHandler

from datetime import datetime

async def handle_job_post_performance(update: Update, context: CallbackContext) -> int:
    chat_id = update.message.chat_id
    logger.debug(f"Employer's chat_id: {chat_id}")

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id from the users table using chat_id
        cursor.execute('''
            SELECT user_id FROM users WHERE contact = %s::text
        ''', (chat_id,))
        user_row = cursor.fetchone()

        if not user_row:
            logger.error(f"No user found in the database for chat_id: {chat_id}")
            await update.message.reply_text(
                "You are not registered in the system. Please contact support.",

            )
            return

        user_id = user_row[0]
        logger.debug(f"Employer's user_id: {user_id}")

        # Execute query to fetch only opened job posts and performance data
        logger.debug("Executing SQL query to fetch opened job posts...")
        cursor.execute('''
            SELECT 
                jp.job_id, jp.job_title, jp.repost_count, jp.job_application_deadline, 
                COUNT(a.application_id) AS applications_count,
                SUM(CASE WHEN a.status = 'shortlisted' THEN 1 ELSE 0 END) AS shortlisted_count,
                SUM(CASE WHEN a.status = 'pending' THEN 1 ELSE 0 END) AS pending_count,
                SUM(CASE WHEN a.status = 'hired' THEN 1 ELSE 0 END) AS hired_count,
                STRING_AGG(DISTINCT ap.location, ', ') AS top_locations,
                SUM(CASE WHEN ap.gender = 'Male' THEN 1 ELSE 0 END) AS male_applicants,
                SUM(CASE WHEN ap.gender = 'Female' THEN 1 ELSE 0 END) AS female_applicants
            FROM job_posts jp
            LEFT JOIN applications a ON jp.job_id = a.job_id
            LEFT JOIN applicant_profiles ap ON a.user_id = ap.user_id
            WHERE jp.user_id = %s AND jp.status_id = 5 -- Filter for 'opened' jobs
            GROUP BY jp.job_id, jp.job_title, jp.repost_count, jp.job_application_deadline
            ORDER BY jp.created_at DESC
        ''', (user_id,))
        job_posts = cursor.fetchall()
        logger.debug(f"Fetched opened job posts: {job_posts}")

        if not job_posts:
            await update.message.reply_text(
                "You currently have no opened job posts to track performance for.",

            )
            return

        # Send each job performance summary as a separate message
        today_date = datetime.now().date()
        for (
            job_id, job_title, repost_count, deadline, applications_count,
            shortlisted_count, pending_count, hired_count, top_locations,
            male_applicants, female_applicants
        ) in job_posts:
            days_until_expiry = (deadline - today_date).days if deadline else None

            # Dynamically build the message
            fields = [
                f"🏷️ *Job Title:* {job_title}" if job_title else None,
                f"📄 *Job ID:* {job_id}",
                f"📩 *Applications Received:* {applications_count}" if applications_count else None,
                f"🔎 *Shortlisted Applicants:* {shortlisted_count}" if shortlisted_count else None,
                f"⏳ *Pending Applications:* {pending_count}" if pending_count else None,
                f"✅ *Hired Candidates:* {hired_count}" if hired_count else None,
                f"♻️ *Reposts:* {repost_count}" if repost_count else None,
                f"🌍 *Top Locations:* {top_locations}" if top_locations else None,
                f"♂️ *Male Applicants:* {male_applicants}" if male_applicants else None,
                f"♀️ *Female Applicants:* {female_applicants}" if female_applicants else None,
                f"⌛ *Days Until Expiry:* {days_until_expiry} days" if days_until_expiry is not None else None,
            ]
            # Filter out fields that are None
            message = "\n\n".join(filter(None, fields)) + f"\n{'-' * 30}"

            await update.message.reply_text(
                message,
                parse_mode="Markdown",

            )

    except psycopg2.Error as e:
        logger.error(f"Database error: {e}")
        await update.message.reply_text(
            "An error occurred while fetching your job performance data. Please try again later.",

        )
    finally:
        if conn:
            cursor.close()
            conn.close()

    return





async def handle_closed_job_posts(update: Update, context: CallbackContext) -> int:
    chat_id = update.message.chat_id
    logger.debug(f"Employer's chat_id: {chat_id}")

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id from the users table using chat_id
        cursor.execute('''
            SELECT user_id FROM users WHERE contact = %s::text
        ''', (chat_id,))
        user_row = cursor.fetchone()

        if not user_row:
            logger.error(f"No user found in the database for chat_id: {chat_id}")
            await update.message.reply_text(
                "You are not registered in the system. Please contact support.",

            )
            return
        user_id = user_row[0]
        logger.debug(f"Employer's user_id: {user_id}")

        # Execute query to fetch only closed job posts and performance data
        logger.debug("Executing SQL query to fetch closed job posts...")
        cursor.execute('''
            SELECT 
                jp.job_id, jp.job_title, jp.repost_count, jp.job_application_deadline, 
                COUNT(a.application_id) AS applications_count,
                SUM(CASE WHEN a.status = 'shortlisted' THEN 1 ELSE 0 END) AS shortlisted_count,
                SUM(CASE WHEN a.status = 'pending' THEN 1 ELSE 0 END) AS pending_count,
                SUM(CASE WHEN a.status = 'hired' THEN 1 ELSE 0 END) AS hired_count,
                STRING_AGG(DISTINCT ap.location, ', ') AS top_locations,
                SUM(CASE WHEN ap.gender = 'Male' THEN 1 ELSE 0 END) AS male_applicants,
                SUM(CASE WHEN ap.gender = 'Female' THEN 1 ELSE 0 END) AS female_applicants
            FROM job_posts jp
            LEFT JOIN applications a ON jp.job_id = a.job_id
            LEFT JOIN applicant_profiles ap ON a.user_id = ap.user_id
            WHERE jp.user_id = %s AND jp.status_id = 6 -- Filter for 'closed' jobs
            GROUP BY jp.job_id, jp.job_title, jp.repost_count, jp.job_application_deadline
            ORDER BY jp.created_at DESC
        ''', (user_id,))
        job_posts = cursor.fetchall()
        logger.debug(f"Fetched closed job posts: {job_posts}")

        if not job_posts:
            await update.message.reply_text(
                "You currently have no closed job posts.",

            )
            return

        # Send each job performance summary as a separate message
        today_date = datetime.now().date()
        for (
            job_id, job_title, repost_count, deadline, applications_count,
            shortlisted_count, pending_count, hired_count, top_locations,
            male_applicants, female_applicants
        ) in job_posts:
            days_since_closure = (today_date - deadline).days if deadline else None

            # Dynamically build the message
            fields = [
                f"🏷️ *Job Title:* {job_title}" if job_title else None,
                f"📄 *Job ID:* {job_id}",
                f"📩 *Applications Received:* {applications_count}" if applications_count else None,
                f"🔎 *Shortlisted Applicants:* {shortlisted_count}" if shortlisted_count else None,
                f"⏳ *Pending Applications:* {pending_count}" if pending_count else None,
                f"✅ *Hired Candidates:* {hired_count}" if hired_count else None,
                f"♻️ *Reposts:* {repost_count}" if repost_count else None,
                f"🌍 *Top Locations:* {top_locations}" if top_locations else None,
                f"♂️ *Male Applicants:* {male_applicants}" if male_applicants else None,
                f"♀️ *Female Applicants:* {female_applicants}" if female_applicants else None,
                f"⌛ *Days Since Closure:* {days_since_closure} days" if days_since_closure is not None else None,
            ]
            # Filter out fields that are None
            message = "\n\n".join(filter(None, fields)) + f"\n{'-' * 30}"

            await update.message.reply_text(
                message,
                parse_mode="Markdown",

            )

    except psycopg2.Error as e:
        logger.error(f"Database error: {e}")
        await update.message.reply_text(
            "An error occurred while fetching your closed job posts. Please try again later.",

        )
    finally:
        if conn:
            cursor.close()
            conn.close()

    return



from telegram import Update, ReplyKeyboardMarkup, ForceReply
from telegram.ext import CallbackContext, ConversationHandler

import psycopg2
from psycopg2 import sql

from telegram import ReplyKeyboardMarkup


async def contact_admin(update: Update, context: CallbackContext) -> int:
    """
    Displays the chat history between the employer and the admin with distinct formatting
    to differentiate admin and employer messages.
    """
    chat_id = update.message.chat_id

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Verify employer and get gender
        cursor.execute("""
            SELECT user_id, gender FROM users WHERE contact = %s AND user_type = 'Employer'
        """, (str(chat_id),))
        result = cursor.fetchone()

        if not result:
            await update.message.reply_text("⚠️ Unable to identify your employer account. Please contact support.")
            return

        employer_id, gender = result

        # Determine the icon based on gender
        user_icon = "👨🏾" if gender == "Male" else "👩🏾"

        # Send the Back button first
        await update.message.reply_text(
            "Loading Chats...",
            reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
        )

        # Fetch chat history
        cursor.execute("""
            SELECT sender, message, timestamp FROM employer_admin_chats
            WHERE employer_id = %s ORDER BY timestamp ASC
        """, (employer_id,))
        chat_history = cursor.fetchall()

        # Send each message in the chat history with distinct formatting
        if chat_history:
            for sender, message, timestamp in chat_history:
                formatted_time = timestamp.strftime("%Y-%m-%d %H:%M:%S")
                if sender == "Employer":
                    # Employer message (box-style for distinction)
                    text = (
                        f"<b>{user_icon} You:</b>\n"
                        f"<pre>╭──────────────────╮\n"
                        f"│ {message}\n"
                        f"╰──────────────────╯</pre>\n"
                        f"<i>{formatted_time}</i>"
                    )
                else:
                    # Admin message (box-style with distinct header)
                    text = (
                        f"🧑🏿‍💻 <b>Support:</b>\n"
                        f"<pre>╭──────────────────╮\n"
                        f"│ {message}\n"
                        f"╰──────────────────╯</pre>\n"
                        f"<i>{formatted_time}</i>"
                    )

                await update.message.reply_html(text)
        else:
            await update.message.reply_text("No previous messages.")

        # Persist the Back button after loading chat
        await update.message.reply_text(
            "🔙 Back to main menu",
            reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
        )

        # Store employer ID in context
        context.user_data["chat_with_admin_user_id"] = employer_id

        return CHAT_WITH_ADMIN

    except Exception as e:
        logger.error(f"Error in contact_admin: {e}")
        await update.message.reply_text("⚠️ An error occurred. Please try again later.")
        return

    finally:
        if conn:
            cursor.close()
            conn.close()



async def handle_user_message(update: Update, context: CallbackContext) -> int:
    """
    Logs messages from the employer, forwards a notification to the admin, and keeps the employer informed silently.
    """
    employer_message = update.message.text.strip()
    chat_id = update.message.chat_id

    # Handle "End Chat"
    if employer_message.lower() == "🔙 back":
        return await end_chat_with_admin(update, context)

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch employer ID and details
        employer_id = context.user_data.get("chat_with_admin_user_id")
        if not employer_id:
            logger.error("Employer ID not found in context.")
            await update.message.reply_text("⚠️ An error occurred. Please restart the chat session.")
            return

        cursor.execute("""
            SELECT first_name, last_name, user_id, phone_number FROM users WHERE user_id = %s
        """, (employer_id,))
        user_details = cursor.fetchone()

        if not user_details:
            logger.error("Employer details not found in the database.")
            await update.message.reply_text("⚠️ Unable to fetch your details. Please try again.")
            return

        first_name, last_name, user_id, phone_number = user_details
        full_name = f"{first_name} {last_name}".strip()

        # Ensure the phone number includes a "+" sign
        formatted_phone_number = f"+{phone_number}" if not phone_number.startswith("+") else phone_number

        # Log the employer's message into the database
        cursor.execute("""
            INSERT INTO employer_admin_chats (employer_id, sender, message, timestamp)
            VALUES (%s, %s, %s, NOW())
        """, (employer_id, "Employer", employer_message))
        conn.commit()

        # Send a push notification to the admin
        notification_message = (
            "📢 <b>New Message Received</b>\n\n"
            f"👤 <b>From:</b> {full_name} (ID: {user_id})\n\n"
            f"📞 <b>Phone:</b> {formatted_phone_number}\n\n"
            f"📩 <b>Message:</b> {employer_message}\n\n"
        )
        await context.bot.send_message(
            chat_id=896853541,  # Admin's chat ID
            text=notification_message,
            parse_mode="HTML"
        )

        # Notify the employer about the successful message
        await update.message.reply_text(
            "✔️ Your message has been successfully sent to the admin.\n\n"
            "📩 The admin will review your message and respond within <b>12 hours</b>. "
            "Please revisit this section later to view their response.\n\n"
            "Thank you for your patience and understanding!",
            parse_mode="HTML"
        )

        # Keep the employer in the chat state
        return CHAT_WITH_ADMIN

    except Exception as e:
        logger.error(f"Error in handle_user_message: {e}")
        await update.message.reply_text("⚠️ An error occurred. Please try again.")
        return SUPPORT

    finally:
        if conn:
            cursor.close()
            conn.close()




async def end_chat_with_admin(update: Update, context: CallbackContext) -> int:
    """
    Ends the chat session without storing the 'Chat session ended' message in the database.
    """
    employer_id = context.user_data.pop("chat_with_admin_user_id", None)

    try:
        # Redirect user to the Support menu
        await update.message.reply_text(
            "Support: Please choose an action..",
            reply_markup=ReplyKeyboardMarkup([
                ["💬 Contact Admin", "🛠️ Help Center"],
                ["❓ FAQs", "🔙 Back"]
            ], resize_keyboard=True)
        )
        return SUPPORT

    except Exception as e:
        logger.error(f"Error ending chat session: {e}")
        await update.message.reply_text("⚠️ An error occurred. Please try again.")
        return SUPPORT


from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import CallbackContext

async def help_center(update: Update, context: CallbackContext) -> int:
    """
    Displays the Help Center information and handles navigation back to the Support menu.
    """
    user_choice = update.message.text.strip()

    if user_choice == "🔙 Back":
        # Redirect to the Support menu
        await update.message.reply_text(
            "Support: Please choose an action.",
            reply_markup=ReplyKeyboardMarkup([
                ["💬 Contact Admin", "🛠️ Help Center"],
                ["❓ FAQs", "🔙 Back"]
            ], resize_keyboard=True)
        )
        return SUPPORT

    else:
        # Display Help Center information
        help_text = (
            "📞 *Welcome to Afro Joblink Contact Center!* \n\n"
            "For further assistance, feel free to contact us directly:\n\n"
            "📌 *Company Name*: Afro Joblink\n\n"
            "📞 *Support Phone*: +251-911-123-456\n\n"
            "📧 *Support Email*: support@afrojoblink.com\n\n"
            "We're here to help you make the most of your experience!"
        )

        # Define reply keyboard for navigation
        reply_keyboard = [["🔙 Back"]]

        # Send the Help Center text with reply markup
        await update.message.reply_text(
            help_text,
            parse_mode='Markdown',
            reply_markup=ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True, one_time_keyboard=True)
        )

        return HELP_CENTER



from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import CallbackContext


async def faqs(update: Update, context: CallbackContext) -> int:
    """
    Displays a link to the FAQs page and handles navigation back to the Support menu.
    """
    user_choice = update.message.text.strip()

    if user_choice == "🔙 Back":
        # Redirect to the Support menu
        await update.message.reply_text(
            "Support: Please choose an action.",
            reply_markup=ReplyKeyboardMarkup([
                ["💬 Contact Admin", "🛠️ Help Center"],
                ["❓ FAQs", "🔙 Back"]
            ], resize_keyboard=True)
        )
        return SUPPORT

    else:
        # Send the FAQs link
        await update.message.reply_text(
            "📖 Please refer to our FAQs page for answers to common questions:\n\n"
            "👉🏾 [FAQs](https://telegra.ph/Faqs-12-26-2)",
            parse_mode='Markdown',
            reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
        )

        # Keep the user in the FAQs state
        return FAQS


# Function to display the Job Management menu
async def show_job_management_menu(update, context):
    await update.message.reply_text(
        "Job Management: Please choose an action.",
        reply_markup=ReplyKeyboardMarkup([
            ["📝 Post a New Job", "📂 Opened Jobs"],
            ["🕒 Pending Jobs", "🔒 Closed Jobs"],
            ["🔁 Repost Jobs", "💾 Saved Jobs"],
            ["🔙 Back"]
        ], resize_keyboard=True)
    )
    return JOB_MANAGEMENT


async def start_job_filling(update: Update, context: CallbackContext):
    """Start job filling process."""
    await update.message.reply_text(
        "Let's start creating your job post. Select a section to begin:",
        reply_markup=ReplyKeyboardMarkup(
            [
                ["🏷️ Job Title", "📄 Job Description"],
                ["🏭 Job Site", "🕒 Job Type"],
                ["🏢 Job Sector", "🎓 Education Qualification"],
                ["🎖️ Experience Level", "🌐 Location (Country)"],
                ["📍 Location (City)", "💰 Compensation Type"],
                ["💲 Salary", "💱 Currency Type"],
                ["👥 Vacancy Number", "🚻 Applicant Gender"],
                ["⏳ Application Deadline", "💾 Draft"],
                ["🔙 Back", "✅ Confirm"],
            ],
            resize_keyboard=True,
        ),
    )
    return SELECT_SECTION


# Database configuration
DB_CONFIG = {
    "dbname": "my_project_db",
    "user": "postgres",
    "password": "1201",
    "host": "localhost",
    "port": "5432",
}

async def handle_section_selection(update: Update, context: CallbackContext):
    """Handle selection of sections."""
    section = update.message.text.strip()
    context.user_data["current_section"] = section  # Track the current section

    if section == "🏷️ Job Title":
        # Temporarily hide the keyboard for editing Job Title
        await update.message.reply_text(
            "Please enter the Job Title:",
            reply_markup=ReplyKeyboardRemove()
        )
        return JOB_TITLE

    elif section == "📄 Job Description":
        # Temporarily hide the keyboard for editing Job Description
        await update.message.reply_text(
            "Please enter the Job Description:",
            reply_markup=ReplyKeyboardRemove()
        )
        return JOB_DESCRIPTION

    elif section == "🏭 Job Site":
        return await fetch_and_show_job_sites(update, context)

    elif section == "🕒 Job Type":
        return await fetch_and_show_job_types(update, context)

    elif section == "🏢 Job Sector":
        return await fetch_and_show_job_categories(update, context)

    elif section == "🎓 Education Qualification":
        return await fetch_and_show_education_levels(update, context)

    elif section == "🎖️ Experience Level":
        return await fetch_and_show_experience_levels(update, context)

    elif section == "🌐 Location (Country)":
        return await fetch_and_show_countries(update, context)

    elif section == "📍 Location (City)":
        return await fetch_and_show_cities(update, context)

    elif section == "💰 Compensation Type":
        return await fetch_and_show_compensation_types(update, context)


    elif section == "💲 Salary":
        # Temporarily hide the keyboard for editing Salary
        await update.message.reply_text(
            "Please enter the Salary/Compensation Amount:",
            reply_markup=ReplyKeyboardRemove()
        )
        return SALARY_COMPENSATION

    elif section == "💱 Currency Type":
        return await fetch_and_show_currency_types(update, context)


    elif section == "👥 Vacancy Number":
        # Temporarily hide the keyboard for editing Vacancy Number
        await update.message.reply_text(
            "Please enter the number of vacancies for this job:",
            reply_markup=ReplyKeyboardRemove()
        )
        return VACANCY_NUMBER

    elif section == "🚻 Applicant Gender":
        await update.message.reply_text(
            "Please select the preferred gender for applicants:",
            reply_markup=ReplyKeyboardMarkup(
                [["Male", "Female", "Both"]],
                resize_keyboard=True,
            ),
        )
        return APPLICANT_GENDER

    elif section == "⏳ Application Deadline":
        await update.message.reply_text(
            "Please enter the job application deadline (format: dd/mm/yyyy):",
            reply_markup=ReplyKeyboardMarkup([["Skip"]], resize_keyboard=True),
        )
        return JOB_APPLICATION_DEADLINE

    elif section == "💾 Draft":
        # Handle draft saving
        return await handle_draft(update, context)

    elif section == "🔙 Back":
        # Redirect back to the updated summary
        return await show_job_management_menu(update, context)

    elif section == "✅ Confirm":

        return await handle_confirm(update, context)


    elif section == "🔄 Reset Entries":
        # Reset all entries in the context
        context.user_data.clear()  # Clear all user data
        await update.message.reply_text(
            "All entries have been reset. You can now start over.",
            reply_markup=ReplyKeyboardMarkup(
                [
                    ["🏷️ Job Title", "📄 Job Description"],
                    ["🏭 Job Site", "🕒 Job Type"],
                    ["🏢 Job Sector", "🎓 Education Qualification"],
                    ["🎖️ Experience Level", "🌐 Location (Country)"],
                    ["📍 Location (City)", "💰 Compensation Type"],
                    ["💲 Salary", "💱 Currency Type"],
                    ["👥 Vacancy Number", "🚻 Applicant Gender"],
                    ["⏳ Application Deadline", "💾 Draft"],
                    ["🔙 Back", "✅ Confirm"],
                    ["🔄 Reset Entries"],
                ],
                resize_keyboard=True,
            ),
        )
        return SELECT_SECTION

    else:
        await update.message.reply_text(
            "⚠️ Invalid selection. Kindly choose one of the options provided below by clicking the appropriate button.")
        return SELECT_SECTION

async def handle_job_title(update: Update, context: CallbackContext):
    """Handle input for Job Title."""
    job_title = update.message.text.strip()

    # List of section buttons to avoid registering as input
    invalid_inputs = [
        "🏷️ Job Title", "📄 Job Description", "🏭 Job Site", "🕒 Job Type",
        "🏢 Job Sector", "🎓 Education Qualification", "🎖️ Experience Level",
        "🌐 Location (Country)", "📍 Location (City)", "💰 Compensation Type",
        "💲 Salary", "💱 Currency Type", "👥 Vacancy Number",
        "🚻 Applicant Gender", "⏳ Application Deadline", "💾 Draft", "🔙 Back", "✅ Confirm"
    ]

    # Validate if the input is a button press
    if job_title in invalid_inputs:
        await update.message.reply_text(
            "❌ Please enter a valid Job Title instead of selecting a section button."
        )
        return JOB_TITLE  # Prompt the user to re-enter the job title

    # Validate job title length
    if len(job_title) < 3 or len(job_title) > 20:
        await update.message.reply_text(
            "❌ Job Title must be between 3 and 20 characters. Please try again."
        )
        return JOB_TITLE  # Prompt the user to re-enter the job title

    # Save the validated job title
    context.user_data["job_title"] = job_title


    # Show the updated summary
    await show_updated_summary(update, context)
    return SELECT_SECTION




async def handle_job_description(update: Update, context: CallbackContext):
    """Handle input for Job Description."""
    job_description = update.message.text.strip()

    # List of section buttons to avoid registering as input
    invalid_inputs = [
        "🏷️ Job Title", "📄 Job Description", "🏭 Job Site", "🕒 Job Type",
        "🏢 Job Sector", "🎓 Education Qualification", "🎖️ Experience Level",
        "🌐 Location (Country)", "📍 Location (City)", "💰 Compensation Type",
        "💲 Salary", "💱 Currency Type", "👥 Vacancy Number",
        "🚻 Applicant Gender", "⏳ Application Deadline", "💾 Draft", "🔙 Back", "✅ Confirm"
    ]

    # Validate if the input is a button press
    if job_description in invalid_inputs:
        await update.message.reply_text(
            "❌ Please enter a valid Job Description instead of selecting a section button."
        )
        return JOB_DESCRIPTION  # Prompt the user to re-enter the job description

    # Validate job description length
    if len(job_description) < 50:
        await update.message.reply_text(
            "❌ Job Description must be at least 50 characters long. Please try again."
        )
        return JOB_DESCRIPTION  # Prompt the user to re-enter the job description

    # Save the validated job description
    context.user_data["job_description"] = job_description


    # Show the updated summary
    await show_updated_summary(update, context)
    return SELECT_SECTION



from telegram import ReplyKeyboardMarkup
from telegram.ext import ConversationHandler

async def fetch_and_show_job_sites(update: Update, context: CallbackContext):
    """Fetch and display job sites as keyboard buttons."""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()
        cursor.execute("SELECT job_site_name FROM job_sites WHERE is_active = TRUE")
        job_sites = cursor.fetchall()
        cursor.close()
        conn.close()

        # Save the valid options to context for validation
        valid_job_sites = [site[0] for site in job_sites]
        context.user_data["valid_job_sites"] = valid_job_sites

        # Create keyboard buttons for job sites
        job_site_buttons = [[site] for site in valid_job_sites]  # Single column of buttons

        # Send the keyboard to the user
        await update.message.reply_text(
            "Select the Job Site:",
            reply_markup=ReplyKeyboardMarkup(job_site_buttons, resize_keyboard=True, one_time_keyboard=True),
        )
        return JOB_SITE

    except (Exception, psycopg2.DatabaseError) as error:
        await update.message.reply_text("An error occurred while fetching job sites. Please try again later.")
        print(f"Database error: {error}")
        return SELECT_SECTION


async def handle_job_site_selection(update: Update, context: CallbackContext):
    """Handle the user's job site selection."""
    selected_job_site = update.message.text.strip()  # Get the user's selection as plain text

    # Validate the selection
    valid_job_sites = context.user_data.get("valid_job_sites", [])
    if selected_job_site not in valid_job_sites:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose a valid Job Site from the options provided."
        )
        return JOB_SITE  # Keep the user in the current state

    # Save the selected job site to context
    context.user_data["job_site"] = selected_job_site



    # Update the job summary
    await show_updated_summary(update, context)

    # Return to the section selection
    return SELECT_SECTION


async def fetch_and_show_job_types(update: Update, context: CallbackContext):
    """Fetch and display job types as keyboard buttons."""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()
        cursor.execute("SELECT job_type_name FROM job_types WHERE is_active = TRUE")
        job_types = cursor.fetchall()
        cursor.close()
        conn.close()

        # Save the valid options to context for validation
        valid_job_types = [job_type[0] for job_type in job_types]
        context.user_data["valid_job_types"] = valid_job_types

        # Create keyboard buttons for job types
        job_type_buttons = [[job_type] for job_type in valid_job_types]  # Single column of buttons

        # Send the keyboard to the user
        await update.message.reply_text(
            "Select the Job Type:",
            reply_markup=ReplyKeyboardMarkup(job_type_buttons, resize_keyboard=True, one_time_keyboard=True),
        )
        return JOB_TYPE

    except (Exception, psycopg2.DatabaseError) as error:
        await update.message.reply_text("An error occurred while fetching job types. Please try again later.")
        print(f"Database error: {error}")
        return SELECT_SECTION


async def handle_job_type_selection(update: Update, context: CallbackContext):
    """Handle the user's job type selection."""
    selected_job_type = update.message.text.strip()  # Get the user's selection as plain text

    # Validate the selection
    valid_job_types = context.user_data.get("valid_job_types", [])
    if selected_job_type not in valid_job_types:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose a valid Job Type from the options provided."
        )
        return JOB_TYPE  # Keep the user in the current state

    # Save the selected job type to context
    context.user_data["job_type"] = selected_job_type


    # Update the job summary
    await show_updated_summary(update, context)

    # Return to the section selection
    return SELECT_SECTION




async def fetch_and_show_job_categories(update: Update, context: CallbackContext):
    """Fetch and display job categories dynamically from the database."""
    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432",
        )
        cursor = conn.cursor()

        # Fetch active job categories from the database
        cursor.execute("SELECT category_name FROM job_categories WHERE is_active = TRUE ORDER BY category_name ASC;")
        categories = [row[0] for row in cursor.fetchall()]

        if not categories:
            await update.message.reply_text("No active job categories available.")
            return SELECT_SECTION

        # Save valid categories to context for validation
        context.user_data["valid_job_categories"] = categories

        # Prepare keyboard buttons for categories in a single column
        category_buttons = [[category] for category in categories]

        # Display the categories to the user
        await update.message.reply_text(
            "Please select the Job Sector:",
            reply_markup=ReplyKeyboardMarkup(category_buttons, resize_keyboard=True),
        )
        return JOB_SECTOR

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error while fetching job categories: {error}")
        await update.message.reply_text(
            "An error occurred while fetching job categories. Please try again later."
        )
        return SELECT_SECTION

    finally:
        if conn:
            cursor.close()
            conn.close()


async def handle_job_category_selection(update: Update, context: CallbackContext):
    """Handle the user's job sector selection."""
    selected_job_sector = update.message.text.strip()

    # Validate the selection
    valid_job_categories = context.user_data.get("valid_job_categories", [])
    if selected_job_sector not in valid_job_categories:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose a valid Job Sector from the options provided."
        )
        return JOB_SECTOR  # Keep the user in the current state

    # Save the selected job sector to context
    context.user_data["job_sector"] = selected_job_sector



    # Update the job summary
    await show_updated_summary(update, context)

    # Return to the section selection
    return SELECT_SECTION


async def fetch_and_show_education_levels(update: Update, context: CallbackContext):
    """Fetch and display education levels from the database."""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()
        cursor.execute("SELECT education_level_name FROM education_levels WHERE is_active = TRUE")
        education_levels = [row[0] for row in cursor.fetchall()]
        cursor.close()
        conn.close()

        if not education_levels:
            await update.message.reply_text("No active education levels available.")
            return SELECT_SECTION

        # Save valid education levels to context for validation
        context.user_data["valid_education_levels"] = education_levels

        # Prepare keyboard buttons for education levels in a single column
        buttons = [[level] for level in education_levels]

        # Display the education levels to the user
        await update.message.reply_text(
            "Select the minimum education qualification:",
            reply_markup=ReplyKeyboardMarkup(buttons, resize_keyboard=True),
        )
        return EDUCATION_QUALIFICATION

    except (Exception, psycopg2.DatabaseError) as error:
        await update.message.reply_text("An error occurred while fetching education levels. Please try again later.")
        print(f"Database error: {error}")
        return SELECT_SECTION


async def handle_education_qualification_selection(update, context: CallbackContext):
    """Handle the user's education qualification selection."""
    selected_qualification = update.message.text.strip()

    # Validate the selection
    valid_education_levels = context.user_data.get("valid_education_levels", [])
    if selected_qualification not in valid_education_levels:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose a valid Education Qualification from the options provided."
        )
        return EDUCATION_QUALIFICATION  # Keep the user in the current state

    # Save the selected qualification to context
    context.user_data["education_level"] = selected_qualification



    # Update the job summary
    await show_updated_summary(update, context)

    # Return to the section selection
    return SELECT_SECTION





async def fetch_and_show_experience_levels(update: Update, context: CallbackContext):
    """Fetch and display experience levels from the database."""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()
        cursor.execute("SELECT experience_level_name FROM experience_levels WHERE is_active = TRUE")
        experience_levels = [row[0] for row in cursor.fetchall()]
        cursor.close()
        conn.close()

        if not experience_levels:
            await update.message.reply_text("No active experience levels available.")
            return SELECT_SECTION

        # Save valid experience levels to context for validation
        context.user_data["valid_experience_levels"] = experience_levels

        # Prepare keyboard buttons for experience levels in a single column
        buttons = [[level] for level in experience_levels]

        # Display the experience levels to the user
        await update.message.reply_text(
            "Select the Experience Level:",
            reply_markup=ReplyKeyboardMarkup(buttons, resize_keyboard=True),
        )
        return EXPERIENCE_LEVEL

    except (Exception, psycopg2.DatabaseError) as error:
        await update.message.reply_text("An error occurred while fetching experience levels. Please try again later.")
        print(f"Database error: {error}")
        return SELECT_SECTION


async def handle_experience_level_selection(update, context: CallbackContext):
    """Handle the user's experience level selection."""
    selected_experience_level = update.message.text.strip()

    # Validate the selection
    valid_experience_levels = context.user_data.get("valid_experience_levels", [])
    if selected_experience_level not in valid_experience_levels:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose a valid Experience Level from the options provided."
        )
        return EXPERIENCE_LEVEL  # Keep the user in the current state

    # Save the selected experience level to context
    context.user_data["experience_level"] = selected_experience_level


    # Update the job summary
    await show_updated_summary(update, context)

    # Return to the section selection
    return SELECT_SECTION


async def fetch_and_show_countries(update: Update, context: CallbackContext):
    """Fetch and display countries dynamically from the database."""
    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432",
        )
        cursor = conn.cursor()

        # Fetch active countries from the database
        cursor.execute("SELECT country_name FROM countries WHERE is_active = TRUE ORDER BY country_name ASC;")
        countries = [row[0] for row in cursor.fetchall()]

        if not countries:
            await update.message.reply_text("No active countries available.")
            return SELECT_SECTION

        # Save valid countries to context for validation
        context.user_data["valid_countries"] = countries

        # Prepare keyboard buttons for countries in a single column
        country_buttons = [[country] for country in countries]

        # Display the countries to the user
        await update.message.reply_text(
            "Please select the Country:",
            reply_markup=ReplyKeyboardMarkup(country_buttons, resize_keyboard=True),
        )
        return LOCATION_COUNTRY

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error while fetching countries: {error}")
        await update.message.reply_text(
            "An error occurred while fetching countries. Please try again later."
        )
        return SELECT_SECTION

    finally:
        if conn:
            cursor.close()
            conn.close()


async def handle_country_selection(update, context: CallbackContext):
    """Handle the user's country selection."""
    selected_country = update.message.text.strip()

    # Validate the selection
    valid_countries = context.user_data.get("valid_countries", [])
    if selected_country not in valid_countries:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose a valid Country from the options provided."
        )
        return LOCATION_COUNTRY  # Keep the user in the current state

    # Save the selected country to context
    context.user_data["location_country"] = selected_country


    # Update the job summary
    await show_updated_summary(update, context)

    # Return to the section selection
    return SELECT_SECTION


async def fetch_and_show_cities(update: Update, context: CallbackContext):
    """Fetch and display cities dynamically from the database."""
    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432",
        )
        cursor = conn.cursor()

        # Fetch active cities from the database
        cursor.execute("SELECT city_name FROM locations ORDER BY city_name ASC;")
        cities = [row[0] for row in cursor.fetchall()]

        if not cities:
            await update.message.reply_text("No active cities available.")
            return SELECT_SECTION

        # Save valid cities to context for validation
        context.user_data["valid_cities"] = cities

        # Prepare keyboard buttons for cities in a single column
        city_buttons = [[city] for city in cities]

        # Display the cities to the user
        await update.message.reply_text(
            "Please select the City:",
            reply_markup=ReplyKeyboardMarkup(city_buttons, resize_keyboard=True),
        )
        return LOCATION_CITY

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error while fetching cities: {error}")
        await update.message.reply_text(
            "An error occurred while fetching cities. Please try again later."
        )
        return SELECT_SECTION

    finally:
        if conn:
            cursor.close()
            conn.close()


async def handle_city_selection(update, context: CallbackContext):
    """Handle the user's city selection."""
    selected_city = update.message.text.strip()

    # Validate the selection
    valid_cities = context.user_data.get("valid_cities", [])
    if selected_city not in valid_cities:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose a valid City from the options provided."
        )
        return LOCATION_CITY  # Keep the user in the current state

    # Save the selected city to context
    context.user_data["location_city"] = selected_city


    # Update the job summary
    await show_updated_summary(update, context)

    # Return to the section selection
    return SELECT_SECTION


async def fetch_and_show_compensation_types(update: Update, context: CallbackContext):
    """Fetch and display compensation types dynamically from the database."""
    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432",
        )
        cursor = conn.cursor()

        # Fetch active compensation types from the database
        cursor.execute("SELECT compensation_type_name FROM compensation_types WHERE is_active = TRUE ORDER BY compensation_type_name ASC;")
        compensation_types = [row[0] for row in cursor.fetchall()]

        if not compensation_types:
            await update.message.reply_text("No active compensation types available.")
            return SELECT_SECTION

        # Save valid compensation types to context for validation
        context.user_data["valid_compensation_types"] = compensation_types

        # Prepare keyboard buttons for compensation types in a single column
        compensation_buttons = [[compensation_type] for compensation_type in compensation_types]

        # Display the compensation types to the user
        await update.message.reply_text(
            "Please select the Compensation Type:",
            reply_markup=ReplyKeyboardMarkup(compensation_buttons, resize_keyboard=True),
        )
        return COMPENSATION_TYPE

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error while fetching compensation types: {error}")
        await update.message.reply_text(
            "An error occurred while fetching compensation types. Please try again later."
        )
        return SELECT_SECTION

    finally:
        if conn:
            cursor.close()
            conn.close()


async def handle_compensation_type_selection(update: Update, context: CallbackContext):
    """Handle the user's compensation type selection."""
    selected_compensation_type = update.message.text.strip()

    # Validate the selection
    valid_compensation_types = context.user_data.get("valid_compensation_types", [])
    if selected_compensation_type not in valid_compensation_types:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose a valid Compensation Type from the options provided."
        )
        return COMPENSATION_TYPE  # Keep the user in the current state

    # Save the selected compensation type to context
    context.user_data["compensation_type"] = selected_compensation_type


    # Update the job summary
    await show_updated_summary(update, context)

    # Return to the section selection
    return SELECT_SECTION



async def handle_salary_compensation(update: Update, context: CallbackContext):
    """Handle salary/compensation input with validation."""
    salary_compensation = update.message.text.strip()

    # Predefined button labels with icons for validation
    invalid_inputs = [
        "🏷️ Job Title", "📄 Job Description", "🏭 Job Site", "🕒 Job Type",
        "🏢 Job Sector", "🎓 Education Qualification", "🎖️ Experience Level",
        "🌐 Location (Country)", "📍 Location (City)", "💰 Compensation Type",
        "💲 Salary", "💱 Currency Type", "👥 Vacancy Number",
        "🚻 Applicant Gender", "⏳ Application Deadline", "💾 Draft", "🔙 Back", "✅ Confirm"
    ]

    # Check if the input is a button press
    if salary_compensation in invalid_inputs:
        await update.message.reply_text(
            "❌ Please enter the salary amount first before selecting other sections."
        )
        return SALARY_COMPENSATION

    # Validate that the input is a numeric value with 2 to 7 digits
    if salary_compensation.isdigit() and 10 <= int(salary_compensation) <= 9999999:
        context.user_data["salary_compensation"] = salary_compensation

        # Show the updated summary dynamically
        await show_updated_summary(update, context)
        return SELECT_SECTION
    else:
        await update.message.reply_text(
            "❌ Invalid input. Please enter a numeric salary amount between 10 and 9,999,999."
        )
        return SALARY_COMPENSATION




async def fetch_and_show_currency_types(update: Update, context: CallbackContext):
    """Fetch and display currency types dynamically from the database."""
    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432",
        )
        cursor = conn.cursor()

        # Fetch active currency types from the database
        cursor.execute("SELECT currency_code FROM currency_types WHERE is_active = TRUE ORDER BY currency_code ASC;")
        currencies = [row[0] for row in cursor.fetchall()]

        if not currencies:
            await update.message.reply_text("No active currencies available.")
            return SELECT_SECTION

        # Save valid currency types to context for validation
        context.user_data["valid_currency_types"] = currencies

        # Prepare keyboard buttons for currencies in a single column
        currency_buttons = [[currency] for currency in currencies]

        # Display the currencies to the user
        await update.message.reply_text(
            "Please select the Currency Type:",
            reply_markup=ReplyKeyboardMarkup(currency_buttons, resize_keyboard=True),
        )
        return CURRENCY_TYPE

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error while fetching currency types: {error}")
        await update.message.reply_text(
            "An error occurred while fetching currency types. Please try again later."
        )
        return SELECT_SECTION

    finally:
        if conn:
            cursor.close()
            conn.close()


async def handle_currency_type_selection(update, context: CallbackContext):
    """Handle the user's currency type selection."""
    selected_currency = update.message.text.strip()

    # Validate the selection
    valid_currencies = context.user_data.get("valid_currency_types", [])
    if selected_currency not in valid_currencies:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose a valid Currency Type from the options provided."
        )
        return CURRENCY_TYPE  # Keep the user in the current state

    # Save the selected currency type to context
    context.user_data["currency_type"] = selected_currency


    # Update the job summary
    await show_updated_summary(update, context)

    # Return to the section selection
    return SELECT_SECTION


async def handle_vacancy_number(update: Update, context: CallbackContext):
    """Handle vacancy number input."""
    vacancy_number = update.message.text.strip()

    # List of section buttons to avoid registering as input
    invalid_inputs = [
        "🏷️ Job Title", "📄 Job Description", "🏭 Job Site", "🕒 Job Type",
        "🏢 Job Sector", "🎓 Education Qualification", "🎖️ Experience Level",
        "🌐 Location (Country)", "📍 Location (City)", "💰 Compensation Type",
        "💲 Salary", "💱 Currency Type", "👥 Vacancy Number",
        "🚻 Applicant Gender", "⏳ Application Deadline", "💾 Draft", "🔙 Back", "✅ Confirm"
    ]

    # Validate input against buttons
    if vacancy_number in invalid_inputs:
        await update.message.reply_text(
            "❌ Please enter the vacancy number first before selecting other sections."
        )
        return VACANCY_NUMBER  # Keep the user in the current state

    # Validate that the input is a number between 1 and 100
    if vacancy_number.isdigit() and 1 <= int(vacancy_number) <= 100:
        context.user_data["vacancy_number"] = vacancy_number


        # Show the updated summary dynamically
        await show_updated_summary(update, context)
        return SELECT_SECTION
    else:
        await update.message.reply_text(
            "❌ Invalid input. Please enter a valid number between 1 and 100."
        )
        return VACANCY_NUMBER


from telegram import ReplyKeyboardRemove

async def handle_applicant_gender(update: Update, context: CallbackContext):
    """Handle applicant gender selection."""
    gender = update.message.text.strip()

    # Validate input
    valid_genders = ["Male", "Female", "Both"]
    if gender in valid_genders:
        # Update context with the selected gender
        context.user_data["applicant_gender"] = gender


        # Show the updated summary dynamically
        await show_updated_summary(update, context)
        return SELECT_SECTION
    else:
        await update.message.reply_text(
            "❌ Invalid selection. Please choose Male, Female, or Both.",
            reply_markup=ReplyKeyboardMarkup(
                [["Male", "Female", "Both"]], resize_keyboard=True
            ),
        )
        return APPLICANT_GENDER




async def handle_job_application_deadline(update: Update, context: CallbackContext):
    """Handle job application deadline input."""
    deadline = update.message.text.strip()

    # Allow skipping
    if deadline.lower() == "skip":
        from datetime import datetime, timedelta

        # Set a default deadline 10 days from now
        default_deadline = (datetime.now() + timedelta(days=10)).strftime("%d/%m/%Y")
        context.user_data["job_application_deadline"] = default_deadline
        # Show the updated summary dynamically
        await show_updated_summary(update, context)
        return SELECT_SECTION

    # Validate date format (dd/mm/yyyy)
    try:
        day, month, year = map(int, deadline.split("/"))
        from datetime import date

        validated_date = date(year, month, day)
        context.user_data["job_application_deadline"] = validated_date.strftime("%d/%m/%Y")
       # Show the updated summary dynamically
        await show_updated_summary(update, context)
        return SELECT_SECTION

    except ValueError:
        await update.message.reply_text(
            "❌ Invalid date format. Please use the format dd/mm/yyyy or type 'skip' to set a default deadline."
        )
        return JOB_APPLICATION_DEADLINE


# Handler for job application deadline
async def show_updated_summary(update: Update, context: CallbackContext):
    """Show the updated job summary with navigation buttons."""
    # Define all possible fields with their labels and emojis in the required order
    ordered_fields = [
        ("job_title", "🏷️ *Job Title:*"),
        ("combined_job_type", "🕒 *Job Type:*"),  # Job type and job site combined
        ("job_sector", "🏢 *Job Sector:*"),
        ("work_location", "📍 *Work Location:*"),  # Location (city, country) combined
        ("education_level", "🎓 *Education Qualification:*"),
        ("experience_level", "🎖️ *Experience Level:*"),
        ("salary_summary", "💰 *Salary/Compensation:*"),  # Salary/compensation fields combined
        ("vacancy_number", "👥 *Vacancy Number:*"),
        ("applicant_gender", ""),  # Gender handled dynamically
        ("job_application_deadline", "⏳ *Application Deadline:*"),
        ("job_description", "📄 *Job Description:*"),
    ]

    # Prepare special fields dynamically
    location_city = context.user_data.get("location_city", "").strip()
    location_country = context.user_data.get("location_country", "").strip()
    if location_city or location_country:
        work_location = f"{location_city}, {location_country}".strip(", ")
        context.user_data["work_location"] = work_location

    job_type = context.user_data.get("job_type", "").strip()
    job_site = context.user_data.get("job_site", "").strip()
    if job_type or job_site:
        combined_job_type = f"{job_type}, {job_site}".strip(", ")
        context.user_data["combined_job_type"] = combined_job_type

    # Handle salary and related fields with type checking
    salary = context.user_data.get("salary_compensation", "")
    if isinstance(salary, (float, int)):  # If it's a number, format it
        salary = f"{salary:.2f}"
    salary = str(salary).strip()  # Ensure salary is always a string
    currency = context.user_data.get("currency_type", "").strip()
    compensation_type = context.user_data.get("compensation_type", "").strip()
    salary_parts = []
    if salary:
        salary_parts.append(salary)
    if currency:
        salary_parts.append(currency)
    if compensation_type:
        salary_parts.append(f"({compensation_type})")
    if salary_parts:
        salary_summary = " ".join(salary_parts).strip()
        context.user_data["salary_summary"] = salary_summary

    # Handle dynamic gender icon
    gender = context.user_data.get("applicant_gender", "").strip()
    gender_icons = {"Male": "♂️", "Female": "♀️", "Both": "🚻"}
    if gender in gender_icons:
        ordered_fields[8] = ("applicant_gender", f"{gender_icons[gender]} *Applicant Gender:*")  # Update label dynamically

    # Construct the summary dynamically based on the ordered fields
    summary_lines = []
    for key, label in ordered_fields:
        value = context.user_data.get(key, "")
        if isinstance(value, (int, float)):  # Convert numeric values to strings
            value = str(value)
        if isinstance(value, str):
            value = value.strip()  # Only call strip on strings
        if value and value not in ["Not provided", "Not selected", "Not specified"]:
            summary_lines.append(f"{label} {value}")

    # Join all the summary lines
    summary = "\n\n".join(summary_lines)

    if not summary_lines:
        summary = "No job details have been provided yet."

    # Send the dynamic summary with buttons
    await update.message.reply_text(
        f"Here is your updated job summary:\n\n{summary}",
        parse_mode="Markdown",
        reply_markup=ReplyKeyboardMarkup(
            [
                ["🏷️ Job Title", "📄 Job Description"],
                ["🏭 Job Site", "🕒 Job Type"],
                ["🏢 Job Sector", "🎓 Education Qualification"],
                ["🎖️ Experience Level", "🌐 Location (Country)"],
                ["📍 Location (City)", "💰 Compensation Type"],
                ["💲 Salary", "💱 Currency Type"],
                ["👥 Vacancy Number", "🚻 Applicant Gender"],
                ["⏳ Application Deadline", "💾 Draft"],
                ["🔙 Back", "✅ Confirm"],
                ["🔄 Reset Entries"],
            ],
            resize_keyboard=True,
        ),
    )



from datetime import datetime

async def handle_draft(update, context: CallbackContext):
    """Handle saving the job as a draft."""
    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Get the employer's `user_id` from the database using Telegram user_id
        telegram_user_id = str(update.message.from_user.id)  # Cast to string
        cursor.execute(
            "SELECT user_id FROM users WHERE contact = %s",
            (telegram_user_id,)
        )
        result = cursor.fetchone()

        if not result:
            await update.message.reply_text("❌ Unable to identify the user. Please try again.")
            return SELECT_SECTION

        employer_user_id = result[0]

        # Validate required fields
        required_fields = [
            "job_title", "job_description", "job_site", "job_type", "job_sector",
            "education_level", "experience_level", "location_country", "location_city",
            "vacancy_number", "applicant_gender", "job_application_deadline"
        ]

        missing_fields = [
            field for field in required_fields if not context.user_data.get(field)
        ]

        if missing_fields:
            missing_fields_str = "\n".join([f"• {field.replace('_', ' ').title()}" for field in missing_fields])
            await update.message.reply_text(
                f"⚠️ *Missing Required Fields:*\n\n"
                f"{missing_fields_str}\n\n"
                f"💡 Please complete these fields before saving the draft.",
                parse_mode="Markdown"
            )
            return SELECT_SECTION

        # Parse and format the job application deadline
        deadline_raw = context.user_data.get("job_application_deadline")
        job_application_deadline = None
        if deadline_raw:
            try:
                # Convert from `dd/mm/yyyy` to `yyyy-mm-dd`
                job_application_deadline = datetime.strptime(deadline_raw, "%d/%m/%Y").strftime("%Y-%m-%d")
            except ValueError:
                await update.message.reply_text(
                    "❌ Invalid date format for the application deadline. Please ensure it is in dd/mm/yyyy format."
                )
                return JOB_APPLICATION_DEADLINE

        # Ensure optional fields are properly initialized
        compensation_type = context.user_data.get("compensation_type", None)
        salary_compensation = context.user_data.get("salary_compensation", None)
        currency_type = context.user_data.get("currency_type", None)

        # Insert the draft into the job_posts table
        cursor.execute(
            """
            INSERT INTO job_posts (
                job_title, job_description, job_site, job_type, job_sector,
                education_qualification, experience_level, location_country, location_city,
                compensation_type, salary_compensation, currency_type, vacancy_number,
                applicant_gender, job_application_deadline, created_at, user_id, status_id, repost_count
            )
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, NOW(), %s, %s, %s)
            """,
            (
                context.user_data.get("job_title"),
                context.user_data.get("job_description"),
                context.user_data.get("job_site"),
                context.user_data.get("job_type"),
                context.user_data.get("job_sector"),
                context.user_data.get("education_level"),
                context.user_data.get("experience_level"),
                context.user_data.get("location_country"),
                context.user_data.get("location_city"),
                compensation_type,  # Optional field
                salary_compensation,  # Optional field
                currency_type,  # Optional field
                context.user_data.get("vacancy_number"),
                context.user_data.get("applicant_gender"),
                job_application_deadline,
                employer_user_id,
                8,  # status_id for "drafted"
                0  # repost_count
            )
        )

        # Commit the transaction
        conn.commit()

        await update.message.reply_text("✅ Job successfully saved as a draft.")
        return SELECT_SECTION

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error while saving draft: {error}")
        await update.message.reply_text("❌ An error occurred while saving the draft. Please try again.")
        return SELECT_SECTION

    finally:
        # Safely close the connection if it was established
        if 'conn' in locals() and conn:
            conn.close()



async def handle_confirm(update, context):
    """Handle the confirmation of the job post."""
    chat_id = update.message.chat_id  # This is the contact, not user_id

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve the correct user_id based on the contact (chat_id)
        cursor.execute('SELECT user_id FROM users WHERE contact = %s', (str(chat_id),))
        user_row = cursor.fetchone()

        if not user_row:
            logger.error(f"No user found with contact {chat_id}. User must be registered.")
            await update.message.reply_text("❌ You are not registered. Please register before posting a job.")
            return

        user_id = user_row[0]

        # Validate required fields
        required_fields = [
            "job_title", "job_description", "job_site", "job_type", "job_sector",
            "education_level", "experience_level", "location_country", "location_city",

            "vacancy_number", "applicant_gender", "job_application_deadline"
        ]

        missing_fields = [
            field for field in required_fields if not context.user_data.get(field)
        ]

        if missing_fields:
            missing_fields_str = "\n".join([f"• {field.replace('_', ' ').title()}" for field in missing_fields])
            await update.message.reply_text(
                f"⚠️ *Missing Required Fields:*\n\n"
                f"{missing_fields_str}\n\n"
                f"💡 Please complete these fields before confirming the job post.",
                parse_mode="Markdown"
            )
            return SELECT_SECTION

        # Convert job_application_deadline from dd/mm/yyyy to yyyy-mm-dd
        deadline_dd_mm_yyyy = context.user_data["job_application_deadline"]
        try:
            day, month, year = map(int, deadline_dd_mm_yyyy.split("/"))
            from datetime import date
            deadline_yyyy_mm_dd = date(year, month, day).strftime("%Y-%m-%d")  # Convert format
        except ValueError:
            logger.error(f"Invalid date format: {deadline_dd_mm_yyyy}")
            await update.message.reply_text("❌ Invalid job application deadline format. Please try again.")
            return

        # Check the job post limit and package details
        cursor.execute('''
            SELECT job_post_limit, package_name, package_expiration, notification_sent
            FROM package_usage 
            WHERE user_id = %s AND package_expiration > NOW()
        ''', (user_id,))
        package_row = cursor.fetchone()

        package_section = ""
        notification_sent = False  # Default if no package is found

        if package_row:
            job_post_limit, package_name, package_expiration, notification_sent = package_row

            if job_post_limit <= 0 and not notification_sent:
                # Notify the user once about the job post limit
                await update.message.reply_text(
                    f"⚠️ You have reached the job post limit for your package '{package_name}'. "
                    "Your job post will still be sent to the admin for approval. Please consider upgrading your package."
                )
                # Mark the notification as sent
                cursor.execute('''
                         UPDATE package_usage
                         SET notification_sent = TRUE
                         WHERE user_id = %s AND package_expiration > NOW()
                     ''', (user_id,))
                conn.commit()

            # Add package details if valid
            package_section = (
                f"📦 *Current Package:* {package_name}\n\n"
                f"📝 *Job Posts Remaining:* {job_post_limit}\n\n"
            )
        # Deduct job post limit if applicable
        if package_row and job_post_limit > 0:
            cursor.execute('''
                UPDATE package_usage
                SET job_post_limit = job_post_limit - 1
                WHERE user_id = %s AND package_expiration > NOW()
            ''', (user_id,))
            conn.commit()

        # Handle Optional Fields
        compensation_type = context.user_data.get("compensation_type")
        salary_compensation = context.user_data.get("salary_compensation")
        currency_type = context.user_data.get("currency_type")

        # Insert job post into the database
        cursor.execute('''
            INSERT INTO job_posts (job_title, job_description, job_site, job_type, job_sector,
                                   education_qualification, experience_level, location_country, location_city,
                                   compensation_type, salary_compensation, currency_type, vacancy_number,
                                   applicant_gender, job_application_deadline, user_id, status_id)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            RETURNING job_id
        ''', (
            context.user_data["job_title"],
            context.user_data["job_description"],
            context.user_data["job_site"],
            context.user_data["job_type"],
            context.user_data["job_sector"],
            context.user_data["education_level"],
            context.user_data["experience_level"],
            context.user_data.get("location_country", "Not specified"),
            context.user_data.get("location_city", "Not specified"),
            compensation_type,  # Optional field
            salary_compensation,  # Optional field
            currency_type,  # Optional field
            context.user_data["vacancy_number"],
            context.user_data["applicant_gender"],
            deadline_yyyy_mm_dd,  # Use the converted format
            user_id,
            1  # Pending status
        ))

        job_id = cursor.fetchone()[0]
        conn.commit()

        # Fetch company details and total reposts
        cursor.execute('''
            SELECT company_name, is_verified FROM company_profiles WHERE user_id = %s
        ''', (user_id,))
        company_row = cursor.fetchone()
        company_name = company_row[0] if company_row else "Private Client"
        is_verified = company_row[1] if company_row else False

        cursor.execute('SELECT COUNT(*) FROM job_posts WHERE user_id = %s', (user_id,))
        total_posts = cursor.fetchone()[0]

        cursor.execute('SELECT SUM(repost_count) FROM job_posts WHERE user_id = %s', (user_id,))
        total_reposts_all_jobs = cursor.fetchone()[0] or 0

        # Construct the company details section
        repost_section = f"♻️ *Total Reposts (All Jobs):* {total_reposts_all_jobs}\n\n" if total_reposts_all_jobs > 0 else ""

        company_section = (
            f"*{company_name}*\n"
            f"{'Verified Company ✅' if is_verified else 'Private Client'}\n\n"
            f"📁 *Total Jobs Posted:* {total_posts}\n\n"
            f"{repost_section}{package_section}"
        )

        # Format job details
        gender_icon = {"Male": "♂️", "Female": "♀️", "Both": "🚻"}.get(context.user_data["applicant_gender"], "⚥")
        # Adjust salary summary to display only if at least one field is provided
        if salary_compensation or currency_type or compensation_type:
            salary_summary_parts = []
            if salary_compensation:
                salary_summary_parts.append(f"{salary_compensation}")
            if currency_type:
                salary_summary_parts.append(f"{currency_type}")
            if compensation_type:
                salary_summary_parts.append(f"{compensation_type}")
            salary_summary = " ".join(salary_summary_parts)  # Combine available fields
        else:
            salary_summary = None  # No fields are provided

        job_summary = (
            f"🏷️ *Job ID:* {job_id}\n\n"
            f"🏷️ *Job Title:* {context.user_data['job_title']}\n\n"
            f"🕒 *Job Type:* {context.user_data['job_site']}, {context.user_data['job_type']}\n\n"
            f"🏢 *Job Sector:* {context.user_data['job_sector']}\n\n"
            f"📍 *Work Location:* {context.user_data.get('location_city', 'N/A')}, {context.user_data.get('location_country', 'N/A')}\n\n"
            f"🎓 *Education Qualification:* {context.user_data['education_level']}\n\n"
            f"🎖️ *Experience Level:* {context.user_data['experience_level']}\n\n"
        )
        # Add the salary section only if at least one field is provided
        if salary_summary:
            job_summary += f"💰 *Salary/Compensation:* {salary_summary}\n\n"
        job_summary += (

            f"👥 *Vacancy Number:* {context.user_data['vacancy_number']}\n\n"
            f"{gender_icon} *Applicant Gender:* {context.user_data['applicant_gender']}\n\n"
            f"⏳ *Job Application Deadline:* {context.user_data['job_application_deadline']}\n\n"
            f"📄 *Job Description:*\n{context.user_data['job_description']}\n\n"
            f"{'_' * 30}\n\n{company_section}{'_' * 30}"
        )

        # Send job post to the admin
        admin_message = await context.bot.send_message(
            chat_id=ADMIN_ID,
            text=job_summary,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("Approve", callback_data=f"approve:{job_id}")],
                [InlineKeyboardButton("Deny", callback_data=f"deny:{job_id}")],
                [InlineKeyboardButton("Request Payment", callback_data=f"request_payment:{job_id}")]
            ])
        )

        # Update admin message ID in the database
        cursor.execute("UPDATE job_posts SET message_id = %s WHERE job_id = %s", (admin_message.message_id, job_id))
        conn.commit()

        # Notify the user
        await update.message.reply_text(
            "🎉 *Success!* Your job post has been successfully saved and forwarded to the admin for approval.\n\n"
            "📩 You will be notified once your job post is reviewed. Thank you for choosing our platform!",
            parse_mode="Markdown"
        )

        await update.message.reply_text(
            "Employer Menu: Please choose an action.",
            reply_markup=ReplyKeyboardMarkup([
                ["🗂️ Job Management", "📄 Applications"],
                ["🔍 Search & Filter", "🪪 Profile"],
                ["💳 Billing & Payments", "📢 Notifications"],
                ["⚙️ Performance", "📞 Support"]
            ], resize_keyboard=True)
        )
        return EMPLOYER_MENU

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error while confirming job post: {error}")
        await update.message.reply_text("❌ An error occurred while confirming the job post. Please try again.")
        return

    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()


import psycopg2
from telegram import InlineKeyboardMarkup, InlineKeyboardButton, Update
from telegram.ext import CallbackContext
import logging

logger = logging.getLogger(__name__)

DB_CONFIG = {
    "dbname": "my_project_db",
    "user": "postgres",
    "password": "1201",
    "host": "localhost",
    "port": "5432",
}

def fetch_payment_details():
    """Fetch payment details from the database."""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()
        query = "SELECT bank_name, account_name, account_number, amount FROM payment_details LIMIT 1;"
        cursor.execute(query)
        payment_details = cursor.fetchone()
        cursor.close()
        conn.close()
        return payment_details
    except Exception as e:
        logger.error(f"Error fetching payment details: {e}")
        return None

async def handle_request_payment(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    # Extract job_id from callback data
    _, job_id = query.data.split(":")

    # Notify the employer about the payment request
    try:
        # Fetch the employer's contact or user_id from the job_posts table
        conn = psycopg2.connect(**DB_CONFIG)
        cursor = conn.cursor()

        cursor.execute('''
            SELECT u.contact, j.job_title
            FROM job_posts j
            JOIN users u ON j.user_id = u.user_id
            WHERE j.job_id = %s
        ''', (job_id,))
        employer_row = cursor.fetchone()

        if not employer_row:
            logger.error(f"Employer not found for job_id {job_id}.")
            await query.message.reply_text("An error occurred. Unable to notify the employer.")
            return

        employer_contact = employer_row[0]
        job_title = employer_row[1]

        # Fetch payment details from the database
        payment_details = fetch_payment_details()
        if not payment_details:
            await query.message.reply_text("Payment details are not available at the moment. Please try again later.")
            return

        bank_name, account_name, account_number, amount = payment_details

        # Send the initial payment request message
        initial_message = await context.bot.send_message(
            chat_id=employer_contact,
            text=(
                f"📢 *Payment Request for Job Posting*\n\n"
                f"Your job post titled *{job_title}* requires payment to proceed.\n\n"
                "Please make the payment using the following account details:\n\n"
                f"🏦 *Bank Name:* {bank_name}\n\n"
                f"👤 *Account Name:* {account_name}\n\n"
                f"🔢 *Account Number:* {account_number}\n\n"
                f"💵 *Amount to Pay:* {amount}\n\n"
                "Thank you for your prompt attention to this matter."
            ),
            parse_mode="Markdown"
        )

        # Send the follow-up message as a reply
        await context.bot.send_message(
            chat_id=employer_contact,
            text=(
                "\u200B\n"  # Invisible section
                "📄 *Steps to Upload Payment Confirmation*\n\n"
                "After completing the payment, please follow these steps to upload your payment confirmation:\n\n"
                "1. Navigate to **💳 Billing & Payments** in the bot menu.\n"
                "2. Select **💳 Make Payments** from the available options.\n"
                "3. Choose the job post for which you made the payment and click **Make Payment**.\n"
                "4. Click **Upload Payment Screenshot**.\n"
                f"5. Use the Telegram file upload button 📎 to attach and upload the payment confirmation screenshot.\n\n"
                "Your payment will be processed shortly. Thank you for your cooperation!"
            ),
            parse_mode="Markdown",
            reply_to_message_id=initial_message.message_id
        )

        # Update admin view with confirmation of payment request
        await query.edit_message_reply_markup(reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("Approve", callback_data=f"approve:{job_id}")],
            [InlineKeyboardButton("Deny", callback_data=f"deny:{job_id}")],
            [InlineKeyboardButton("Payment Requested ✅", callback_data="payment_requested")]
        ]))

        await query.message.reply_text("Payment request has been sent to the employer.")

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error while notifying employer: {error}")
        await query.message.reply_text("An error occurred while processing the payment request.")
    finally:
        if conn:
            cursor.close()
            conn.close()





from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import CallbackContext
import logging
import psycopg2

# Initialize logger
logger = logging.getLogger(__name__)
CHANNEL_ID = "-1002270681847"  # Replace with your actual channel ID

async def handle_approval(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    query_data = query.data
    job_id = query_data.split(":")[1]

    try:
        # Connect to PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch job post details
        cursor.execute('''
            SELECT job_title, job_description, job_site, job_type, job_sector,
                   education_qualification, experience_level, location_country, location_city,
                   compensation_type, salary_compensation, currency_type, vacancy_number,
                   applicant_gender, job_application_deadline, user_id, status_id, repost_count
            FROM job_posts
            WHERE job_id = %s
        ''', (job_id,))
        job_post = cursor.fetchone()

        if not job_post:
            await query.answer(text="Job post not found.")
            return

        job_title, job_description, job_site, job_type, job_sector = job_post[0:5]
        education_qualification, experience_level, location_country, location_city = job_post[5:9]
        compensation_type, salary_compensation, currency_type, vacancy_number = job_post[9:13]
        applicant_gender, job_application_deadline, employer_user_id, status_id, specific_repost_count = job_post[13:18]

        # Format the application deadline
        formatted_deadline = job_application_deadline.strftime("%B %d")  # Example: "December 13"
        day_suffix = (
            "st" if 11 > job_application_deadline.day % 10 == 1 else
            "nd" if 11 > job_application_deadline.day % 10 == 2 else
            "rd" if 11 > job_application_deadline.day % 10 == 3 else "th"
        )
        formatted_deadline += day_suffix + job_application_deadline.strftime(", %Y")  # Example: "December 13th, 2024"

        # Check if the employer is verified and get the company name
        cursor.execute('''
            SELECT company_name, is_verified FROM company_profiles WHERE user_id = %s
        ''', (employer_user_id,))
        company_row = cursor.fetchone()
        company_name = company_row[0] if company_row else "Private Client"
        is_verified = company_row[1] if company_row else False

        # Fetch total job post count for the employer (opened or closed jobs only)
        cursor.execute('''
            SELECT COUNT(*)
            FROM job_posts
            WHERE user_id = %s AND status_id IN (
                SELECT status_id FROM job_status WHERE status_name IN ('opened', 'closed')
            )
        ''', (employer_user_id,))
        total_posts = cursor.fetchone()[0]

        # Fetch total repost count for all jobs by the employer
        cursor.execute('''
            SELECT SUM(repost_count)
            FROM job_posts
            WHERE user_id = %s
        ''', (employer_user_id,))
        total_reposts_all_jobs = cursor.fetchone()[0] or 0

        # Construct dynamic repost section
        repost_section = ""
        if total_reposts_all_jobs > 0:
            repost_section += f"♻️ *Total Reposts (All Jobs):* {total_reposts_all_jobs}\n\n"
        if specific_repost_count > 0:
            repost_section += f"🔂 *Reposts for This Job:* {specific_repost_count}\n"

        # Construct the company details section
        if is_verified:
            verified_company_section = (
                f"*{company_name}*\n"
                f"Verified Company ✅\n\n"
                f"⚡ *Total Jobs Posted:* {total_posts}\n\n"
                f"{repost_section}"  # Include dynamic repost section if available
            )
        else:
            verified_company_section = (
                f"*Private Client*\n\n"
                f"⚡ *Total Jobs Posted:* {total_posts}\n\n"
                f"{repost_section}"  # Include dynamic repost section if available
            )

        # Gender icon
        gender_icon = {"Male": "♂️", "Female": "♀️"}.get(applicant_gender, "🚻")

        # Format salary/compensation summary
        if compensation_type or salary_compensation or currency_type:
            salary_summary_parts = []
            if salary_compensation:
                salary_summary_parts.append(str(salary_compensation))
            if currency_type:
                salary_summary_parts.append(currency_type)
            if compensation_type:
                salary_summary_parts.append(compensation_type)
            salary_summary = " ".join(salary_summary_parts)
        else:
            salary_summary = None

        # Construct the job summary
        job_summary = (
            f"🏷️ *Job Title:* {job_title}\n\n"
            f"🕒 *Job Type:* {job_site}, {job_type}\n\n"
            f"🏢 *Job Sector:* {job_sector}\n\n"
            f"📍 *Work Location:* {location_city}, {location_country}\n\n"
            f"🎓 *Education Qualification:* {education_qualification}\n\n"
            f"🎖️ *Experience Level:* {experience_level}\n\n"
           )

        # Add salary section only if at least one field is provided
        if salary_summary:
            job_summary += f"💰 *Salary/Compensation:* {salary_summary}\n\n"

        job_summary += (
            f"👥 *Vacancy Number:* {vacancy_number}\n\n"
            f"{gender_icon} *Applicant Gender:* {applicant_gender}\n\n"
            f"⏳ *Job Application Deadline:* {formatted_deadline}\n\n"
            f"📄 *Job Description:*\n{job_description}\n"
            f"{'\\_' * 30}\n\n"  # Separator line
            f"{verified_company_section}"
            f"{'\\_' * 30}\n"
        )

        # Fetch the employer's chat_id (contact)
        cursor.execute('SELECT contact FROM users WHERE user_id = %s', (employer_user_id,))
        employer_chat_row = cursor.fetchone()
        employer_chat_id = employer_chat_row[0] if employer_chat_row else None

        if query_data.startswith("approve:"):
            # Update job status to 'opened' and notify employer of approval
            cursor.execute('''
                UPDATE job_posts 
                SET status_id = (SELECT status_id FROM job_status WHERE status_name = 'opened') 
                WHERE job_id = %s
            ''', (job_id,))
            conn.commit()


            # Get the channel username using getChat
            channel_chat = await context.bot.get_chat(CHANNEL_ID)  # Replace CHANNEL_ID with your channel ID
            channel_username = channel_chat.username  # Fetch the username dynamically

            # Send job post to channel with "Apply" button linking to bot
            apply_button = InlineKeyboardButton("Apply",
                                                url=f"https://t.me/{context.bot.username}?start=apply_{job_id}")
            reply_markup = InlineKeyboardMarkup([[apply_button]])

            sent_message = await context.bot.send_message(chat_id=CHANNEL_ID, text=job_summary, reply_markup=reply_markup,
                                                          parse_mode='Markdown')
            message_id = sent_message.message_id

            # Store message_id and channel_username in job_posts table
            cursor.execute('''
                UPDATE job_posts
                SET message_id = %s, channel_username = %s
                WHERE job_id = %s
            ''', (message_id, f"@{channel_username}", job_id))
            conn.commit()

            if employer_chat_id:
                job_post_link = f"https://t.me/{channel_username}/{message_id}"
                await context.bot.send_message(
                    chat_id=employer_chat_id,
                    text=(
                        f"🎉 Congratulations! Your job post titled "
                        f"<a href='{job_post_link}'>{job_title}</a> "
                        "has been successfully approved and is now live on our platform. 🎯\n\n"
                        "We wish you the best in finding the ideal candidate for your role!"
                    ),
                    parse_mode="HTML"  # Use HTML parse mode for clickable links
                )

            await query.answer(text="Job post approved and employer notified.", show_alert=True)


        elif query_data.startswith("deny:"):
            # Update job status to 'denied' and notify employer of denial
            cursor.execute('''
                UPDATE job_posts 
                SET status_id = (SELECT status_id FROM job_status WHERE status_name = 'denied') 
                WHERE job_id = %s
            ''', (job_id,))
            conn.commit()
            if employer_chat_id:
                await context.bot.send_message(chat_id=employer_chat_id,
                                               text=f"❌ Your job post '{job_title}' has been denied.")
            await query.answer(text="Job post denied and employer notified.", show_alert=True)

        # Remove the inline buttons from the original message for admin
        await query.edit_message_reply_markup(reply_markup=None)

    except (Exception, psycopg2.DatabaseError) as error:
        logger.error(f"Database error during approval: {error}")
        await query.answer(text="An error occurred during approval.")

    finally:
        if conn:
            cursor.close()
            conn.close()



async def handle_apply(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    job_id = query.data.split(":")[1]
    applicant_id = query.from_user.id

    # Save job_id and applicant_id to context data for later reference
    context.user_data['job_id'] = job_id
    context.user_data['applicant_id'] = applicant_id

    # Call confirm_application to prompt the applicant for confirmation
    return await confirm_application(update, context)

async def forward_message(update: Update, context: CallbackContext) -> int:
    job_id = context.user_data.get("job_id")
    employer_contact = context.user_data.get("employer_contact")

    if update.effective_user.id == employer_contact:
        await context.bot.send_message(chat_id=update.effective_user.id, text=f"Employer: {update.message.text}")
    else:
        await context.bot.send_message(chat_id=employer_contact, text=f"Applicant: {update.message.text}")

    return APPLY_CONVERSATION

async def end_conversation(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text("Conversation ended.")
    return


from telegram import ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove
from telegram.ext import ConversationHandler
import psycopg2

async def confirm_application(update: Update, context: CallbackContext, job_id: str) -> int:
    """Handle application button press and validate user registration, type, and job status."""
    applicant_contact = update.effective_user.id  # The user's Telegram ID

    try:
        # Connect to the PostgreSQL database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Check if the user is registered and get their user_type and gender
        cursor.execute('''
            SELECT user_type, gender, is_registered FROM users WHERE contact = %s
        ''', (str(applicant_contact),))
        user_row = cursor.fetchone()

        if not user_row:
            await update.message.reply_text("You are not registered. Please register to apply for jobs.")
            return

        user_type, applicant_gender, is_registered = user_row

        # Check if user is registered
        if not is_registered:
            await update.message.reply_text("You need to complete your registration before applying for jobs.")
            return

        # Check if the user type is Applicant
        if user_type != "Applicant":
            await update.message.reply_text("Your profile is registered as an Employer. Please switch to Applicant to apply.")
            return

        # Check the job status
        cursor.execute('''
            SELECT status_id
            FROM job_posts
            WHERE job_id = %s
        ''', (job_id,))
        job_status_row = cursor.fetchone()

        if not job_status_row:
            await update.message.reply_text("The job post does not exist.")
            return

        job_status_id = job_status_row[0]

        # Fetch the status_id for 'closed' jobs
        cursor.execute('''
            SELECT status_id
            FROM job_status
            WHERE status_name = 'closed'
        ''')
        closed_status_id = cursor.fetchone()[0]

        # Check if the job is closed
        if job_status_id == closed_status_id:
            await update.message.reply_text("Sorry, the job you are trying to apply for is closed.")
            return

        # Fetch the job post details
        cursor.execute('''
            SELECT job_title, applicant_gender, job_description, job_site, job_type, job_sector,
                   education_qualification, experience_level, location_country, location_city,
                   compensation_type, salary_compensation, currency_type, vacancy_number,
                   job_application_deadline, user_id
            FROM job_posts WHERE job_id = %s
        ''', (job_id,))
        job_post_row = cursor.fetchone()

        if not job_post_row:
            await update.message.reply_text("The job post does not exist.")
            return

        # Extract job details
        (job_title, required_gender, job_description, job_site, job_type, job_sector,
         education_qualification, experience_level, location_country, location_city,
         compensation_type, salary_compensation, currency_type, vacancy_number,
         job_application_deadline, employer_user_id) = job_post_row

        # Gender compatibility check
        if required_gender != "Both" and required_gender != applicant_gender:
            await update.message.reply_text(
                f"You cannot apply for this job. It is restricted to {required_gender.lower()} applicants."
            )
            return

        # Construct job summary
        salary_summary = ""
        if compensation_type or salary_compensation or currency_type:
            salary_summary = f"💰 *Salary/Compensation:* {salary_compensation or 'Not specified'} {currency_type or ''}"

        # Construct job summary
        job_summary = (
            f"🏷️ *Job Title:* {job_title}\n\n"
            f"🕒 *Job Type:* {job_site}, {job_type}\n\n"
            f"🏢 *Job Sector:* {job_sector}\n\n"
            f"📍 *Work Location:* {location_city}, {location_country}\n\n"
            f"🎓 *Education Qualification:* {education_qualification}\n\n"
            f"🎖️ *Experience Level:* {experience_level}\n\n"
            f"💰 *Salary/Compensation:* {salary_compensation} {currency_type}\n\n"
            f"👥 *Vacancy Number:* {vacancy_number}\n\n"
            f"⏳ *Application Deadline:* {job_application_deadline}\n\n"
            f"📄 *Job Description:*\n{job_description}"
        )

        # Send job summary
        sent_message = await update.message.reply_text(
            job_summary,
            parse_mode='Markdown'
        )

        # Send confirmation prompt as a reply to the job summary
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="Are you sure you want to apply for this job? Select Yes or No.",
            reply_to_message_id=sent_message.message_id,  # Link to the job summary
            reply_markup=ReplyKeyboardMarkup(
                [["Yes", "No"]],
                one_time_keyboard=True,
                resize_keyboard=True
            )
        )

        context.user_data['job_id'] = job_id  # Save job ID for later use
        return CONFIRM_APPLICATION

    except Exception as e:
        logger.error(f"Error during application validation: {e}")
        await update.message.reply_text("An error occurred. Please try again later.")
        return

    finally:
        if conn:
            cursor.close()
            conn.close()


from telegram import InlineKeyboardMarkup, InlineKeyboardButton

async def handle_confirmation(update: Update, context: CallbackContext) -> int:
    """Handle the user's confirmation response."""
    user_response = update.message.text.strip()

    if user_response == "No":
        # Redirect to Applicant Main Menu
        await update.message.reply_text(
            "Application canceled. Returning to the main menu...",
            reply_markup=ReplyKeyboardRemove()
        )
        return await show_applicant_main_menu(update, context)

    elif user_response == "Yes":
        # Display the application summary with inline buttons for editing
        return await show_application_summary(update, context)

    else:
        await update.message.reply_text("Please select either 'Yes' or 'No'.")
        return CONFIRM_APPLICATION


from telegram import ReplyKeyboardMarkup, ReplyKeyboardRemove
import psycopg2
import logging

logger = logging.getLogger(__name__)

async def show_application_summary(update: Update, context: CallbackContext) -> int:
    """Display the application summary with options to edit each section using keyboard buttons."""
    job_id = context.user_data.get('job_id')
    application_message = context.user_data.get('application_message', None)
    portfolio_links = context.user_data.get('portfolio_links', None)
    attachments = context.user_data.get('attachments', None)

    # Check if the user has a CV in their profile
    applicant_contact = update.effective_user.id
    has_cv = False

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()
        cursor.execute('SELECT resume FROM applicant_profiles WHERE user_id = (SELECT user_id FROM users WHERE contact = %s)', (str(applicant_contact),))
        resume_row = cursor.fetchone()
        if resume_row and resume_row[0]:
            has_cv = True
    except Exception as e:
        logger.error(f"Error checking CV: {e}")
    finally:
        if conn:
            cursor.close()
            conn.close()

    # Update the button text dynamically
    cv_button_text = "🖇️ Update CV" if has_cv else "🖇️ Upload CV"
    attachments_text = "CV already in profile" if has_cv else "No CV attached"

    # Construct the dynamic summary text
    summary_text = "Here is your application summary:\n\n"
    if application_message:
        summary_text += f"*Message:* {application_message}\n\n"
    if portfolio_links:
        summary_text += f"*Portfolio Links:* {portfolio_links}\n\n"
    summary_text += f"*Attachments:* {attachments_text}"

    # Keyboard buttons for editing specific sections
    keyboard = [
        ["✉️ Message", cv_button_text],
        ["🖋️ Portfolio", "✅ Submit Application"],
        ["💾 Save as Draft", "🗑️ Cancel Application"]
    ]

    # If called from a callback query, edit the message; else, send a new one
    if update.callback_query:
        query = update.callback_query
        await query.message.edit_text(
            summary_text,
            parse_mode='Markdown'
        )
        await query.message.reply_text(
            "Choose an option below:",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        )
    else:
        await update.message.reply_text(
            summary_text,
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True),
            parse_mode='Markdown'
        )

    return REVIEW_APPLICATION


async def handle_review_response(update: Update, context: CallbackContext) -> int:
    """Handle text-based button clicks from the keyboard."""
    user_response = update.message.text.strip()

    if user_response == "✉️ Message":
        await update.message.reply_text(
            "Please provide your updated message or press 🔙 Back to return to the summary.",
            reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
        )
        return COLLECT_APPLICATION_MESSAGE
    elif user_response in ["🖇️ Upload CV", "🖇️ Update CV"]:
        await update.message.reply_text(
            "Please upload your CV or press 🔙 Back to return to the summary.",
            reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
        )
        return UPLOAD_CV
    elif user_response == "🖋️ Portfolio":
        await update.message.reply_text(
            "Please provide your updated portfolio links or press 🔙 Back to return to the summary.",
            reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
        )
        return COLLECT_PORTFOLIO_LINKS
    elif user_response == "✅ Submit Application":
        await update.message.reply_text("Submitting your application...")
        return await handle_application_submission(update, context)  # Save to database and notify
    elif user_response == "💾 Save as Draft":
        await update.message.reply_text("Saving your application as a draft...")
        return await save_application_as_draft(update, context)  # Save to draft
    elif user_response == "🗑️ Cancel Application":
        await update.message.reply_text("Application process canceled.")
        return
    elif user_response == "🔙 Back":
        return await show_application_summary(update, context)
    else:
        await update.message.reply_text("Sorry, I didn't understand that.")
        return REVIEW_APPLICATION


async def save_application_as_draft(update: Update, context: CallbackContext) -> int:
    """Save the application as a draft in the database."""
    job_id = context.user_data.get('job_id')
    applicant_contact = update.effective_user.id
    application_message = context.user_data.get('application_message')
    portfolio_links = context.user_data.get('portfolio_links')
    attachments = context.user_data.get('attachments')

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO application_drafts (job_id, user_id, application_message, portfolio_links, attachments)
            VALUES (%s, (SELECT user_id FROM users WHERE contact = %s), %s, %s, %s)
            ON CONFLICT (job_id, user_id) 
            DO UPDATE SET application_message = EXCLUDED.application_message,
                          portfolio_links = EXCLUDED.portfolio_links,
                          attachments = EXCLUDED.attachments
        ''', (job_id, str(applicant_contact), application_message, portfolio_links, attachments))
        conn.commit()
        await update.message.reply_text("Your application has been saved as a draft.")
    except Exception as e:
        logger.error(f"Error saving draft: {e}")
        await update.message.reply_text("Failed to save your application as a draft.")
    finally:
        if conn:
            cursor.close()
            conn.close()

        # Redirect to Applicant Main Menu
    return await show_applicant_main_menu(update, context)


async def handle_submission_menu(update: Update, context: CallbackContext) -> int:
    """Handle actions from the submission menu."""
    query = update.callback_query  # Use callback_query for inline buttons
    if not query:
        await update.message.reply_text("Invalid action. Please try again.")
        return SUBMISSION_MENU

    user_choice = query.data  # Get callback data

    if user_choice == "edit_message":
        await query.message.edit_text("Please write your message.")
        return COLLECT_APPLICATION_MESSAGE
    elif user_choice == "upload_cv":
        await query.message.edit_text("Please upload your CV.")
        return UPLOAD_CV
    elif user_choice == "edit_portfolio":
        await query.message.edit_text("Please provide your portfolio links.")
        return COLLECT_PORTFOLIO_LINKS
    elif user_choice == "back_to_main_menu":
        await query.message.edit_text("Returning to the main menu...")
        return
    else:
        await query.answer("Invalid choice. Please select again.")
        return SUBMISSION_MENU

from telegram import InlineKeyboardMarkup, InlineKeyboardButton

async def collect_application_message(update: Update, context: CallbackContext) -> int:
    """Collect the applicant's message or handle the back button."""
    application_message = update.message.text.strip()

    if application_message == "🔙 Back":
        # Return to the application summary
        return await show_application_summary(update, context)

    if len(application_message) > 1000:
        await update.message.reply_text("Your message is too long. Please make sure it's under 1000 characters.")
        return COLLECT_APPLICATION_MESSAGE

    # Store the message in context
    context.user_data['application_message'] = application_message
    await update.message.reply_text("Thank you for providing your message!")

    # Return to the summary after updating the message
    return await show_application_summary(update, context)


async def collect_portfolio_links(update: Update, context: CallbackContext) -> int:
    """Collect the applicant's portfolio links or handle the back button."""
    portfolio_links = update.message.text.strip()

    if portfolio_links == "🔙 Back":
        # Return to the application summary
        return await show_application_summary(update, context)

    # Store the portfolio links in context
    context.user_data['portfolio_links'] = portfolio_links
    await update.message.reply_text("Thank you for providing your portfolio links!")

    # Return to the summary after updating the portfolio links
    return await show_application_summary(update, context)





import psycopg2
import logging
from telegram import ReplyKeyboardMarkup, Update
from telegram.ext import CallbackContext, ConversationHandler

logger = logging.getLogger(__name__)

async def handle_resume_app_upload(update: Update, context: CallbackContext) -> int:
    """Handles CV upload and updates the resume in the database."""
    if update.message.document:
        # Extract the file ID of the uploaded document
        file_id = update.message.document.file_id
        context.user_data['attachments'] = file_id  # Store file ID in user context

        # Retrieve Telegram user ID
        telegram_user_id = str(update.effective_user.id)

        try:
            # Connect to PostgreSQL database
            conn = psycopg2.connect(
                dbname="my_project_db",
                user="postgres",
                password="1201",
                host="localhost",
                port="5432"
            )
            cursor = conn.cursor()

            # Fetch the internal user_id using contact (Telegram user_id)
            cursor.execute('SELECT user_id FROM users WHERE contact = %s', (telegram_user_id,))
            user_id_row = cursor.fetchone()

            if not user_id_row:
                await update.message.reply_text("User not found. Please register first.")
                return

            user_id = user_id_row[0]

            # Check if a record exists in applicant_profiles for this user_id
            cursor.execute('SELECT 1 FROM applicant_profiles WHERE user_id = %s', (user_id,))
            record_exists = cursor.fetchone()

            if record_exists:
                # Update the existing record
                cursor.execute('UPDATE applicant_profiles SET resume = %s WHERE user_id = %s', (file_id, user_id))
                logger.info(f"Updated resume for user_id {user_id} in applicant_profiles.")
            else:
                # Insert a new record
                cursor.execute('INSERT INTO applicant_profiles (user_id, resume) VALUES (%s, %s)', (user_id, file_id))
                logger.info(f"Inserted new resume for user_id {user_id} in applicant_profiles.")

            # Commit the changes
            conn.commit()
            logger.info("Commit successful for updating/adding resume in applicant_profiles.")

            # Notify the user of success
            await update.message.reply_text("Your CV has been updated successfully!")

        except psycopg2.Error as e:
            logger.error(f"Database error: {e}")
            await update.message.reply_text("A database error occurred while updating your CV.")
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            await update.message.reply_text("An unexpected error occurred.")
        finally:
            if conn:
                cursor.close()
                conn.close()

        # Return to the application summary
        return await show_application_summary(update, context)

    # If no document is attached
    await update.message.reply_text(
        "Please upload a valid CV or press 🔙 Back to return to the summary.",
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
    )
    return UPLOAD_CV


async def submit_application(update: Update, context: CallbackContext) -> int:
    """Submit the collected application data to the database."""
    user_id = context.user_data.get('user_id')  # Retrieved from context
    job_id = context.user_data.get('job_id')  # Job ID from the application process
    application_message = context.user_data.get('application_message', 'No message provided.')
    portfolio_links = context.user_data.get('portfolio_links', 'No links provided.')

    application_date = datetime.now()

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Insert application data into the applications table
        cursor.execute('''
            INSERT INTO applications (user_id, job_id, application_date, application_message, portfolio_links)
            VALUES (%s, %s, %s, %s, %s)
        ''', (user_id, job_id, application_date, application_message, portfolio_links))

        conn.commit()  # Save changes

        await update.message.reply_text("Your application has been submitted successfully!")

    except psycopg2.Error as e:
        logger.error(f"Database error: {e}")
        await update.message.reply_text("An error occurred while submitting your application.")
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        await update.message.reply_text("An unexpected error occurred.")
    finally:
        if conn:
            cursor.close()
            conn.close()

    # Redirect user to the main menu or summary
    return await show_application_summary(update, context)


import psycopg2
import logging
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import CallbackContext, ConversationHandler

logger = logging.getLogger(__name__)

async def handle_application_submission(update: Update, context: CallbackContext) -> int:
    """Handle application submission, save to the database, and notify the employer."""
    query = update.callback_query
    applicant_contact = query.from_user.id if query else update.message.from_user.id
    job_id = context.user_data.get('job_id')
    application_message = context.user_data.get('application_message', 'No message provided.')
    portfolio_links = context.user_data.get('portfolio_links', 'No links provided.')
    resume_file_id = None

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve user details
        cursor.execute('SELECT user_id, first_name, last_name, gender FROM users WHERE contact = %s', (str(applicant_contact),))
        user_row = cursor.fetchone()
        if not user_row:
            await (query.message if query else update.message).reply_text("User not found in the database.")
            return

        user_id, first_name, last_name, gender = user_row
        full_name = f"{first_name} {last_name}"
        gender_icon = "👨🏾" if gender.lower() == "male" else "👩🏾"

        # Retrieve job details
        cursor.execute('SELECT job_title, channel_username, message_id FROM job_posts WHERE job_id = %s', (job_id,))
        job_post_row = cursor.fetchone()
        job_title = job_post_row[0] if job_post_row else "Unknown Job Title"
        channel_username = job_post_row[1].lstrip('@') if job_post_row[1] else None
        message_id = job_post_row[2] if job_post_row else None

        # Create a clickable job title link using HTML
        if channel_username and message_id:
            job_title_link = f'<a href="https://t.me/{channel_username}/{message_id}">{job_title}</a>'
        else:
            job_title_link = job_title

        # Retrieve portfolio and resume information
        cursor.execute('SELECT portfolio_link, resume FROM applicant_profiles WHERE user_id = %s', (user_id,))
        profile_row = cursor.fetchone()

        actual_portfolio = profile_row[0] if profile_row and profile_row[0] else None
        resume_file_id = profile_row[1] if profile_row and profile_row[1] else None

        # Insert application into the applications table and get the application_id
        cursor.execute('''
            INSERT INTO applications (user_id, job_id, application_date, application_message, portfolio_links)
            VALUES (%s, %s, NOW(), %s, %s) RETURNING application_id
        ''', (user_id, job_id, application_message, portfolio_links))

        application_id = cursor.fetchone()[0]  # Get the generated application_id
        conn.commit()

        # Retrieve employer's notification preference
        cursor.execute('''
            SELECT application_alerts 
            FROM company_profiles 
            WHERE user_id = (SELECT user_id FROM job_posts WHERE job_id = %s)
        ''', (job_id,))
        application_alerts_row = cursor.fetchone()
        application_alerts = application_alerts_row[0] if application_alerts_row else False

    except Exception as e:
        logger.error(f"Error handling application submission: {e}")
        await (query.message if query else update.message).reply_text(
            "An error occurred while submitting your application. Please try again later."
        )
        return

    finally:
        if conn:
            cursor.close()
            conn.close()

    # Dynamically build message text
    message_text = (
        f"📥 <b>New Application Received!</b>\n\n"
        f"\n{gender_icon} <b>Name:</b> {full_name}\n"
        f"\n📌 <b>Job Title:</b> {job_title_link}\n"
        f"\n✉️ <b>Message:</b> {application_message[:30]}{'...' if len(application_message) > 30 else ''}\n"
    )

    if actual_portfolio:
        message_text += f"\n🔗 <b>Portfolio:</b> <a href='{actual_portfolio}'>View Portfolio</a>\n"
    if resume_file_id:
        message_text += f"\n📄 <b>Resume:</b> Available for download\n"

    # Dynamically build inline buttons
    keyboard = [
        [InlineKeyboardButton("View Application", callback_data=f"view_application_{application_id}")],
        [InlineKeyboardButton("View Profile", callback_data=f"view_profile_{application_id}")],
    ]

    if resume_file_id:
        keyboard.append([InlineKeyboardButton("Download CV", callback_data=f"download_resume_{application_id}")])

    keyboard.append([InlineKeyboardButton("Shortlist", callback_data=f"shortlists_{application_id}")])
    keyboard.append([InlineKeyboardButton("Chat", callback_data=f"start_chat_{application_id}")])

    reply_markup = InlineKeyboardMarkup(keyboard)

    # Notify employer with or without sound
    notification_method_kwargs = {
        "chat_id": get_employer_contact(job_id),
        "text": message_text,
        "parse_mode": 'HTML',
        "reply_markup": reply_markup,
        "disable_notification": not application_alerts  # Silent if application_alerts is False
    }

    await context.bot.send_message(**notification_method_kwargs)

    # Notify the applicant
    await (query.message if query else update.message).reply_text(
        "Your application has been submitted to the employer. Thank you!"
    )

    # Redirect to Applicant Main Menu
    return await show_applicant_main_menu(update, context)


async def handle_download_resume(update: Update, context: CallbackContext) -> None:
    """Send the resume when the employer presses the Download Resume button."""
    query = update.callback_query
    await query.answer()

    try:
        # Extract application_id from the callback data
        data = query.data.split('_')  # Example: download_cv_12
        application_id = int(data[-1])

        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve the resume file ID using application_id
        cursor.execute('''
            SELECT ap.resume 
            FROM applications a
            JOIN applicant_profiles ap ON a.user_id = ap.user_id
            WHERE a.application_id = %s
        ''', (application_id,))
        resume_row = cursor.fetchone()

        if resume_row and resume_row[0]:
            resume_file_id = resume_row[0]
            await context.bot.send_document(
                chat_id=query.message.chat_id,
                document=resume_file_id,
                caption="Here is the requested resume."
            )
        else:
            await query.message.reply_text("No resume available for this application.")

    except Exception as e:
        logger.error(f"Error handling resume download: {e}")
        await query.message.reply_text("An error occurred while retrieving the resume.")

    finally:
        if conn:
            cursor.close()
            conn.close()


async def finalize_application(update: Update, context: CallbackContext) -> int:
    """Send the finalized application details to the employer, attaching the existing CV if applicable."""
    job_id = context.user_data.get('job_id')
    applicant_contact = update.callback_query.from_user.id if update.callback_query else update.message.from_user.id
    application_message = context.user_data.get('application_message', '')
    portfolio_links = context.user_data.get('portfolio_links', '')
    employer_contact = get_employer_contact(job_id)  # Ensure this function is implemented
    attachments = None

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve user details from the users table
        cursor.execute('SELECT user_id, first_name, last_name FROM users WHERE contact = %s', (str(applicant_contact),))
        user_row = cursor.fetchone()
        if not user_row:
            await update.message.reply_text("User not found in the database.")
            return

        user_id, first_name, last_name = user_row
        full_name = f"{first_name} {last_name}"

        # Retrieve job title from the job_posts table
        cursor.execute('SELECT job_title FROM job_posts WHERE job_id = %s', (job_id,))
        job_title_row = cursor.fetchone()
        job_title = job_title_row[0] if job_title_row else "Unknown Job Title"

        # Retrieve the resume from the applicant_profiles table
        cursor.execute('SELECT resume FROM applicant_profiles WHERE user_id = %s', (user_id,))
        resume_row = cursor.fetchone()
        attachments = resume_row[0] if resume_row and resume_row[0] else None

    except Exception as e:
        logger.error(f"Error retrieving application details: {e}")
        await update.message.reply_text("An error occurred while retrieving your application details. Please try again later.")
        return

    finally:
        if conn:
            cursor.close()
            conn.close()

    # Prepare the message text with application details
    message_text = (
        f"New application for the job *{job_title}* from *{full_name}*.\n\n"
        f"*Qualifications Message:* {application_message}\n\n"
        f"*Portfolio Links:* {portfolio_links}\n\n"
        f"Attachments: {'CV attached' if attachments else 'CV attached from profile'}"
    )

    # Send the message to the employer
    await context.bot.send_message(
        chat_id=employer_contact,
        text=message_text,
        parse_mode='Markdown'
    )

    # Send the CV as a document if available
    if attachments:
        await context.bot.send_document(chat_id=employer_contact, document=attachments)

    # Send confirmation to the applicant
    if update.callback_query:
        await update.callback_query.message.reply_text("Your application has been submitted to the employer. Thank you!")
    else:
        await update.message.reply_text("Your application has been submitted to the employer. Thank you!")

    return





async def cancel_application(update: Update, context: CallbackContext) -> int:
    """Cancel the application and redirect to the Applicant Main Menu."""
    await update.message.reply_text(
        "Application process canceled.",
        reply_markup=ReplyKeyboardRemove()
    )
    return await show_applicant_main_menu(update, context)


from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import CallbackContext
import psycopg2
import logging

logger = logging.getLogger(__name__)

async def view_begin_application(update: Update, context: CallbackContext) -> None:
    """Display all the information submitted by the applicant."""
    query = update.callback_query
    application_id = int(query.data.split("_")[-1])  # Extract application_id from callback data

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve application and applicant details
        cursor.execute('''
            SELECT u.first_name, u.last_name, u.gender, jp.job_title, a.application_message, 
                   ap.portfolio_link, ap.resume, jp.channel_username, jp.message_id
            FROM applications a
            JOIN users u ON a.user_id = u.user_id
            JOIN job_posts jp ON a.job_id = jp.job_id
            LEFT JOIN applicant_profiles ap ON a.user_id = ap.user_id
            WHERE a.application_id = %s
        ''', (application_id,))
        application_row = cursor.fetchone()

        if not application_row:
            await query.message.reply_text("Application details not found.")
            return

        (first_name, last_name, gender, job_title, application_message,
         portfolio_link, resume_file_id, channel_username, message_id) = application_row

        full_name = f"{first_name} {last_name}"
        gender_icon = "👨🏾" if gender.lower() == "male" else "👩🏾"

        # Create a clickable job title link using HTML
        if channel_username and message_id:
            job_title_link = f'<a href="https://t.me/{channel_username.lstrip("@")}/{message_id}">{job_title}</a>'
        else:
            job_title_link = job_title

        # Build message text
        message_text = (
            f"📥 <b>Application Details:</b>\n\n"
            f"\n{gender_icon} <b>Name:</b> {full_name}\n"
            f"\n📌 <b>Job Title:</b> {job_title_link}\n"
            f"\n✉️ <b>Message:</b> {application_message}\n"
        )

        if portfolio_link:
            message_text += f"\n🔗 <b>Portfolio:</b> <a href='{portfolio_link}'>View Portfolio</a>\n"
        if resume_file_id:
            message_text += f"\n📄 <b>Resume:</b> Available for download\n"

        # Build inline buttons
        keyboard = [
            [InlineKeyboardButton("Back", callback_data=f"back_to_application_{application_id}")]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)

        # Edit message to display the application details
        await query.message.edit_text(
            text=message_text,
            parse_mode='HTML',
            reply_markup=reply_markup
        )

    except Exception as e:
        logger.error(f"Error displaying application details: {e}")
        await query.message.reply_text("An error occurred while fetching the application details.")
    finally:
        if conn:
            cursor.close()
            conn.close()



async def applicant_begin_view_profile(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    application_id = int(query.data.split("_")[-1])  # Extract application_id from callback data

    logging.info(f"Fetching profile for application_id: {application_id}")

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch user_id and associated fields from applications and applicant_profiles
        cursor.execute('''
            SELECT ap.full_name, ap.job_title, ap.experience_level, ap.skills, ap.location, ap.phone_number, ap.email, 
                   ap.work_experience, ap.highest_degree, ap.university, ap.college, ap.graduation_year, ap.gpa, 
                   ap.certifications, ap.languages, ap.portfolio_link, ap.dob, ap.gender, ap.employment_type, ap.availability, a.user_id
            FROM applications a
            JOIN applicant_profiles ap ON a.user_id = ap.user_id
            WHERE a.application_id = %s
        ''', (application_id,))
        profile_data = cursor.fetchone()

        if not profile_data:
            logging.warning(f"No profile found for application_id: {application_id}")
            await query.answer("Applicant profile not found.", show_alert=True)
            return VIEW_APPLICANTS_STATE

        # Unpack profile data
        (full_name, job_title, experience_level, skills, location, phone_number, email,
         work_experience, highest_degree, university, college, graduation_year, gpa,
         certifications, languages, portfolio_link, dob, gender, employment_type, availability, user_id) = profile_data

        # Format phone number as clickable if it exists, prepend +251 (or other country code)
        formatted_phone_number = f"+{phone_number}" if phone_number else ""

        # Dynamically include only sections with actual data
        sections = filter(None, [
            add_section("Personal Information", [
                f"{'👨🏾' if gender.strip().lower() == 'male' else '👩🏾'} *Full Name:* {escape_markdown_v2(full_name)}",
                f"\n🎂 *Age:* {escape_markdown_v2(calculate_age(dob))}" if dob else "",
                f"\n📞 *Phone:* [{escape_markdown_v2(formatted_phone_number)}](tel:{formatted_phone_number})" if phone_number else "",
                f"\n✉️ *Email:* {escape_markdown_v2(email)}" if email else "",
                f"\n📍 *Location:* {escape_markdown_v2(location)}" if location else ""
            ]),
            add_section("Professional Overview", [
                f"💼 *Job Title:* {escape_markdown_v2(job_title)}" if job_title else "",
                f"\n📊 *Experience Level:* {escape_markdown_v2(experience_level)}" if experience_level else "",
                f"\n🕒 *Employment Type:* {escape_markdown_v2(employment_type)}" if employment_type else "",
                f"\n📅 *Availability:* {escape_markdown_v2(availability)}" if availability else ""
            ]),

            add_section("Work Experience", [
                f"🏢 {escape_markdown_v2(work_experience)}" if work_experience else ""
            ]),
            add_section("Education", [
                f"🎓 *Degrees:* {escape_markdown_v2(highest_degree)}" if highest_degree else "",
                f"\n🏫 *University:* {escape_markdown_v2(university)}" if university else "",
                f"\n🏛️ *College:* {escape_markdown_v2(college)}" if college else "",
                f"\n📅 *Graduation Year:* {escape_markdown_v2(graduation_year)}" if graduation_year else "",
                f"\n📊 *GPA:* {escape_markdown_v2(gpa)}" if gpa else ""
            ]),
            add_section("Certifications", [
                format_list_field(certifications, "📜") if certifications else ""
            ]),
            add_section("Languages", [
                format_list_field(languages, "🌐") if languages else ""
            ]),
            add_section("Skills", [
                format_list_field(skills, "🛠️") if skills else ""
            ]),
            add_section("Portfolio Links", [
                "\n\n".join([f"🔗 {escape_markdown_v2(link.strip())}" for link in portfolio_link.split(",") if link.strip()]) if portfolio_link else ""
            ])
        ])

        profile_info = "\n\n".join(sections)

        # Edit the message with the complete profile information
        await query.message.edit_text(
            profile_info,
            parse_mode='MarkdownV2',
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("Back to Applications", callback_data=f"back_to_application_{application_id}")]
            ])
        )
        await query.answer()  # Remove spinner

    except Exception as e:
        logging.error(f"Error fetching profile for application_id {application_id}: {e}")
        await query.message.edit_text("An error occurred while retrieving the profile.")
    finally:
        if conn:
            cursor.close()
            conn.close()

    return


from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import CallbackContext, ConversationHandler
import psycopg2
import logging

logger = logging.getLogger(__name__)
async def shortlist_begin_applicant(update: Update, context: CallbackContext) -> int:
    """Toggle the applicant's status between 'shortlisted' and 'pending' and update the message."""
    query = update.callback_query
    application_id = int(query.data.split("_")[-1])  # Extract application_id from callback data

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Check the current status
        cursor.execute('SELECT status FROM applications WHERE application_id = %s', (application_id,))
        current_status_row = cursor.fetchone()

        if not current_status_row:
            await query.answer("Application not found.", show_alert=True)
            return

        current_status = current_status_row[0]

        # Toggle the status
        new_status = 'pending' if current_status == 'shortlisted' else 'shortlisted'
        cursor.execute('UPDATE applications SET status = %s WHERE application_id = %s', (new_status, application_id))
        conn.commit()

        # Fetch updated status for UI feedback
        cursor.execute('SELECT status FROM applications WHERE application_id = %s', (application_id,))
        updated_status = cursor.fetchone()[0]

        # Fetch applicant and job details
        cursor.execute('''
            SELECT 
                u.contact, u.first_name, u.last_name, ap.resume, jp.job_title, 
                jp.channel_username, jp.message_id, c.company_name
            FROM applications a
            JOIN users u ON a.user_id = u.user_id
            JOIN job_posts jp ON a.job_id = jp.job_id
            LEFT JOIN applicant_profiles ap ON a.user_id = ap.user_id
            LEFT JOIN company_profiles c ON jp.user_id = c.user_id
            WHERE a.application_id = %s
        ''', (application_id,))
        applicant_data = cursor.fetchone()

        if applicant_data:
            applicant_contact, first_name, last_name, resume, job_title, channel_username, message_id, company_name = applicant_data

            # Notify the applicant if they are shortlisted
            if updated_status == "shortlisted":
                job_link = f"https://t.me/{channel_username.strip('@')}/{message_id}" if channel_username and message_id else "#"

                notification_message = (
                    "🎯 <b>You’ve made it to the shortlist!</b>\n\n"
                    f"Dear <b>{first_name} {last_name}</b>,\n\n"
                    f"You’re shortlisted for the <a href='{job_link}'>{job_title}</a> role"
                    + (f" at <b>{company_name}</b>" if company_name else "")
                    + ".\n\nYou’ll be hearing from the employer shortly. Congratulations and good luck!"
                )

                if applicant_contact:
                    try:
                        await context.bot.send_message(
                            chat_id=applicant_contact,
                            text=notification_message,
                            parse_mode="HTML"
                        )
                    except Exception as notify_error:
                        logger.warning(f"Could not notify applicant {applicant_contact}: {notify_error}")

        # Labels for buttons based on updated status
        shortlist_label = "Shortlist ✔️" if updated_status == "shortlisted" else "Shortlist"

        # Build dynamic inline keyboard
        buttons = [
            [InlineKeyboardButton("View Application", callback_data=f"view_application_{application_id}")],
            [InlineKeyboardButton("View Profile", callback_data=f"view_profile_{application_id}")]
        ]

        # Add "Download CV" button if resume exists
        if resume:  # Check if resume exists
            buttons.append([InlineKeyboardButton("Download CV", callback_data=f"download_resume_{application_id}")])

        buttons.append([InlineKeyboardButton(shortlist_label, callback_data=f"shortlists_{application_id}")])
        buttons.append([InlineKeyboardButton("Chat", callback_data=f"start_chat_{application_id}")])

        updated_keyboard = InlineKeyboardMarkup(buttons)

        # Update the reply markup in the message
        await query.message.edit_reply_markup(reply_markup=updated_keyboard)
        await query.answer("Status updated.", show_alert=True)

    except Exception as e:
        logger.error(f"Error toggling shortlist status: {e}")
        await query.answer("Failed to update shortlist status.", show_alert=True)

    finally:
        if conn:
            cursor.close()
            conn.close()

    return


from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import CallbackContext
import psycopg2
import logging

logger = logging.getLogger(__name__)

async def back_to_application(update: Update, context: CallbackContext) -> None:
    """Reconstruct and display the application message with dynamic content."""
    query = update.callback_query
    await query.answer()  # Acknowledge the query to avoid timeout

    # Extract application_id from callback_data
    application_id = int(query.data.split("_")[-1])

    try:
        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Retrieve application details using application_id
        cursor.execute('''
            SELECT jp.job_id, jp.job_title, jp.channel_username, jp.message_id,
                   a.application_message, a.status AS application_status, 
                   ap.portfolio_link, ap.resume, u.first_name, u.last_name, u.gender
            FROM applications a
            JOIN job_posts jp ON a.job_id = jp.job_id
            LEFT JOIN applicant_profiles ap ON a.user_id = ap.user_id
            JOIN users u ON a.user_id = u.user_id
            WHERE a.application_id = %s
        ''', (application_id,))
        application_row = cursor.fetchone()

        if not application_row:
            await query.edit_message_text("Application details not found.")
            return

        (job_id, job_title, channel_username, message_id, application_message,
         application_status, actual_portfolio, resume_file_id, first_name,
         last_name, gender) = application_row

        full_name = f"{first_name} {last_name}"
        gender_icon = "👨🏾" if gender.lower() == "male" else "👩🏾"

        # Create a clickable job title link using HTML
        if channel_username and message_id:
            job_title_link = f'<a href="https://t.me/{channel_username.lstrip("@")}/{message_id}">{job_title}</a>'
        else:
            job_title_link = job_title

        # Dynamically build message text
        message_text = (
            f"📥 <b>New Application Received!</b>\n\n"
            f"\n{gender_icon} <b>Name:</b> {full_name}\n"
            f"\n📌 <b>Job Title:</b> {job_title_link}\n"
            f"\n✉️ <b>Message:</b> {application_message[:30]}{'...' if len(application_message) > 30 else ''}\n"
        )

        if actual_portfolio:
            message_text += f"\n🔗 <b>Portfolio:</b> <a href='{actual_portfolio}'>View Portfolio</a>\n"
        if resume_file_id:
            message_text += f"\n📄 <b>Resume:</b> Available for download\n"

        # Dynamically build inline buttons
        keyboard = [
            [InlineKeyboardButton("View Application", callback_data=f"view_application_{application_id}")],
            [InlineKeyboardButton("View Profile", callback_data=f"view_profile_{application_id}")],
        ]

        if application_status == 'shortlisted':
            keyboard.append([InlineKeyboardButton("✔️ Shortlisted", callback_data="shortlisted_already")])
        else:
            if resume_file_id:
                keyboard.append([InlineKeyboardButton("Download CV", callback_data=f"download_resume_{application_id}")])
            keyboard.append([InlineKeyboardButton("Shortlist", callback_data=f"shortlists_{application_id}")])

        keyboard.append([InlineKeyboardButton("Chat", callback_data=f"start_chat_{application_id}")])

        reply_markup = InlineKeyboardMarkup(keyboard)

        # Edit the message to resemble the original application submission
        await query.edit_message_text(message_text, parse_mode='HTML', reply_markup=reply_markup)

    except Exception as e:
        logger.error(f"Error reconstructing application message: {e}")
        await query.edit_message_text("An error occurred while reconstructing the application message.")
    finally:
        if conn:
            cursor.close()
            conn.close()



async def fallback_cancel(update: Update, context: CallbackContext) -> int:
    """Handle cancellation of the application process."""
    await update.message.reply_text("Application process canceled.")
    return

async def fallback_help(update, context):
    await update.message.reply_text("It seems you need help. Here’s what you can do...")
    return

async def fallback_general(update, context):
    await update.message.reply_text("Sorry, I didn't understand that.")
    return

async def application_complete(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Application process is complete. Thank you for applying!"
    )
    return


def get_employer_contact(job_id: str) -> str:
    """Retrieve the employer's contact information for the specified job_id."""
    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch the employer's contact information based on job_id
        cursor.execute('''
            SELECT users.contact
            FROM job_posts
            JOIN users ON job_posts.user_id = users.user_id
            WHERE job_posts.job_id = %s
        ''', (job_id,))

        result = cursor.fetchone()
        if result:
            return result[0]  # Return the contact if found
        else:
            logger.error(f"No employer contact found for job_id: {job_id}")
            return None

    except Exception as e:
        logger.error(f"Error retrieving employer contact for job_id {job_id}: {e}")
        return None

    finally:
        if conn:
            cursor.close()
            conn.close()


async def handle_manage_jobs_menu(update: Update, context: CallbackContext):
    await update.message.reply_text(
        "Manage Jobs Options:",
        reply_markup=ReplyKeyboardMarkup([
            ["Active Jobs", "Expired Jobs"],
            ["Draft Jobs", "Pending Approval Jobs"],
            ["Closed Jobs", "Repost Jobs", "Back to Main Menu"]
        ], resize_keyboard=True)
    )
    return MANAGE_JOBS_MENU  # State for handling manage jobs menu

async def handle_view_applicants_menu(update: Update, context: CallbackContext):
    await update.message.reply_text(
        "View Applicants Options:",
        reply_markup=ReplyKeyboardMarkup([
            ["View by Job Posts", "Applicant Details"],
            ["Application Status", "Schedule Interview", "Back to Main Menu"]
        ], resize_keyboard=True)
    )
    return VIEW_APPLICANTS_MENU  # State for handling view applicants menu

async def handle_search_candidates_menu(update: Update, context: CallbackContext):
    await update.message.reply_text(
        "Search Candidates Options:",
        reply_markup=ReplyKeyboardMarkup([
            ["Filter by Skills", "Filter by Experience"],
            ["Filter by Location", "View Candidate Profiles", "Back to Main Menu"]
        ], resize_keyboard=True)
    )
    return SEARCH_CANDIDATES_MENU  # State for handling search candidates menu

async def handle_shortlisted_candidates_menu(update: Update, context: CallbackContext):
    await update.message.reply_text(
        "Shortlisted Candidates Options:",
        reply_markup=ReplyKeyboardMarkup([
            ["Review Shortlisted Applicants", "Message Candidates"],
            ["Schedule Interviews", "Back to Main Menu"]
        ], resize_keyboard=True)
    )
    return SHORTLISTED_CANDIDATES_MENU  # State for handling shortlisted candidates menu


async def handle_job_analytics_menu(update: Update, context: CallbackContext):
    await update.message.reply_text(
        "Job Analytics Options:",
        reply_markup=ReplyKeyboardMarkup([
            ["Job Views", "Number of Applicants"],
            ["Application Conversion Rate", "Average Time to Hire", "Back to Main Menu"]
        ], resize_keyboard=True)
    )
    return JOB_ANALYTICS_MENU  # State for handling job analytics menu

async def handle_manage_jobs(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Manage your jobs by selecting one of the options below:",
        reply_markup=ReplyKeyboardMarkup([
            ["Active Jobs", "Expired Jobs"],
            ["Draft Jobs", "Pending Approval Jobs"],
            ["Closed Jobs", "Repost Jobs"],
            ["Back to Main Menu"]
        ], resize_keyboard=True)
    )
    return MANAGE_JOBS_MENU  # Return the corresponding state


# Function to handle "Create New Job Postings" selection
async def handle_new_job(update: Update, context: CallbackContext) -> int:
    # Ask the employer to enter the job title
    await update.message.reply_text(
        "Please enter the job title for the new job posting:",
        reply_markup=ReplyKeyboardMarkup(
            [["Back"]],  # Display only the "Back" button
            resize_keyboard=True,  # Ensure the button is properly sized for mobile users
            one_time_keyboard=True  # Hide the keyboard after pressing Back
        )
    )

    # Transition to the state where the job title is captured
    return JOB_TITLE


# Function to handle when the user presses "Back"
async def handle_back_to_main_menu(update: Update, context: CallbackContext) -> int:
    # Show the employer main menu again
    await update.message.reply_text(
        "You have returned to the employer main menu.",
        reply_markup=ReplyKeyboardMarkup(
            [
                ["Post a Job", "Manage Jobs"],
                ["View Applicants", "Search Candidates"],
                ["Shortlisted Candidates", "Company Profile"],
                ["Notifications", "Job Analytics"]
            ],
            resize_keyboard=True
        )
    )

    # Transition back to the employer main menu
    return EMPLOYER_MENU


# Function to handle job templates
async def handle_job_templates(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Here are your job posting templates."
    )
    return EMPLOYER_MENU  # Return to the main employer menu

# Function to handle job posting guidelines
async def handle_job_guidelines(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Here are the job posting guidelines."
    )
    return EMPLOYER_MENU  # Return to the main employer menu

# Function to handle active jobs
async def handle_active_jobs(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Listing all active jobs..."
    )
    return MANAGE_JOBS_MENU

# Function to handle expired jobs
async def handle_expired_jobs(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Listing all expired jobs..."
    )
    return MANAGE_JOBS_MENU

# Function to handle draft jobs
async def handle_draft_jobs(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Listing all draft jobs..."
    )
    return MANAGE_JOBS_MENU

async def handle_pending_approval_jobs(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Listing all jobs pending approval..."
    )
    return MANAGE_JOBS_MENU  # Or the appropriate next step in your conversation flow

# Function to handle closed jobs
async def handle_closed_jobs(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Listing all closed jobs..."
    )
    return MANAGE_JOBS_MENU  # Or whatever state you want to return to

# Function to handle saved jobs
async def handle_saved_jobs(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Listing all saved jobs..."
    )
    return MANAGE_JOBS_MENU  # Or whatever state is appropriate

# Function to handle active jobs (example from the last answer)
async def handle_active_jobs(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Listing all active jobs..."
    )
    return MANAGE_JOBS_MENU  # Adjust the state if needed



# Function to handle viewing applicants by job posts
async def handle_view_by_job_posts(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Listing applicants by job posts..."
    )
    return VIEW_APPLICANTS_MENU  # Return to the applicant viewing menu or adjust as needed

# Define other related functions if needed

# Example: Function to handle applicant details
async def handle_applicant_details(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Showing applicant details..."
    )
    return VIEW_APPLICANTS_MENU



# Example: Function to handle scheduling interviews
async def handle_schedule_interview(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Scheduling interviews..."
    )
    return VIEW_APPLICANTS_MENU

# Function to handle filtering candidates by skills
async def handle_filter_by_skills(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Filtering candidates by skills..."
    )
    return SEARCH_CANDIDATES_MENU  # Return to the search candidates menu or the appropriate next state

# Function to handle filtering candidates by experience
async def handle_filter_by_experience(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Filtering candidates by experience..."
    )
    return SEARCH_CANDIDATES_MENU  # Return to the appropriate menu

# Function to handle filtering candidates by location
async def handle_filter_by_location(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Filtering candidates by location..."
    )
    return SEARCH_CANDIDATES_MENU

# Function to handle viewing candidate profiles
async def handle_view_candidate_profiles(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Displaying candidate profiles..."
    )
    return SEARCH_CANDIDATES_MENU

# Function to handle reviewing shortlisted applicants
async def handle_review_shortlisted_applicants(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Reviewing shortlisted applicants..."
    )
    return SHORTLISTED_CANDIDATES_MENU  # Return to the appropriate menu or state

# Function to handle messaging candidates
async def handle_message_candidates(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Messaging shortlisted candidates..."
    )
    return SHORTLISTED_CANDIDATES_MENU

# Function to handle scheduling interviews with shortlisted candidates
async def handle_schedule_shortlisted_interviews(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Scheduling interviews for shortlisted candidates..."
    )
    return SHORTLISTED_CANDIDATES_MENU

# Function to handle editing company details
async def handle_edit_company_details(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please provide the new company details to update."
    )
    return COMPANY_PROFILE_MENU  # Return to the company profile menu or proceed accordingly

# Function to handle updating the company logo
async def handle_update_logo(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please upload the new company logo."
    )
    return COMPANY_PROFILE_MENU

# Function to handle updating the company description
async def handle_company_description(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please provide the new company description."
    )
    return COMPANY_PROFILE_MENU

# Function to handle updating contact information
async def handle_contact_information(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Please provide updated contact information."
    )
    return COMPANY_PROFILE_MENU

# Function to handle job post status updates
async def handle_job_post_status_updates(update: Update, context: CallbackContext) -> int:
    # You can add functionality to show status updates for job postings here.
    await update.message.reply_text(
        "Here are the status updates for your job posts:"
        "\n1. Job Post ID: 123 - Status: Active"
        "\n2. Job Post ID: 124 - Status: Pending Approval"
        "\n3. Job Post ID: 125 - Status: Closed"
    )
    return NOTIFICATIONS_MENU  # Return to notifications menu or proceed accordingly

# Function to handle new applicant notifications
async def handle_new_applicant_notifications(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "You have new applicant notifications."
        "\n1. Applicant: John Doe - Applied for: Software Engineer"
        "\n2. Applicant: Jane Smith - Applied for: Data Scientist"
    )
    return NOTIFICATIONS_MENU

# Function to handle interview schedule notifications
async def handle_interview_schedule_notifications(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Here are your interview schedule notifications:"
        "\n1. Interview with John Doe - Scheduled: 10/10/2024 at 2:00 PM"
        "\n2. Interview with Jane Smith - Scheduled: 11/10/2024 at 10:00 AM"
    )
    return NOTIFICATIONS_MENU

# Function to handle job views analytics
async def handle_job_views(update: Update, context: CallbackContext) -> int:
    # Provide information or analytics related to job views
    await update.message.reply_text(
        "Here are the analytics for job views:"
        "\n1. Job Post ID: 123 - Views: 150"
        "\n2. Job Post ID: 124 - Views: 98"
        "\n3. Job Post ID: 125 - Views: 45"
    )
    return JOB_ANALYTICS_MENU  # Return to job analytics menu or proceed accordingly

# Function to handle number of applicants
async def handle_number_of_applicants(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Number of applicants for your job posts:"
        "\n1. Job Post ID: 123 - Applicants: 50"
        "\n2. Job Post ID: 124 - Applicants: 30"
    )
    return JOB_ANALYTICS_MENU

# Function to handle application conversion rate
async def handle_application_conversion_rate(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Application conversion rate analytics:"
        "\n1. Job Post ID: 123 - Conversion Rate: 25%"
        "\n2. Job Post ID: 124 - Conversion Rate: 20%"
    )
    return JOB_ANALYTICS_MENU

# Function to handle average time to hire
async def handle_average_time_to_hire(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Average time to hire for your job posts:"
        "\n1. Job Post ID: 123 - Time to Hire: 15 days"
        "\n2. Job Post ID: 124 - Time to Hire: 10 days"
    )
    return JOB_ANALYTICS_MENU


# Helper function to format the job summary
def format_job_summary(context):
    return (
        f"<b>Job Title:</b> {context.user_data['job_title']}\n\n"                 # 1st: Job Title
        f"<b>Job Type:</b> {context.user_data['job_type']}\n\n"                   # 2nd: Job Type
        f"<b>Job Sector:</b> {context.user_data['job_sector']}\n\n"               # 3rd: Job Sector
        f"<b>Job Site:</b> {context.user_data['job_site']}\n\n"                   # 4th: Job Site
        f"<b>Location (Country):</b> {context.user_data['location_country']}\n\n" # 5th: Location (Country)
        f"<b>Location (City):</b> {context.user_data['location_city']}\n\n"       # 6th: Location (City)
        f"<b>Education Qualification:</b> {context.user_data['education_qualification']}\n\n"  # 7th: Education Qualification
        f"<b>Experience Level:</b> {context.user_data['experience_level']}\n\n"   # 8th: Experience Level
        f"<b>Compensation Type:</b> {context.user_data['compensation_type']}\n\n" # 9th: Compensation Type
        f"<b>Salary/Compensation:</b> {context.user_data['salary_compensation']}\n\n"  # 10th: Salary/Compensation
        f"<b>Application Deadline:</b> {context.user_data.get('job_application_deadline', 'No deadline set')}\n\n"  # 11th: Job Application Deadline
        f"<b>Currency Type:</b> {context.user_data['currency_type']}\n\n"         # 12th: Currency Type
        f"<b>Vacancy Number:</b> {context.user_data['vacancy_number']}\n\n"       # 13th: Vacancy Number
        f"<b>Applicant Gender:</b> {context.user_data['applicant_gender']}\n\n"   # 14th: Applicant Gender
        f"<b>Job Description:</b>\n{context.user_data['job_description']}"        # 15th: Job Description (Bottom)
    )

# Step 1: Show the main admin menu
async def show_admin_menu(update, context):
    await update.message.reply_text(
        "Please choose an option from the Admin Menu:",
        reply_markup=ReplyKeyboardMarkup([
            ["📋 Post Management", "👥 User Management"],
            ["🛡️ Moderation", "⚙️ Platform Settings"],
            ["📈 Analytics & Reports", "💵 Monetization"],
            ["🛠️ Support & Issue Resolution"]
        ], resize_keyboard=True)
    )
    return ADMIN_MENU  # Transition to the admin menu state


# Function to handle the main menu choices for admins
async def handle_admin_main_menu_choice(update: Update, context: CallbackContext) -> int:
    choice = update.message.text

    # Handle Post Management submenu
    if choice == "📋 Post Management":
        return await show_post_management_menu(update, context)  # Transition to Post Management submenu

    # Handle User Management submenu
    elif choice == "👥 User Management":
        return await show_user_management_menu(update, context)  # Transition to User Management submenu

    # Handle Moderation submenu
    elif choice == "🛡️ Moderation":
        return await show_moderation_menu(update, context)  # Transition to Moderation submenu

    # Handle Platform Settings submenu
    elif choice == "⚙️ Platform Settings":
        return await show_platform_settings_menu(update, context)  # Transition to Platform Settings submenu

    # Handle Analytics & Reports submenu
    elif choice == "📈 Analytics & Reports":
        return await show_analytics_reports_menu(update, context)  # Transition to Analytics & Reports submenu

    # Handle Monetization submenu
    elif choice == "💵 Monetization":
        return await show_monetization_menu(update, context)  # Transition to Monetization submenu

    # Handle Support & Issue Resolution submenu
    elif choice == "🛠️ Support & Issue Resolution":
        return await show_support_issue_resolution_menu(update, context)  # Transition to Support & Issue Resolution submenu

    else:
        # If the choice is invalid, ask the user to select a valid option
        await update.message.reply_text("Invalid choice, please select a valid option from the menu.")
        return ADMIN_MAIN_MENU  # Stay in the main menu state


# Post Management Submenu
async def show_post_management_menu(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Post Management: Please choose an action.",
        reply_markup=ReplyKeyboardMarkup([
            ["Approve/Reject Job Posts", "Edit Job Posts"],
            ["View Flagged Job Posts", "Back"]
        ], resize_keyboard=True)
    )
    return JOB_POST_MANAGEMENT  # A new state for Job Post Management menu


# User Management Submenu
async def show_user_management_menu(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "User Management: Please choose an action.",
        reply_markup=ReplyKeyboardMarkup([
            ["Manage Employers", "Manage Job Seekers"],
            ["Ban/Unban Users", "View Registered Users"],
            ["Back"]
        ], resize_keyboard=True)
    )
    return USER_MANAGEMENT  # A new state for User Management menu


# Moderation Submenu
async def show_moderation_menu(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Moderation: Please choose an action.",
        reply_markup=ReplyKeyboardMarkup([
            ["Manage Comments", "Flagged Content Review"],
            ["Back"]
        ], resize_keyboard=True)
    )
    return CONTENT_MODERATION  # A new state for Content Moderation menu


# Platform Settings Submenu
async def show_platform_settings_menu(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Platform Settings: Please choose an action.",
        reply_markup=ReplyKeyboardMarkup([
            ["Job Categories", "Location Management"],
            ["Notification Settings", "Back"]
        ], resize_keyboard=True)
    )
    return PLATFORM_SETTINGS  # A new state for Platform Settings menu


# Analytics & Reports Submenu
async def show_analytics_reports_menu(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Analytics & Reports: Please choose an action.",
        reply_markup=ReplyKeyboardMarkup([
            ["User Activity Reports", "Job Post Insights"],
            ["Applicant Insights", "Revenue Reports"],
            ["Back"]
        ], resize_keyboard=True)
    )
    return ANALYTICS_REPORTS  # A new state for Analytics & Reports menu


# Monetization Submenu
async def show_monetization_menu(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Monetization: Please choose an action.",
        reply_markup=ReplyKeyboardMarkup([
            ["Manage Payment Options", "View Transactions"],
            ["Refund Management", "Back"]
        ], resize_keyboard=True)
    )
    return MONETIZATION  # A new state for Monetization menu


# Support & Issue Resolution Submenu
async def show_support_issue_resolution_menu(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "Support & Issue Resolution: Please choose an action.",
        reply_markup=ReplyKeyboardMarkup([
            ["📨 Contact Employers", "📨 Contact Applicants"],
            ["Back"]
        ], resize_keyboard=True)
    )
    return SUPPORT_ISSUE_RESOLUTION  # A new state for Support & Issue Resolution menu


# Post Management Submenu Handler
async def handle_post_management_menu_choice(update: Update, context: CallbackContext) -> int:
    choice = update.message.text

    if choice == "Approve/Reject Job Posts":
        return await approve_reject_job_posts(update, context)

    elif choice == "Edit Job Posts":
        return await handle_edit_job_posts(update, context)

    elif choice == "View Flagged Job Posts":
        return await handle_view_flagged_job_posts(update, context)

    elif choice == "Back":
        return await show_admin_menu(update, context)

    else:
        await update.message.reply_text("Invalid choice, please select a valid option.")
        return JOB_POST_MANAGEMENT  # Stay in Post Management menu

# User Management Submenu Handler
async def handle_user_management_menu_choice(update: Update, context: CallbackContext) -> int:
    choice = update.message.text

    if choice == "Manage Employers":
        return await manage_employers(update, context)

    elif choice == "Manage Job Seekers":
        return await handle_manage_job_seekers(update, context)

    elif choice == "Ban/Unban Users":
        return await handle_ban_unban_users(update, context)

    elif choice == "View Registered Users":
        return await handle_view_registered_users(update, context)

    elif choice == "Back":
        return await show_admin_menu(update, context)

    else:
        await update.message.reply_text("Invalid choice, please select a valid option.")
        return USER_MANAGEMENT  # Stay in User Management menu

# Moderation Submenu Handler
async def handle_moderation_menu_choice(update: Update, context: CallbackContext) -> int:
    choice = update.message.text

    if choice == "Manage Comments":
        return await handle_manage_comments(update, context)

    elif choice == "Flagged Content Review":
        return await handle_flagged_content_review(update, context)

    elif choice == "Back":
        return await show_admin_menu(update, context)

    else:
        await update.message.reply_text("Invalid choice, please select a valid option.")
        return CONTENT_MODERATION  # Stay in Moderation menu

# Platform Settings Submenu Handler
async def handle_platform_settings_menu_choice(update: Update, context: CallbackContext) -> int:
    choice = update.message.text

    if choice == "Job Categories":
        return await handle_job_categories(update, context)

    elif choice == "Location Management":
        return await handle_location_management(update, context)

    elif choice == "Notification Settings":
        return await handle_notification_settings(update, context)

    elif choice == "Back":
        return await show_admin_menu(update, context)

    else:
        await update.message.reply_text("Invalid choice, please select a valid option.")
        return PLATFORM_SETTINGS  # Stay in Platform Settings menu

# Analytics & Reports Submenu Handler
async def handle_analytics_reports_menu_choice(update: Update, context: CallbackContext) -> int:
    choice = update.message.text

    if choice == "User Activity Reports":
        return await handle_user_activity_reports(update, context)

    elif choice == "Job Post Insights":
        return await handle_job_post_insights(update, context)

    elif choice == "Applicant Insights":
        return await handle_applicant_insights(update, context)

    elif choice == "Revenue Reports":
        return await handle_revenue_reports(update, context)

    elif choice == "Back":
        return await show_admin_menu(update, context)

    else:
        await update.message.reply_text("Invalid choice, please select a valid option.")
        return ANALYTICS_REPORTS  # Stay in Analytics & Reports menu

# Monetization Submenu Handler
async def handle_monetization_menu_choice(update: Update, context: CallbackContext) -> int:
    choice = update.message.text

    if choice == "Manage Payment Options":
        return await handle_manage_payment_options(update, context)

    elif choice == "View Transactions":
        return await handle_view_transactions(update, context)

    elif choice == "Refund Management":
        return await handle_refund_management(update, context)

    elif choice == "Back":
        return await show_admin_menu(update, context)

    else:
        await update.message.reply_text("Invalid choice, please select a valid option.")
        return MONETIZATION  # Stay in Monetization menu

# Support & Issue Resolution Submenu Handler
async def handle_support_issue_resolution_menu_choice(update: Update, context: CallbackContext) -> int:
    choice = update.message.text

    if choice == "📨 Contact Employers":
        return await handle_view_user_reports(update, context)

    elif choice == "📨 Contact Applicants":
        return await handle_resolve_issues(update, context)

    elif choice == "Back":
        return await show_admin_menu(update, context)

    else:
        await update.message.reply_text("Invalid choice, please select a valid option.")
        return SUPPORT_ISSUE_RESOLUTION  # Stay in Support & Issue Resolution menu




async def approve_reject_job_posts(update, context):
    # Logic to approve/reject job posts
    await update.message.reply_text("Here you can approve or reject job posts.")
    return


from telegram import InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import CallbackContext

async def employer_pagination(update, context: CallbackContext):
    """Handles pagination for employer management with company names dynamically displayed."""
    # Determine whether the input is from a button (callback query) or a message
    if update.callback_query:
        message_data = update.callback_query.data
    elif update.message:
        message_data = update.message.text
    else:
        await update.message.reply_text("Invalid input. Please use the navigation buttons.")
        return

    # Retrieve the current page number from context
    current_page = context.user_data.get('current_page', 1)

    # Adjust page number based on the user's input
    if message_data == 'Next':
        current_page += 1
    elif message_data == 'Previous':
        current_page -= 1
    elif message_data == 'Back':
        await update.message.reply_text("Returning to the main menu...")
        return await show_admin_menu(update, context)
    else:
        await update.message.reply_text("Invalid choice, please use the navigation buttons.")
        return

    # Fetch employers for the current page, including company names
    employers, total_employers = await fetch_employers_for_page(current_page)

    if not employers:
        await update.message.reply_text("No more employers to display.")
        return

    # Save the updated current page in user_data
    context.user_data['current_page'] = current_page

    # Generate the message with employer details
    message = f"Registered Employers (Page {current_page}/{-(-total_employers // EMPLOYERS_PER_PAGE)}):\n\n"
    for employer in employers:
        phone_number = employer['phone_number']
        # Ensure the phone number has a "+" prefix
        if not phone_number.startswith('+'):
            phone_number = f"+{phone_number}"

        message += (
            f"👤 <b>Name:</b> {employer['first_name']} {employer['last_name']}\n"
            f"📧 <b>Email:</b> {employer['email']}\n"
            f"📲 <b>Phone:</b> {phone_number}\n"
            f"📍 <b>Location:</b> {employer['city']}, {employer['country']}\n"
            f"🆔 <b>User ID:</b> {employer['user_id']}\n"  # Add User ID here
        )
        if employer['company_name']:
            message += f"🏢 <b>Company Name:</b> {employer['company_name']}\n"
        message += "------------------------------\n"

    # Add navigation buttons
    navigation_buttons = []
    if current_page > 1:
        navigation_buttons.append("Previous")
    if current_page * EMPLOYERS_PER_PAGE < total_employers:
        navigation_buttons.append("Next")
    navigation_buttons.append("Back")

    if update.callback_query:
        await update.callback_query.answer()
        await update.callback_query.message.edit_text(
            message,
            reply_markup=ReplyKeyboardMarkup([navigation_buttons], resize_keyboard=True),
            parse_mode="HTML"  # Use HTML for formatting
        )
    elif update.message:
        await update.message.reply_text(
            message,
            reply_markup=ReplyKeyboardMarkup([navigation_buttons], resize_keyboard=True),
            parse_mode="HTML"  # Use HTML for formatting
        )


import asyncpg

EMPLOYERS_PER_PAGE = 10  # Number of employers per page


async def fetch_employers_for_page(page: int):
    offset = (page - 1) * EMPLOYERS_PER_PAGE
    try:
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )

        # Query to fetch total number of employers
        total_employers = await conn.fetchval("SELECT COUNT(*) FROM users WHERE user_type = 'Employer'")

        # Query to fetch employer details and company name, including user_id
        employers = await conn.fetch("""
            SELECT 
                u.user_id,  -- Include user_id
                u.first_name, 
                u.last_name, 
                u.email, 
                u.phone_number, 
                u.city, 
                u.country,
                c.company_name
            FROM users u
            LEFT JOIN company_profiles c ON u.user_id = c.user_id
            WHERE u.user_type = 'Employer'
            ORDER BY u.user_id
            LIMIT $1 OFFSET $2
        """, EMPLOYERS_PER_PAGE, offset)

        return employers, total_employers

    except Exception as e:
        print(f"Database error: {e}")
        return [], 0

    finally:
        if conn:
            await conn.close()


import asyncpg
from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import CallbackContext, ConversationHandler


async def manage_employers(update: Update, context: CallbackContext) -> int:
    """
    Lists all registered employers in sections with pagination, including company names if available.
    """
    page = context.user_data.get("employer_page", 1)  # Default to the first page

    # Connect to the database
    try:
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )

        # Fetch total number of employers
        total_employers = await conn.fetchval("SELECT COUNT(*) FROM users WHERE user_type = 'Employer'")

        # Calculate pagination
        offset = (page - 1) * EMPLOYERS_PER_PAGE

        # Fetch employer details for the current page, including company name if available
        employers = await conn.fetch("""
            SELECT 
                u.user_id, u.first_name, u.last_name, u.email, u.phone_number, u.city, u.country,
                c.company_name
            FROM users u
            LEFT JOIN company_profiles c ON u.user_id = c.user_id
            WHERE u.user_type = 'Employer'
            ORDER BY u.user_id
            LIMIT $1 OFFSET $2
        """, EMPLOYERS_PER_PAGE, offset)

    except Exception as e:
        logger.error(f"Database error: {e}")
        await update.message.reply_text(
            "An error occurred while fetching the employers. Please try again later.",
            reply_markup=ReplyKeyboardMarkup([["🔙 Back to Menu"]], resize_keyboard=True)
        )
        return

    finally:
        # Close the database connection
        if conn:
            await conn.close()

    if not employers:
        await update.message.reply_text("No registered employers found.")
        return

    # Construct the message with employer details, including company names
    message = f"Registered Employers (Page {page}/{-(-total_employers // EMPLOYERS_PER_PAGE)}):\n\n"
    for employer in employers:
        user_id, first_name, last_name, email, phone_number, city, country, company_name = employer

        # Ensure the phone number has a "+" prefix
        if not phone_number.startswith('+'):
            phone_number = f"+{phone_number}"

        message += (
            f"👤 <b>Name:</b> {first_name} {last_name}\n"
            f"📧 <b>Email:</b> {email}\n"
            f"📲 <b>Phone:</b> {phone_number}\n"
            f"📍 <b>Location:</b> {city}, {country}\n"
            f"🆔 <b>User ID:</b> {user_id}\n"  # Add User ID here
        )
        if company_name:
            message += f"🏢 <b>Company Name:</b> {company_name}\n"
        message += "------------------------------\n"

    # Add navigation buttons for pagination
    navigation_buttons = []
    if page > 1:
        navigation_buttons.append("Previous")
    if page * EMPLOYERS_PER_PAGE < total_employers:
        navigation_buttons.append("Next")
    navigation_buttons.append("Back")

    await update.message.reply_text(
        message,
        reply_markup=ReplyKeyboardMarkup([navigation_buttons], resize_keyboard=True),
        parse_mode="HTML"  # Use HTML for bold formatting
    )

    return EMPLOYER_MANAGEMENT


async def view_user_reports(update, context) -> int:
    """
    Allows the admin to search for a user by username, user ID, or phone number to initiate or review a chat.
    """
    try:
        await update.message.reply_text(
            "🔍 Please enter the Username, User ID, or Phone Number to search for a user:",
            reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
        )
        return SEARCH_USER_ADMIN

    except Exception as e:
        logger.error(f"Error initiating user search: {e}")
        await update.message.reply_text("An error occurred. Please try again later.")
        return VIEW_USER_REPORTS

async def handle_search_user(update, context) -> int:
    """
    Searches for users that have active chat sessions with the admin by user ID, username, or phone number.
    """
    query = update.message.text.strip()

    if query.lower() == "🔙 back":
        return await back_to_reports(update, context)

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Perform the search in the users table, ensuring they have active chats in employer_admin_chats
        cursor.execute("""
            SELECT DISTINCT u.user_id, u.first_name, u.last_name, u.phone_number
            FROM users u
            INNER JOIN employer_admin_chats eac ON u.user_id = eac.employer_id
            WHERE eac.admin_id = %s
              AND (
                  CAST(u.user_id AS TEXT) = %s
                  OR u.username ILIKE %s
                  OR u.phone_number ILIKE %s
              )
        """, (896853541, query, f"%{query}%", f"%{query}%"))
        results = cursor.fetchall()

        if not results:
            await update.message.reply_text(
                "❌ No users found matching your search query.",
                reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
            )
            return SEARCH_USER_ADMIN

        # Display results with inline buttons for selection
        keyboard = [
            [
                InlineKeyboardButton(
                    f"{first_name} {last_name} ({phone_number})",
                    callback_data=f"select_user_{user_id}"
                )
            ]
            for user_id, first_name, last_name, phone_number in results
        ]


        await update.message.reply_text(
            "🔍 Search Results:\nSelect a user to chat with:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return SELECT_USER

    except Exception as e:
        logger.error(f"Error searching for user: {e}")
        await update.message.reply_text("⚠️ An error occurred. Please try again later.")
        return SEARCH_USER_ADMIN

    finally:
        if conn:
            cursor.close()
            conn.close()

async def handle_select_user(update: Update, context: CallbackContext) -> int:
    """
    Fetches the chat history of the selected user and displays each message separately with sender-specific icons.
    """
    query = update.callback_query
    user_id = query.data.split("_")[-1]

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch chat history
        cursor.execute("""
            SELECT sender, message, timestamp
            FROM employer_admin_chats
            WHERE employer_id = %s
            ORDER BY timestamp ASC
        """, (user_id,))
        chat_history = cursor.fetchall()

        # Fetch user's details for personalized icons or display
        cursor.execute("""
            SELECT first_name, last_name, gender
            FROM users
            WHERE user_id = %s
        """, (user_id,))
        user_details = cursor.fetchone()

        if not user_details:
            await query.edit_message_text("⚠️ Unable to fetch user details. Please try again later.")
            return VIEW_USER_REPORTS

        first_name, last_name, gender = user_details
        full_name = f"{first_name} {last_name}".strip()
        user_icon = "👨🏾" if gender == "Male" else "👩🏾"

        # Display chat history
        if chat_history:
            await query.edit_message_text(
                text="📜 <b>Chat History:</b>\n",
                parse_mode="HTML"
            )
            for sender, message, timestamp in chat_history:
                formatted_time = timestamp.strftime("%Y-%m-%d %H:%M:%S")

                if sender == "Employer":
                    # User message (right-aligned with user-specific icon)
                    text = (
                        f"<b>{user_icon} {full_name}:</b>\n"
                        f"<pre>╭──────────────────╮\n"
                        f"│ {message}\n"
                        f"╰──────────────────╯</pre>\n"
                        f"<i>{formatted_time}</i>"
                    )
                else:
                    # Admin message (left-aligned with admin icon)
                    text = (
                        f"<b>🧑🏿‍💻 Admin:</b>\n"
                        f"<pre>╭──────────────────╮\n"
                        f"│ {message}\n"
                        f"╰──────────────────╯</pre>\n"
                        f"<i>{formatted_time}</i>"
                    )

                await context.bot.send_message(
                    chat_id=query.message.chat_id,
                    text=text,
                    parse_mode="HTML"
                )
        else:
            await query.edit_message_text(
                text="📜 <b>Chat History:</b>\nNo previous messages.",
                parse_mode="HTML"
            )

        # Display action buttons after the messages
        await context.bot.send_message(
            chat_id=query.message.chat_id,
            text="⚙️ Actions:",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("Reply to User", callback_data=f"reply_to_{user_id}")],

            ])
        )

        # Store user ID in context for replying
        context.user_data["current_employer_id"] = user_id
        return CHAT_WITH_USER

    except Exception as e:
        logger.error(f"Error fetching chat for user_id {user_id}: {e}")
        await query.edit_message_text("⚠️ An error occurred. Please try again later.")
        return VIEW_USER_REPORTS

    finally:
        if conn:
            cursor.close()
            conn.close()

async def admin_reply_to_user(update, context) -> int:
    """
    Sends a message from the admin to the user and updates the chat history.
    """
    if update.message:  # If the update is a message (admin typing a reply)
        admin_message = update.message.text.strip()

        # Handle "Back" button press
        if admin_message.lower() == "🔙 back":  # Match the back button text
            return await back_to_reports(update, context)

        chat_id = context.user_data.get("current_employer_id")

        if not chat_id:
            await update.message.reply_text("⚠️ No active chat session found. Please select a user to chat with.")
            return VIEW_USER_REPORTS

        try:
            conn = psycopg2.connect(
                dbname="my_project_db",
                user="postgres",
                password="1201",
                host="localhost",
                port="5432"
            )
            cursor = conn.cursor()

            # Log admin's message into the database
            cursor.execute("""
                INSERT INTO employer_admin_chats (employer_id, sender, message, timestamp)
                VALUES (%s, %s, %s, NOW())
            """, (chat_id, "Admin", admin_message))
            conn.commit()

            # Send the message to the employer
            cursor.execute("""
                SELECT contact FROM users WHERE user_id = %s
            """, (chat_id,))
            result = cursor.fetchone()

            if not result:
                await update.message.reply_text("⚠️ Could not find the employer's contact information.")
                return CHAT_WITH_USER

            employer_contact = result[0]

            await context.bot.send_message(
                chat_id=employer_contact,
                text=(
                    "📩 You have a new message from the admin.\n\n"
                    "📢 Please go to the Support menu and select 'Contact Admin' to view the message."
                ),
                parse_mode="HTML"
            )

            await update.message.reply_text("✅ Your message has been sent to the employer.")

            return CHAT_WITH_USER

        except Exception as e:
            logger.error(f"Error in admin_reply_to_user: {e}")
            await update.message.reply_text("⚠️ An error occurred. Please try again.")
            return VIEW_USER_REPORTS

        finally:
            if conn:
                cursor.close()
                conn.close()

    elif update.callback_query:  # If the update is a callback query (e.g., "Reply to User" button)
        query = update.callback_query
        user_id = query.data.split("_")[-1]
        context.user_data["current_employer_id"] = user_id  # Store the user ID for subsequent replies

        await query.edit_message_text(
            text=f"Replying to Employer ID: {user_id}. Type your message below.",
            reply_markup=InlineKeyboardMarkup([])
        )

        return CHAT_WITH_USER

    return VIEW_USER_REPORTS


async def back_to_reports(update: Update, context: CallbackContext) -> int:
    """
    Redirects the admin back to the Support & Issue Resolution submenu.
    """
    return await show_support_issue_resolution_menu(update, context)


# Handler for Approve/Reject Job Posts
async def approve_reject_job_posts(update, context):
    # Logic to display job posts pending approval
    await update.message.reply_text(
        "Here are the job posts pending approval:\n1. Job A\n2. Job B\n\nPlease choose which job to approve/reject.",
        reply_markup=ReplyKeyboardMarkup([["Approve", "Reject"], ["Back to Job Post Management"]], resize_keyboard=True)
    )
    return APPROVE_REJECT_JOB_POSTS


# Handler for Edit Job Posts
import psycopg2
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import CallbackContext


FIELD_MAPPING = {
    "job_title": "Job Title",
    "job_description": "Job Description",
    "job_site": "Job Site",
    "job_type": "Job Type",
    "job_sector": "Job Sector",
    "education_qualification": "Education Qualification",
    "experience_level": "Experience Level",
    "location_country": "Location Country",
    "location_city": "Location City",
    "compensation_type": "Compensation Type",
    "salary_compensation": "Salary Compensation",
    "currency_type": "Currency Type",
    "vacancy_number": "Vacancy Number",
    "applicant_gender": "Applicant Gender",
    "job_application_deadline": "Application Deadline",
}



async def edit_job_posts(update: Update, context: CallbackContext) -> int:
    """Prompts admin to search for a job by ID or title for editing."""
    await update.message.reply_text(
        "Please enter the Job ID or part of the Job Title to search for the job post you want to edit:",
        reply_markup=ReplyKeyboardMarkup(
            [["🔙 Back"]],  # Single button with "Back"
            resize_keyboard=True,  # Resize keyboard for better user experience
            one_time_keyboard=True  # Hide the keyboard after one use
        )
    )
    return SEARCH_JOB_POSTS



async def search_job_posts(update: Update, context: CallbackContext) -> int:
    """Searches for job posts by job ID or title and displays the results."""
    query = update.message.text.strip()

    # Check if the user pressed "Back"
    if query.lower() == "🔙 back":
        return await show_post_management_menu(update, context)

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Search jobs based on query
        if query.isdigit():
            cursor.execute("""
                SELECT job_id, job_title
                FROM job_posts
                WHERE job_id = %s AND status_id IN (5, 7)
            """, (query,))
        else:
            cursor.execute("""
                SELECT job_id, job_title
                FROM job_posts
                WHERE job_title ILIKE %s AND status_id IN (5, 7)
            """, (f"%{query}%",))
        job_posts = cursor.fetchall()

        if not job_posts:
            await update.message.reply_text(
                "No job posts found. Please try again.",
                reply_markup=ReplyKeyboardMarkup(
                    [["🔙 Back"]],
                    resize_keyboard=True,
                    one_time_keyboard=True
                )
            )
            return SEARCH_JOB_POSTS

        # Display job posts as inline buttons
        keyboard = [
            [InlineKeyboardButton(f"{job_title} (ID: {job_id})", callback_data=f"edit_{job_id}")]
            for job_id, job_title in job_posts
        ]
        await update.message.reply_text(
            "Search Results:\nSelect a job post to edit:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return EDIT_SELECTED_JOB

    except Exception as e:
        logger.error(f"Error searching for job posts: {e}")
        await update.message.reply_text("An error occurred. Please try again.")
        return SEARCH_JOB_POSTS

    finally:
        if conn:
            cursor.close()
            conn.close()





async def edit_selected_job(update: Update, context: CallbackContext) -> int:
    """Displays job details and options for editing."""
    query = update.callback_query
    job_id = query.data.split("_")[1]
    context.user_data["job_id"] = job_id

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch job details
        cursor.execute("""
            SELECT job_title, job_description, job_site, job_type, job_sector,
                   education_qualification, experience_level, location_country,
                   location_city, compensation_type, salary_compensation, currency_type,
                   vacancy_number, applicant_gender, job_application_deadline
            FROM job_posts
            WHERE job_id = %s
        """, (job_id,))
        job = cursor.fetchone()

        if not job:
            await query.answer("The selected job post could not be found.", show_alert=True)
            return EDIT_JOB_POSTS

        job_details = "\n".join([
            f"📝 <b>{FIELD_MAPPING[field]}:</b> {value}" for field, value in zip(FIELD_MAPPING.keys(), job)
        ])

        await query.edit_message_text(
            text=job_details + "\nWhat would you like to edit?",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(FIELD_MAPPING[field], callback_data=f"edit_{field}_{job_id}")]
                for field in FIELD_MAPPING.keys()
            ]),
            parse_mode="HTML"
        )
        return EDIT_JOB_DETAIL

    except Exception as e:
        logger.error(f"Error fetching job details for job_id {job_id}: {e}")
        await query.answer("An error occurred. Please try again.", show_alert=True)
        return EDIT_JOB_POSTS

    finally:
        if conn:
            cursor.close()
            conn.close()


async def handle_edit_job_detail(update: Update, context: CallbackContext) -> int:
    """Handles admin's selection of a job detail to edit."""
    query = update.callback_query
    await query.answer()

    try:
        data = query.data.split("_")
        field = "_".join(data[1:-1])
        job_id = data[-1]

        context.user_data["edit_field"] = field
        context.user_data["job_id"] = job_id

        await query.edit_message_text(
            text=f"Please enter the new value for the {FIELD_MAPPING[field]}:"
        )
        return WAITING_FOR_NEW_VALUE

    except Exception as e:
        logger.error(f"Error in handle_edit_job_detail: {e}")
        await query.edit_message_text("An error occurred. Please try again.")
        return EDIT_JOB_DETAIL



async def save_new_job_detail(update: Update, context: CallbackContext) -> int:
    """Saves the new value for the selected job detail."""
    new_value = update.message.text.strip()
    field = context.user_data.get("edit_field")
    job_id = context.user_data.get("job_id")

    if not field or not job_id:
        await update.message.reply_text("An error occurred. Please try again.")
        return

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        cursor.execute(f"UPDATE job_posts SET {field} = %s WHERE job_id = %s", (new_value, job_id))
        conn.commit()

        await update.message.reply_text(f"The {FIELD_MAPPING[field]} has been successfully updated.")

    except Exception as e:
        logger.error(f"Error updating {field} for job_id {job_id}: {e}")
        await update.message.reply_text("An error occurred. Please try again.")

    finally:
        if conn:
            cursor.close()
            conn.close()

    return

async def process_new_value(update: Update, context: CallbackContext) -> int:
    """
    Processes the new value entered by the admin and updates the job post.
    """
    try:
        # Retrieve the new value, field, and job_id from the context
        new_value = update.message.text.strip()
        field = context.user_data.get("edit_field")
        job_id = context.user_data.get("job_id")

        if not field or not job_id:
            await update.message.reply_text("An error occurred. Please try again.")
            return EDIT_JOB_DETAIL

        logger.info(f"Updating field: {field} for Job ID: {job_id} with new value: {new_value}")

        # Connect to the database
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Update the job post
        cursor.execute(f"""
            UPDATE job_posts
            SET {field} = %s
            WHERE job_id = %s
        """, (new_value, job_id))
        conn.commit()

        # Notify the admin
        await update.message.reply_text(
            f"✅ The {FIELD_MAPPING[field]} has been successfully updated.",
            reply_markup=ReplyKeyboardMarkup(
                [["🔙 Back"]],
                resize_keyboard=True,
                one_time_keyboard=True
            )
        )

        return EDIT_JOB_DETAIL

    except Exception as e:
        logger.error(f"Error updating job post: {e}")
        await update.message.reply_text("An error occurred while updating the job post. Please try again.")
        return EDIT_JOB_DETAIL

    finally:
        if conn:
            cursor.close()
            conn.close()



# Handler for View Flagged Job Posts
async def view_flagged_job_posts(update, context):
    # Logic to view flagged job posts
    await update.message.reply_text(
        "Here are the flagged job posts:\n1. Job C (Flagged for inappropriate content)\n2. Job D (Flagged for spam).",
        reply_markup=ReplyKeyboardMarkup([["Back to Job Post Management"]], resize_keyboard=True)
    )
    return VIEW_FLAGGED_JOB_POSTS


from telegram import InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import CallbackContext

APPLICANTS_PER_PAGE = 10  # Number of applicants per page


async def applicant_pagination(update, context: CallbackContext):
    """Handles pagination for applicant management."""
    if update.callback_query:
        message_data = update.callback_query.data
    elif update.message:
        message_data = update.message.text
    else:
        await update.message.reply_text("Invalid input. Please use the navigation buttons.")
        return

    # Retrieve the current page number from context
    current_page = context.user_data.get('current_page', 1)

    # Adjust page number based on the user's input
    if message_data == 'Next':
        current_page += 1
    elif message_data == 'Previous':
        current_page -= 1
    elif message_data == 'Back':
        await update.message.reply_text("Returning to the main menu...")
        return await show_admin_menu(update, context)
    else:
        await update.message.reply_text("Invalid choice, please use the navigation buttons.")
        return

    # Fetch applicants for the current page
    applicants, total_applicants = await fetch_applicants_for_page(current_page)

    if not applicants:
        await update.message.reply_text("No more applicants to display.")
        return

    # Save the updated current page in user_data
    context.user_data['current_page'] = current_page

    # Generate the message with applicant details
    message = f"Registered Applicants (Page {current_page}/{-(-total_applicants // APPLICANTS_PER_PAGE)}):\n\n"
    for applicant in applicants:
        first_name = applicant['first_name']
        last_name = applicant['last_name']
        email = applicant['email']
        phone_number = applicant['phone_number']
        city = applicant['city']
        country = applicant['country']
        user_id = applicant['user_id']  # Access the user_id

        # Ensure the phone number has a "+" prefix
        if not phone_number.startswith('+'):
            phone_number = f"+{phone_number}"

        message += (
            f"👤 <b>Name:</b> {first_name} {last_name}\n"
            f"📧 <b>Email:</b> {email}\n"
            f"📲 <b>Phone:</b> {phone_number}\n"
            f"📍 <b>Location:</b> {city}, {country}\n"
            f"🆔 <b>User ID:</b> {user_id}\n"  # Add the user_id here
            "------------------------------\n"
        )

    # Add navigation buttons
    navigation_buttons = []
    if current_page > 1:
        navigation_buttons.append("Previous")
    if current_page * APPLICANTS_PER_PAGE < total_applicants:
        navigation_buttons.append("Next")
    navigation_buttons.append("🔙 Back")

    if update.callback_query:
        await update.callback_query.answer()
        await update.callback_query.message.edit_text(
            message,
            reply_markup=ReplyKeyboardMarkup([navigation_buttons], resize_keyboard=True),
            parse_mode="HTML"
        )
    elif update.message:
        await update.message.reply_text(
            message,
            reply_markup=ReplyKeyboardMarkup([navigation_buttons], resize_keyboard=True),
            parse_mode="HTML"
        )


async def fetch_applicants_for_page(page: int):
    offset = (page - 1) * APPLICANTS_PER_PAGE
    try:
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )

        # Query to fetch total number of applicants
        total_applicants = await conn.fetchval("SELECT COUNT(*) FROM users WHERE user_type = 'Applicant'")

        # Query to fetch applicant details
        applicants = await conn.fetch("""
            SELECT 
                user_id, first_name, last_name, email, phone_number, city, country, dob
            FROM users
            WHERE user_type = 'Applicant'
            ORDER BY user_id
            LIMIT $1 OFFSET $2
        """, APPLICANTS_PER_PAGE, offset)

        return applicants, total_applicants

    except Exception as e:
        print(f"Database error: {e}")
        return [], 0

    finally:
        if conn:
            await conn.close()




async def manage_job_seekers(update: Update, context: CallbackContext) -> int:
    """
    Lists all registered job seekers (applicants) in sections with pagination.
    """
    page = context.user_data.get("job_seeker_page", 1)  # Default to the first page

    # Connect to the database
    try:
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )

        # Fetch total number of job seekers
        total_applicants = await conn.fetchval("SELECT COUNT(*) FROM users WHERE user_type = 'Applicant'")

        # Calculate pagination
        offset = (page - 1) * APPLICANTS_PER_PAGE  # Number of items per page

        # Fetch job seeker details for the current page
        applicants = await conn.fetch("""
            SELECT 
                user_id, first_name, last_name, email, phone_number, city, country
            FROM users
            WHERE user_type = 'Applicant'
            ORDER BY user_id
            LIMIT $1 OFFSET $2
        """, APPLICANTS_PER_PAGE, offset)

    except Exception as e:
        logger.error(f"Database error: {e}")
        await update.message.reply_text(
            "An error occurred while fetching the job seekers. Please try again later.",
            reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
        )
        return

    finally:
        # Ensure the database connection is closed
        if conn:
            await conn.close()

    if not applicants:
        await update.message.reply_text("No registered job seekers found.")
        return

    # Construct the message with applicant details
    message = f"Registered Job Seekers (Page {page}/{-(-total_applicants // APPLICANTS_PER_PAGE)}):\n\n"
    for applicant in applicants:
        user_id, first_name, last_name, email, phone_number, city, country = applicant

        # Ensure the phone number has a "+" prefix
        if not phone_number.startswith('+'):
            phone_number = f"+{phone_number}"

        message += (
            f"👤 <b>Name:</b> {first_name} {last_name}\n"
            f"📧 <b>Email:</b> {email}\n"
            f"📲 <b>Phone:</b> {phone_number}\n"
            f"📍 <b>Location:</b> {city}, {country}\n"
            f"🆔 <b>User ID:</b> {user_id}\n"  # Add User ID here
            "------------------------------\n"
        )

    # Add navigation buttons for pagination
    navigation_buttons = []
    if page > 1:
        navigation_buttons.append("Previous")
    if page * APPLICANTS_PER_PAGE < total_applicants:
        navigation_buttons.append("Next")
    navigation_buttons.append("🔙 Back")

    # Send the message with pagination buttons
    await update.message.reply_text(
        message,
        reply_markup=ReplyKeyboardMarkup([navigation_buttons], resize_keyboard=True),
        parse_mode="HTML"  # Use HTML for formatting
    )

    # Save the current page to user_data for tracking
    context.user_data['job_seeker_page'] = page

    return MANAGE_JOB_SEEKERS


# Handler for banning and unbanning users

from telegram import ReplyKeyboardMarkup

async def search_users(update, context):
    """
    Prompts the admin to enter a user ID or phone number to search for a user.
    """
    await update.message.reply_text(
        "Please enter the user ID or phone number of the user you want to manage (e.g., 123 or +251912345678):",
        reply_markup=ReplyKeyboardMarkup(
            [["🔙 Back"]],
            resize_keyboard=True,
            one_time_keyboard=True
        )
    )
    return SEARCH_USERS



from telegram import InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup

async def search_and_manage_users(update, context):
    """
    Searches for a user by user_id or phone_number and provides options to ban/unban.
    """
    user_input = update.message.text.strip()

    try:
        # Validate input type
        is_user_id = user_input.isdigit() and int(user_input) <= 2147483647  # Max value for int32
        is_phone_number = user_input.isdigit() and not is_user_id

        if not (is_user_id or is_phone_number):
            await update.message.reply_text(
                "Invalid input. Please enter a valid user ID (integer) or phone number."
            )
            return SEARCH_USER

        # Connect to the database
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )

        # Query user by ID or phone number
        user = None
        if is_user_id:
            user = await conn.fetchrow("""
                SELECT user_id, first_name, last_name, user_type, phone_number, status, country, city
                FROM users
                WHERE user_id = $1
            """, int(user_input))
        elif is_phone_number:
            user = await conn.fetchrow("""
                SELECT user_id, first_name, last_name, user_type, phone_number, status, country, city
                FROM users
                WHERE phone_number = $1
            """, user_input)

        if not user:
            await update.message.reply_text("No user found with the provided information.")
            return SEARCH_USER

        # Ensure phone number starts with "+" if missing
        phone_number = user['phone_number']
        if not phone_number.startswith("+"):
            phone_number = f"+{phone_number}"

        # Determine the status icon
        status_icon = "🟢" if user['status'] == 'active' else "🔴"

        # Prepare user details with dynamic status icon
        user_details = (
            f"👤 <b>Name:</b> {user['first_name']} {user['last_name']}\n\n"
            f"📲 <b>Phone:</b> {phone_number}\n\n"
            f"📍 <b>Location:</b> {user['city']}, {user['country']}\n\n"
            f"🛠 <b>Type:</b> {user['user_type']}\n\n"
            f"{status_icon} <b>Status:</b> {user['status'].capitalize()}\n\n"
            f"🆔 <b>User ID:</b> {user['user_id']}\n"
        )

        # Inline "Ban/Unban" button
        action_button = InlineKeyboardButton(
            text="Ban" if user["status"] == "active" else "Unban",
            callback_data=f"{'ban' if user['status'] == 'active' else 'unban'}_{user['user_id']}"
        )

        # Display the user details with the inline "Ban/Unban" button
        await update.message.reply_text(
            user_details,
            reply_markup=InlineKeyboardMarkup([[action_button]]),
            parse_mode="HTML"
        )

        # Provide the "Back" button as a keyboard button
        await update.message.reply_text(
            "Use the button below to return to the user management menu.",
            reply_markup=ReplyKeyboardMarkup(
                [["🔙 Back"]],
                resize_keyboard=True
            )
        )

    except Exception as e:
        logger.error(f"Error occurred while searching for the user: {e}")
        await update.message.reply_text("An error occurred while searching for the user. Please try again later.")
    finally:
        if conn:
            await conn.close()

    return BAN_UNBAN_USERS




from telegram import InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup


async def handle_ban_unban_callback(update, context):
    """
    Handles the ban/unban action selected by the admin and updates the original message.
    """
    query = update.callback_query
    action, user_id = query.data.split("_")
    user_id = int(user_id)

    conn = None
    try:
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )

        # Perform the ban or unban action
        if action == "ban":
            await conn.execute("""
                UPDATE users
                SET status = 'banned'
                WHERE user_id = $1
            """, user_id)
            await query.answer("User has been banned.")

            # Fetch the user's contact and name for notification
            user = await conn.fetchrow("""
                SELECT contact, first_name, last_name
                FROM users
                WHERE user_id = $1
            """, user_id)

            if user and user['contact']:
                user_name = f"{user['first_name']} {user['last_name']}" if user['last_name'] else user['first_name']
                contact = int(user['contact'])

                try:
                    # Notify the user about the ban
                    ban_message = (
                        f"🚫 <b>Notice of Suspension</b>\n\n"
                        f"Dear {user_name},\n\n"
                        "Your access to our platform has been <b>restricted</b> due to a violation of our policies.\n\n"
                        "If you believe this action was taken in error or need further assistance, please contact our support team.\n\n"
                        "📧 <b>Support Email:</b> support@example.com\n"
                        "📞 <b>Contact:</b> +1 800 123 4567\n\n"
                        "Thank you for your understanding.\n"
                        "- The Support Team"
                    )
                    await context.bot.send_message(
                        chat_id=contact,
                        text=ban_message,
                        parse_mode="HTML"
                    )

                    # Send a follow-up message instructing the user to restart
                    await context.bot.send_message(
                        chat_id=contact,
                        text="To continue, please restart the bot.",
                        parse_mode="HTML"
                    )

                    # Simulate forced restart by removing the user's state from context
                    context.user_data.clear()
                except Exception as e:
                    logger.error(f"Failed to notify user {user_id} (contact: {contact}) about ban: {e}")

        elif action == "unban":
            await conn.execute("""
                UPDATE users
                SET status = 'active'
                WHERE user_id = $1
            """, user_id)
            await query.answer("User has been unbanned.")

            # Fetch the user's contact and name for notification
            user = await conn.fetchrow("""
                SELECT contact, first_name, last_name
                FROM users
                WHERE user_id = $1
            """, user_id)

            if user and user['contact']:
                user_name = f"{user['first_name']} {user['last_name']}" if user['last_name'] else user['first_name']
                contact = int(user['contact'])

                try:
                    # Notify the user about the unban
                    unban_message = (
                        f"✅ <b>Account Reactivated</b>\n\n"
                        f"Dear {user_name},\n\n"
                        "Your access to our platform has been <b>restored</b>. You can now use the platform as usual.\n\n"
                        "Thank you for being part of our community!\n"
                        "- The Support Team"
                    )
                    await context.bot.send_message(
                        chat_id=contact,
                        text=unban_message,
                        parse_mode="HTML"
                    )
                except Exception as e:
                    logger.error(f"Failed to notify user {user_id} (contact: {contact}) about unban: {e}")

        else:
            await query.answer("Invalid action.", show_alert=True)

        # Fetch the updated user details
        user = await conn.fetchrow("""
            SELECT user_id, first_name, last_name, user_type, phone_number, city, country, status
            FROM users
            WHERE user_id = $1
        """, user_id)

        if user:
            phone_number = user['phone_number']
            if not phone_number.startswith('+'):
                phone_number = f"+{phone_number}"

            # Determine the status icon dynamically
            status_icon = "🟢" if user['status'] == 'active' else "🔴"

            # Updated user details
            user_details = (
                f"👤 <b>Name:</b> {user['first_name']} {user['last_name']}\n\n"
                f"📲 <b>Phone:</b> {phone_number}\n\n"
                f"📍 <b>Location:</b> {user['city']}, {user['country']}\n\n"
                f"🛠 <b>Type:</b> {user['user_type']}\n\n"
                f"{status_icon} <b>Status:</b> {user['status'].capitalize()}\n\n"
                f"🆔 <b>User ID:</b> {user['user_id']}\n"
            )

            # Updated inline button
            action_button = InlineKeyboardButton(
                text="Ban" if user["status"] == "active" else "Unban",
                callback_data=f"{'ban' if user['status'] == 'active' else 'unban'}_{user['user_id']}"
            )

            # Update the original message
            await query.edit_message_text(
                text=user_details,
                reply_markup=InlineKeyboardMarkup([[action_button]]),
                parse_mode="HTML"
            )

    except Exception as e:
        logger.error(f"Error occurred while banning/unbanning user: {e}")
        await query.answer("An error occurred. Please try again later.", show_alert=True)
    finally:
        if conn:
            await conn.close()

    return BAN_UNBAN_USERS


# Handler for View Registered Users
async def view_registered_users(update, context):
    """
    Displays statistics of registered users, divided into applicants and employers.
    """
    try:
        # Connect to the database
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )

        # Fetch the count of employers and applicants
        total_employers = await conn.fetchval("SELECT COUNT(*) FROM users WHERE user_type = 'Employer'")
        total_applicants = await conn.fetchval("SELECT COUNT(*) FROM users WHERE user_type = 'Applicant'")
        total_users = total_employers + total_applicants

    except Exception as e:
        # Handle database errors
        logger.error(f"Database error: {e}")
        await update.message.reply_text(
            "An error occurred while fetching user statistics. Please try again later.",
            reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
        )
        return VIEW_REGISTERED_USERS

    finally:
        # Ensure the database connection is closed
        if conn:
            await conn.close()

    # Construct the statistics message
    message = (
        f"<b>Platform Statistics:</b>\n\n"
        f"👤 <b>Total Users:</b> {total_users}\n\n"
        f"🏢 <b>Employers:</b> {total_employers}\n\n"
        f"🎓 <b>Applicants:</b> {total_applicants}\n"
    )

    # Send the message to the user
    await update.message.reply_text(
        message,
        reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True),
        parse_mode="HTML"  # Use HTML for formatting
    )

    return VIEW_REGISTERED_USERS


# Handler for Manage Comments
async def manage_comments(update, context):
    # Logic to manage comments
    await update.message.reply_text(
        "Here are comments to moderate:\n1. Comment A\n2. Comment B\n\nSelect a comment to review.",
        reply_markup=ReplyKeyboardMarkup([["Delete Comment A", "Delete Comment B"], ["Back to Content Moderation"]], resize_keyboard=True)
    )
    return MANAGE_COMMENTS


# Handler for Flagged Content Review
async def flagged_content_review(update, context):
    # Logic to review flagged content
    await update.message.reply_text(
        "Here is the flagged content:\n1. Post A (Flagged for inappropriate content)\n2. Comment B (Flagged for spam).",
        reply_markup=ReplyKeyboardMarkup([["Delete Post A", "Delete Comment B"], ["Back to Content Moderation"]], resize_keyboard=True)
    )
    return FLAGGED_CONTENT_REVIEW

# Handler for Job Categories
async def job_categories(update: Update, context: CallbackContext) -> int:
    """Main menu for managing job categories."""
    await update.message.reply_text(
        "Manage Job Categories:\n1. Add Category\n2. Remove Category\n3. List Categories\n\nSelect an action.",
        reply_markup=ReplyKeyboardMarkup(
            [["Add Category", "Remove Category"], ["List Categories", "Back to Platform Settings"]],
            resize_keyboard=True
        )
    )
    return JOB_CATEGORIES
# Handler to list all job categories
async def list_categories(update: Update, context: CallbackContext) -> int:
    """Fetch and display all job categories."""
    try:
        # Connect to the database
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )
        # Fetch all categories
        rows = await conn.fetch("SELECT id, category_name, description, is_active FROM job_categories")
        await conn.close()

        if not rows:
            await update.message.reply_text("No job categories found.")
        else:
            # Format the list of categories
            categories_list = "\n\n".join(
                f"ID: {row['id']}\nName: {row['category_name']}\nDescription: {row['description']}\n"
                f"Active: {'Yes' if row['is_active'] else 'No'}"
                for row in rows
            )
            await update.message.reply_text(f"Job Categories:\n\n{categories_list}")

        # Return to the main menu
        return await job_categories(update, context)

    except Exception as e:
        logger.error(f"Error fetching job categories: {e}")
        await update.message.reply_text("An error occurred while fetching job categories.")
        return JOB_CATEGORIES

# Handler to add a job category
async def add_category(update: Update, context: CallbackContext) -> int:
    """Prompt the admin to add a new category."""
    await update.message.reply_text(
        "Please enter the new category details in the format:\n"
        "Category Name | Description | Active (true/false)",
        reply_markup=ReplyKeyboardMarkup([["Cancel"]], resize_keyboard=True)
    )
    return ADD_CATEGORY


async def save_category(update: Update, context: CallbackContext) -> int:
    """Save the new job category to the database."""
    try:
        # Parse input
        raw_input = update.message.text
        parts = [part.strip() for part in raw_input.split('|')]
        if len(parts) != 3:
            raise ValueError("Invalid input format. Use: Category Name | Description | Active (true/false)")

        category_name, description, is_active = parts

        # Validate 'is_active'
        if is_active.lower() not in ["true", "false"]:
            raise ValueError("The 'Active' field must be either 'true' or 'false'.")

        is_active_bool = is_active.lower() == "true"

        # Save to database
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )
        await conn.execute("""
            INSERT INTO job_categories (category_name, description, is_active)
            VALUES ($1, $2, $3)
        """, category_name, description, is_active_bool)
        await conn.close()

        await update.message.reply_text(f"Category '{category_name}' added successfully!")
        return JOB_CATEGORIES

    except ValueError as e:
        await update.message.reply_text(f"Input error: {e}")
        return ADD_CATEGORY
    except Exception as e:
        logger.error(f"Error saving category: {e}")
        await update.message.reply_text("An error occurred while adding the category.")
        return JOB_CATEGORIES


# Handler to remove a job category
async def remove_category(update: Update, context: CallbackContext) -> int:
    """Prompt the admin to enter the ID of the category to remove."""
    await update.message.reply_text(
        "Please enter the ID of the category you want to remove.",
        reply_markup=ReplyKeyboardMarkup([["Cancel"]], resize_keyboard=True)
    )
    return REMOVE_CATEGORY


async def delete_category(update: Update, context: CallbackContext) -> int:
    """Delete a job category from the database."""
    try:
        # Validate input
        category_id = update.message.text.strip()
        if not category_id.isdigit():
            raise ValueError("Category ID must be a numeric value.")

        # Delete from database
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )
        result = await conn.execute("""
            DELETE FROM job_categories WHERE id = $1
        """, int(category_id))
        await conn.close()

        # Check if deletion was successful
        if result == "DELETE 0":
            await update.message.reply_text(f"No category found with ID {category_id}.")
        else:
            await update.message.reply_text(f"Category with ID {category_id} has been removed successfully!")

        return JOB_CATEGORIES

    except ValueError as e:
        await update.message.reply_text(f"Input error: {e}")
        return REMOVE_CATEGORY
    except Exception as e:
        logger.error(f"Error deleting category: {e}")
        await update.message.reply_text("An error occurred while removing the category.")
        return JOB_CATEGORIES


# Fallback handler to return to the main menu
async def cancel(update: Update, context: CallbackContext) -> int:
    """Return to the main menu."""
    await update.message.reply_text(
        "Action canceled. Returning to the main menu.",
        reply_markup=ReplyKeyboardMarkup([["Back to Platform Settings"]], resize_keyboard=True)
    )
    return


# Handler for Location Management
async def location_management(update: Update, context: CallbackContext) -> int:
    """Main menu for managing locations."""
    await update.message.reply_text(
        "Manage Locations:\n1. Add Location\n2. Remove Location\n\nSelect an action.",
        reply_markup=ReplyKeyboardMarkup(
            [["Add Location", "Remove Location"], ["Back to Platform Settings"]], resize_keyboard=True
        )
    )
    return LOCATION_MANAGEMENT

# Handler for Location Management
async def location_management(update: Update, context: CallbackContext) -> int:
    """Main menu for managing locations."""
    await update.message.reply_text(
        "Manage Locations:\n1. Add Location\n2. Remove Location\n3. List Locations\n\nSelect an action.",
        reply_markup=ReplyKeyboardMarkup(
            [["Add Location", "Remove Location"], ["List Locations", "Back to Platform Settings"]],
            resize_keyboard=True
        )
    )
    return LOCATION_MANAGEMENT


# Handler to list all locations
async def list_locations(update: Update, context: CallbackContext) -> int:
    """Fetch and display all locations."""
    try:
        # Connect to the database
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )
        # Fetch all locations
        rows = await conn.fetch("SELECT id, city_name, country_id FROM locations")
        await conn.close()

        if not rows:
            await update.message.reply_text("No locations found.")
        else:
            # Format the list of locations
            locations_list = "\n\n".join(
                f"ID: {row['id']}\nCity: {row['city_name']}\nCountry ID: {row['country_id'] or 'N/A'}"
                for row in rows
            )
            await update.message.reply_text(f"Locations:\n\n{locations_list}")

        # Return to the main menu
        return await location_management(update, context)

    except Exception as e:
        logger.error(f"Error fetching locations: {e}")
        await update.message.reply_text("An error occurred while fetching locations.")
        return LOCATION_MANAGEMENT


# Handler to add a new location
async def add_location(update: Update, context: CallbackContext) -> int:
    """Prompt the admin to add a new location."""
    await update.message.reply_text(
        "Please enter the new location details in the format:\n"
        "City Name | Country ID (optional)",
        reply_markup=ReplyKeyboardMarkup([["Cancel"]], resize_keyboard=True)
    )
    return ADD_LOCATION


async def save_location(update: Update, context: CallbackContext) -> int:
    """Save the new location to the database."""
    try:
        # Parse input
        raw_input = update.message.text
        parts = [part.strip() for part in raw_input.split('|')]
        if len(parts) < 1 or len(parts) > 2:
            raise ValueError("Invalid input format. Use: City Name | Country ID (optional)")

        city_name = parts[0]
        country_id = parts[1] if len(parts) == 2 else None

        # Validate input
        if not city_name:
            raise ValueError("City Name cannot be empty.")

        # Save to database
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )
        await conn.execute("""
            INSERT INTO locations (city_name, country_id)
            VALUES ($1, $2)
        """, city_name, country_id)
        await conn.close()

        await update.message.reply_text(f"Location '{city_name}' added successfully!")
        return LOCATION_MANAGEMENT

    except ValueError as e:
        await update.message.reply_text(f"Input error: {e}")
        return ADD_LOCATION
    except Exception as e:
        logger.error(f"Error saving location: {e}")
        await update.message.reply_text("An error occurred while adding the location.")
        return LOCATION_MANAGEMENT


# Handler to remove a location
async def remove_location(update: Update, context: CallbackContext) -> int:
    """Prompt the admin to enter the ID of the location to remove."""
    await update.message.reply_text(
        "Please enter the ID of the location you want to remove.",
        reply_markup=ReplyKeyboardMarkup([["Cancel"]], resize_keyboard=True)
    )
    return REMOVE_LOCATION


async def delete_location(update: Update, context: CallbackContext) -> int:
    """Delete a location from the database."""
    try:
        # Validate input
        location_id = update.message.text.strip()
        if not location_id.isdigit():
            raise ValueError("Location ID must be a numeric value.")

        # Delete from database
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )
        result = await conn.execute("""
            DELETE FROM locations WHERE id = $1
        """, int(location_id))
        await conn.close()

        # Check if deletion was successful
        if result == "DELETE 0":
            await update.message.reply_text(f"No location found with ID {location_id}.")
        else:
            await update.message.reply_text(f"Location with ID {location_id} has been removed successfully!")

        return LOCATION_MANAGEMENT

    except ValueError as e:
        await update.message.reply_text(f"Input error: {e}")
        return REMOVE_LOCATION
    except Exception as e:
        logger.error(f"Error deleting location: {e}")
        await update.message.reply_text("An error occurred while removing the location.")
        return LOCATION_MANAGEMENT


# Fallback handler to return to the main menu
async def cancel(update: Update, context: CallbackContext) -> int:
    """Return to the main menu."""
    await update.message.reply_text(
        "Action canceled. Returning to the main menu.",
        reply_markup=ReplyKeyboardMarkup([["Back to Platform Settings"]], resize_keyboard=True)
    )
    return


# Handler for Notification Settings
async def notification_settings(update, context):
    # Logic to manage notification settings
    await update.message.reply_text(
        "Manage Notification Settings:\n1. Enable Job Alerts\n2. Disable Job Alerts\n\nSelect an action.",
        reply_markup=ReplyKeyboardMarkup([["Enable Job Alerts", "Disable Job Alerts"], ["Back to Platform Settings"]], resize_keyboard=True)
    )
    return NOTIFICATION_SETTINGS

from datetime import datetime, timedelta
import asyncpg
from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import CallbackContext

# Handler for User Activity Reports
async def user_activity_reports(update: Update, context: CallbackContext) -> int:
    """Main menu for user activity reports."""
    await update.message.reply_text(
        "User Activity Reports:\n1. Employer Activity\n2. Job Seeker Activity\n\nSelect a report to view.",
        reply_markup=ReplyKeyboardMarkup(
            [["Employer Activity", "Job Seeker Activity"], ["Back to Analytics & Reports"]],
            resize_keyboard=True
        )
    )
    return USER_ACTIVITY_REPORTS


async def employer_activity(update: Update, context: CallbackContext) -> int:
    """Fetch and display employer activity report."""
    try:
        # Connect to the database
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )

        # Fetch employer activity stats
        total_employers = await conn.fetchval("SELECT COUNT(*) FROM company_profiles")
        active_employers = await conn.fetchval(
            "SELECT COUNT(*) FROM company_profiles WHERE updated_at >= $1",
            datetime.now() - timedelta(days=30)
        )

        # Fetch company city count
        company_city_counts = await conn.fetch(
            """
            SELECT company_city, COUNT(*) AS count
            FROM company_profiles
            GROUP BY company_city
            ORDER BY count DESC
            """
        )

        # Fetch employer gender count
        male_employers = await conn.fetchval(
            "SELECT COUNT(*) FROM company_profiles WHERE employer_gender = 'Male'"
        )
        female_employers = await conn.fetchval(
            "SELECT COUNT(*) FROM company_profiles WHERE employer_gender = 'Female'"
        )

        # Fetch employer city count
        employer_city_counts = await conn.fetch(
            """
            SELECT employer_city, COUNT(*) AS count
            FROM company_profiles
            GROUP BY employer_city
            ORDER BY count DESC
            """
        )

        # Fetch industry count
        industry_counts = await conn.fetch(
            """
            SELECT industry, COUNT(*) AS count
            FROM company_profiles
            GROUP BY industry
            ORDER BY count DESC
            """
        )
        await conn.close()

        # Format city and industry counts
        company_city_message = "\n".join(
            f"📍 {row['company_city']}: {row['count']} companies" for row in company_city_counts
        )
        employer_city_message = "\n".join(
            f"📍 {row['employer_city']}: {row['count']} employers" for row in employer_city_counts
        )
        industry_message = "\n".join(
            f"🏢 {row['industry']}: {row['count']} companies" for row in industry_counts
        )

        # Display results
        message = (
            f"🔗 Employer Activity Report:\n"
            f"👤 Total Employers: {total_employers}\n"
            f"🟢 Active in Last 30 Days: {active_employers}\n\n"
            f"📊 Company City Breakdown:\n{company_city_message}\n\n"
            f"👥 Employer Gender Breakdown:\n"
            f"👨 Male: {male_employers} employers\n"
            f"👩 Female: {female_employers} employers\n\n"
            f"📊 Employer City Breakdown:\n{employer_city_message}\n\n"
            f"📊 Industry Breakdown:\n{industry_message}"
        )
        await update.message.reply_text(
            message,
            reply_markup=ReplyKeyboardMarkup([["Back to Reports"]], resize_keyboard=True)
        )
        return USER_ACTIVITY_REPORTS

    except Exception as e:
        logger.error(f"Error fetching employer activity: {e}")
        await update.message.reply_text("An error occurred while fetching employer activity.")
        return USER_ACTIVITY_REPORTS


async def job_seeker_activity(update: Update, context: CallbackContext) -> int:
    """Fetch and display applicant activity report, including gender and shortlisted stats."""
    try:
        # Connect to the database
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )

        # Fetch applicant stats from the applications table
        total_applications = await conn.fetchval("SELECT COUNT(*) FROM applications")
        pending_applications = await conn.fetchval("SELECT COUNT(*) FROM applications WHERE status = 'pending'")
        shortlisted_applicants = await conn.fetchval("SELECT COUNT(*) FROM applications WHERE status = 'shortlisted'")
        hired_applicants = await conn.fetchval("SELECT COUNT(*) FROM applications WHERE status = 'hired'")
        rejected_applicants = await conn.fetchval("SELECT COUNT(*) FROM applications WHERE status = 'rejected'")
       
        # Fetch gender breakdown
        gender_stats = await conn.fetch("""
            SELECT u.gender, COUNT(a.application_id) AS count
            FROM applications a
            INNER JOIN users u ON a.user_id = u.user_id
            GROUP BY u.gender
        """)

        # Parse gender stats
        gender_message = ""
        for row in gender_stats:
            gender_message += f"👤 {row['gender']}: {row['count']}\n"

        await conn.close()

        # Display results
        message = (
            f"📊 Applicant Activity Report:\n"
            f"👤 Total Applications: {total_applications}\n"
            f"🟢 Pending Applications: {pending_applications}\n"
            f"🌟 Shortlisted Applicants: {shortlisted_applicants}\n"
            f"✅ Hired Applicants: {hired_applicants}\n"
            f"🔴 Rejected Applicants: {rejected_applicants}\n"
           
            f"\n📊 Gender Breakdown:\n{gender_message}"
        )
        await update.message.reply_text(
            message,
            reply_markup=ReplyKeyboardMarkup([["Back to Reports"]], resize_keyboard=True)
        )
        return USER_ACTIVITY_REPORTS

    except Exception as e:
        logger.error(f"Error fetching applicant activity: {e}")
        await update.message.reply_text("An error occurred while fetching applicant activity.")
        return USER_ACTIVITY_REPORTS



async def job_post_insights(update: Update, context: CallbackContext) -> int:
    """Fetch and display job post insights, including location counts and gender breakdown."""
    try:
        # Connect to the database
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )

        # Fetch job post insights
        opened_jobs = await conn.fetchval("SELECT COUNT(*) FROM job_posts WHERE status_id = 6")
        closed_jobs = await conn.fetchval("SELECT COUNT(*) FROM job_posts WHERE status_id != 6")

        # Fetch location counts
        location_counts = await conn.fetch(
            """
            SELECT location_city, COUNT(*) AS count
            FROM job_posts
            GROUP BY location_city
            ORDER BY count DESC
            """
        )

        # Fetch gender counts
        male_jobs = await conn.fetchval("SELECT COUNT(*) FROM job_posts WHERE applicant_gender = 'Male'")
        female_jobs = await conn.fetchval("SELECT COUNT(*) FROM job_posts WHERE applicant_gender = 'Female'")
        both_gender_jobs = await conn.fetchval("SELECT COUNT(*) FROM job_posts WHERE applicant_gender = 'Both'")

        await conn.close()

        # Format location counts
        location_message = "\n".join(
            f"📍 {row['location_city']}: {row['count']} jobs" for row in location_counts
        )

        # Display results
        message = (
            f"🔗 Job Post Insights:\n"
            f"🟢 Opened Job Posts: {opened_jobs}\n"
            f"🔴 Closed Job Posts: {closed_jobs}\n\n"
            f"📊 Location Breakdown:\n{location_message}\n\n"
            f"👥 Gender Breakdown:\n"
            f"👨 Male: {male_jobs} jobs\n"
            f"👩 Female: {female_jobs} jobs\n"
            f"⚧ Both Genders: {both_gender_jobs} jobs"
        )
        await update.message.reply_text(
            message,
            reply_markup=ReplyKeyboardMarkup([["Back to Reports"]], resize_keyboard=True)
        )
        return JOB_POST_INSIGHTS

    except Exception as e:
        logger.error(f"Error fetching job post insights: {e}")
        await update.message.reply_text("An error occurred while fetching job post insights.")
        return JOB_POST_INSIGHTS


# Handler for Applicant Insights
async def applicant_insights(update: Update, context: CallbackContext) -> int:
    """Fetch and display applicant insights."""
    try:
        # Connect to the database
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )

        # Fetch applicant insights
        active_applicants = await conn.fetchval("SELECT COUNT(*) FROM applicant_profiles WHERE application_status = 'active'")
        rejected_applicants = await conn.fetchval("SELECT COUNT(*) FROM applicant_profiles WHERE application_status = 'rejected'")
        await conn.close()

        # Display results
        message = (
            f"🔗 Applicant Insights:\n"
            f"🟢 Active Applicants: {active_applicants}\n"
            f"🔴 Rejected Applicants: {rejected_applicants}"
        )
        await update.message.reply_text(
            message,
            reply_markup=ReplyKeyboardMarkup([["Back to Reports"]], resize_keyboard=True)
        )
        return APPLICANT_INSIGHTS

    except Exception as e:
        logger.error(f"Error fetching applicant insights: {e}")
        await update.message.reply_text("An error occurred while fetching applicant insights.")
        return APPLICANT_INSIGHTS


# Handler for Revenue Reports
async def revenue_reports(update: Update, context: CallbackContext) -> int:
    """Fetch and display revenue reports."""
    try:
        # Connect to the database
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )

        # Fetch revenue data
        monthly_revenue = await conn.fetchval(
            "SELECT COALESCE(SUM(amount), 0) FROM job_payments WHERE payment_date >= $1",
            datetime.now() - timedelta(days=30)
        )
        yearly_revenue = await conn.fetchval(
            "SELECT COALESCE(SUM(amount), 0) FROM job_payments WHERE payment_date >= $1",
            datetime.now() - timedelta(days=365)
        )
        await conn.close()

        # Display results
        message = (
            f"🔗 Revenue Reports:\n"
            f"📅 Monthly Revenue: {monthly_revenue} ETB\n"
            f"📆 Yearly Revenue: {yearly_revenue} ETB"
        )
        await update.message.reply_text(
            message,
            reply_markup=ReplyKeyboardMarkup([["Back to Reports"]], resize_keyboard=True)
        )
        return REVENUE_REPORTS

    except Exception as e:
        logger.error(f"Error fetching revenue reports: {e}")
        await update.message.reply_text("An error occurred while fetching revenue reports.")
        return REVENUE_REPORTS


async def manage_packages(update: Update, context: CallbackContext) -> int:
    """Initial handler for managing packages."""
    await update.message.reply_text(
        "Manage Packages:\n"
        "1. Add a New Package\n"
        "2. Edit an Existing Package\n"
        "3. Remove a Package\n"
        "4. List All Packages\n\nSelect an action.",
        reply_markup=ReplyKeyboardMarkup(
            [["Add Package", "Edit Package"], ["Remove Package", "List Packages"], ["Back to Monetization"]],
            resize_keyboard=True
        )
    )
    return MANAGE_PAYMENT_OPTIONS

async def add_package(update: Update, context: CallbackContext) -> int:
    """Handler for adding a new package."""
    await update.message.reply_text(
        "Adding a new package:\nPlease send the package details in the following format:\n"
        "Name | Price | Features (comma-separated) | Callback Data\n"
        "Example: 📦 Standard Package | 10000 | ✅ 15 job posts, ♻️ 10 reposts, 🌟 10 featured job visibility | buy_package:standard",
        reply_markup=ReplyKeyboardMarkup([["Cancel"]], resize_keyboard=True)
    )
    return ADD_PACKAGE

async def save_package_details(update: Update, context: CallbackContext) -> int:
    """Save the package details entered by the admin."""
    package_data = update.message.text.split('|')

    if len(package_data) != 4:
        await update.message.reply_text(
            "Invalid format. Please use the format: Name | Price | Features (comma-separated) | Callback Data"
        )
        return ADD_PACKAGE

    name, price, features, callback_data = map(str.strip, package_data)

    # Convert the features string into a list of strings
    features_list = [feature.strip() for feature in features.split(',')]

    try:
        price = int(price)
    except ValueError:
        await update.message.reply_text("Price must be a number.")
        return ADD_PACKAGE

    try:
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )
        # Insert the data into the database
        await conn.execute("""
            INSERT INTO packages (name, price, features, callback_data)
            VALUES ($1, $2, $3, $4)
        """, name, price, features_list, callback_data)  # Pass features_list directly
        await conn.close()

        await update.message.reply_text(f"Package '{name}' added successfully!")
    except Exception as e:
        logger.error(f"Error adding package: {e}")
        await update.message.reply_text("An error occurred while adding the package. Please try again.")

    return MANAGE_PAYMENT_OPTIONS


async def edit_package(update: Update, context: CallbackContext) -> int:
    """Handler for editing an existing package."""
    await update.message.reply_text(
        "Editing a package:\nPlease enter the package ID you want to edit.",
        reply_markup=ReplyKeyboardMarkup([["Cancel"]], resize_keyboard=True)
    )
    return EDIT_PACKAGE

async def get_package_details(update: Update, context: CallbackContext) -> int:
    """Fetch the package details for editing."""
    package_id = update.message.text.strip()
    try:
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )
        package = await conn.fetchrow("SELECT * FROM packages WHERE package_id = $1", int(package_id))
        await conn.close()

        if not package:
            await update.message.reply_text(f"No package found with ID {package_id}.")
            return EDIT_PACKAGE

        # `features` is already a list, no need to deserialize
        features_list = package['features']
        features_display = ', '.join(features_list)

        context.user_data['package_id'] = package_id
        await update.message.reply_text(
            f"Current details of package ID {package_id}:\n"
            f"Name: {package['name']}\n"
            f"Price: {package['price']}\n"
            f"Features: {features_display}\n"
            f"Callback Data: {package['callback_data']}\n\n"
            "Please send the updated details in the format:\n"
            "Name | Price | Features (comma-separated) | Callback Data",
            reply_markup=ReplyKeyboardMarkup([["Cancel"]], resize_keyboard=True)
        )
        return SAVE_PACKAGE  # Transition to SAVE_PACKAGE state

    except Exception as e:
        logger.error(f"Error fetching package: {e}")
        await update.message.reply_text("An error occurred. Please try again.")
        return EDIT_PACKAGE




async def save_edited_package(update: Update, context: CallbackContext) -> int:
    """Save the updated package details in one step."""
    package_id = context.user_data.get('package_id')
    raw_input = update.message.text

    try:
        # Step 1: Validate and parse the input
        parts = [part.strip() for part in raw_input.split('|')]
        if len(parts) != 4:
            raise ValueError("Input format incorrect. Use: Name | Price | Features (comma-separated) | Callback Data")

        name, price_str, features_str, callback_data = parts

        # Validate and clean price
        if not price_str.isdigit():
            raise ValueError("Price must be a valid numeric value.")
        price = int(price_str)

        # Validate and clean features
        features_list = [feature.strip() for feature in features_str.split(',') if feature.strip()]
        if not features_list:
            raise ValueError("Features cannot be empty. Provide a comma-separated list.")

        callback_data = callback_data.strip()

        # Step 2: Update the database
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )
        # Update the database, pass features_list as an array
        result = await conn.execute("""
            UPDATE packages
            SET name = $1, price = $2, features = $3, callback_data = $4
            WHERE package_id = $5
        """, name, price, features_list, callback_data, int(package_id))
        await conn.close()

        # Check if the update was successful
        if result == "UPDATE 0":
            raise Exception(f"No package found with ID {package_id}.")

        # Send success message
        await update.message.reply_text(f"Package ID {package_id} updated successfully!\n"
                                        f"Name: {name}\n"
                                        f"Price: {price}\n"
                                        f"Features: {', '.join(features_list)}\n"
                                        f"Callback Data: {callback_data}")
        return MANAGE_PAYMENT_OPTIONS

    except ValueError as e:
        # Handle input validation errors
        await update.message.reply_text(f"Input error: {e}\nPlease use the correct format:\n"
                                        "Name | Price | Features (comma-separated) | Callback Data")
        return EDIT_PACKAGE
    except Exception as e:
        # Handle other errors
        logger.error(f"Error saving package: {e}")
        await update.message.reply_text(f"An error occurred while saving the package: {e}")
        return EDIT_PACKAGE


async def remove_package(update: Update, context: CallbackContext) -> int:
    """Handler for removing a package."""
    await update.message.reply_text(
        "Removing a package:\nPlease enter the package ID you want to remove.",
        reply_markup=ReplyKeyboardMarkup([["Cancel"]], resize_keyboard=True)
    )
    return REMOVE_PACKAGE

async def confirm_remove_package(update: Update, context: CallbackContext) -> int:
    """Confirm and remove the package."""
    package_id = update.message.text
    try:
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )
        await conn.execute("DELETE FROM packages WHERE package_id = $1", int(package_id))
        await conn.close()

        await update.message.reply_text(f"Package ID {package_id} removed successfully!")
    except Exception as e:
        logger.error(f"Error removing package: {e}")
        await update.message.reply_text("An error occurred while removing the package. Please try again.")

    return MANAGE_PAYMENT_OPTIONS

async def list_packages(update: Update, context: CallbackContext) -> int:
    """List all packages."""
    try:
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )
        packages = await conn.fetch("SELECT * FROM packages ORDER BY package_id")
        await conn.close()

        if not packages:
            await update.message.reply_text("No packages found.")
            return MANAGE_PAYMENT_OPTIONS

        message = "Available Packages:\n\n"
        for package in packages:
            features = package['features']  # Already deserialized into a list
            message += (
                f"ID: {package['package_id']}\n"
                f"Name: {package['name']}\n"
                f"Price: {package['price']}\n"
                f"Features: {', '.join(features)}\n"  # Join list items into a string
                f"Callback Data: {package['callback_data']}\n"
                "------------------------------\n"
            )

        await update.message.reply_text(message)
    except Exception as e:
        logger.error(f"Error fetching packages: {e}")
        await update.message.reply_text("An error occurred while listing the packages. Please try again.")

    return MANAGE_PAYMENT_OPTIONS


# Handler for View Transactions
async def view_transactions(update: Update, context: CallbackContext) -> int:
    """Main menu for viewing transactions."""
    await update.message.reply_text(
        "View Transactions:\n1. Job Post Payments\n2. Package Payments\n\nSelect a report to view.",
        reply_markup=ReplyKeyboardMarkup(
            [["Job Post Payments", "Package Payments"], ["Back to Monetization"]],
            resize_keyboard=True
        )
    )
    return VIEW_TRANSACTIONS


# Function to calculate income for different time periods
async def fetch_income(conn, table, status_column, date_column, status_value):
    """Fetch income for monthly, half-year, full-year, and total income."""
    today = datetime.now()
    one_month_ago = today - timedelta(days=30)
    six_months_ago = today - timedelta(days=182)
    one_year_ago = today - timedelta(days=365)

    income_data = {}
    # Monthly Income
    income_data["monthly"] = await conn.fetchval(
        f"""
        SELECT COALESCE(SUM(amount), 0)
        FROM {table}
        WHERE {status_column} = $1 AND {date_column} >= $2
        """, status_value, one_month_ago
    )

    # Half-Year Income
    income_data["half_year"] = await conn.fetchval(
        f"""
        SELECT COALESCE(SUM(amount), 0)
        FROM {table}
        WHERE {status_column} = $1 AND {date_column} >= $2
        """, status_value, six_months_ago
    )

    # Full-Year Income
    income_data["full_year"] = await conn.fetchval(
        f"""
        SELECT COALESCE(SUM(amount), 0)
        FROM {table}
        WHERE {status_column} = $1 AND {date_column} >= $2
        """, status_value, one_year_ago
    )

    # Total Income
    income_data["total"] = await conn.fetchval(
        f"""
        SELECT COALESCE(SUM(amount), 0)
        FROM {table}
        WHERE {status_column} = $1
        """, status_value
    )

    return income_data


# Handler to show job post payment earnings
async def show_job_post_earnings(update: Update, context: CallbackContext) -> int:
    """Fetch and display earnings from job post payments."""
    try:
        # Connect to the database
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )

        # Fetch income data
        income = await fetch_income(
            conn, "job_payments", "payment_status", "payment_date", "paid"
        )
        await conn.close()

        # Prepare and send the response
        message = (
            f"💼 Job Post Payments Earnings:\n"
            f"📅 Monthly: {income['monthly']} ETB\n"
            f"📆 Half-Year: {income['half_year']} ETB\n"
            f"🗓 Full-Year: {income['full_year']} ETB\n"
            f"💰 Total: {income['total']} ETB"
        )
        await update.message.reply_text(
            message,
            reply_markup=ReplyKeyboardMarkup([["Back to Transactions"]], resize_keyboard=True)
        )
        return VIEW_TRANSACTIONS

    except Exception as e:
        logger.error(f"Error fetching job post earnings: {e}")
        await update.message.reply_text("An error occurred while fetching job post earnings.")
        return VIEW_TRANSACTIONS


# Handler to show package payment earnings
async def show_package_earnings(update: Update, context: CallbackContext) -> int:
    """Fetch and display earnings from package payments."""
    try:
        # Connect to the database
        conn = await asyncpg.connect(
            user="postgres",
            password="1201",
            database="my_project_db",
            host="localhost",
            port="5432"
        )

        # Fetch income data
        income = await fetch_income(
            conn, "premium_payments", "payment_status", "purchase_date", "Paid"
        )
        await conn.close()

        # Prepare and send the response
        message = (
            f"📦 Package Payments Earnings:\n"
            f"📅 Monthly: {income['monthly']} ETB\n"
            f"📆 Half-Year: {income['half_year']} ETB\n"
            f"🗓 Full-Year: {income['full_year']} ETB\n"
            f"💰 Total: {income['total']} ETB"
        )
        await update.message.reply_text(
            message,
            reply_markup=ReplyKeyboardMarkup([["Back to Transactions"]], resize_keyboard=True)
        )
        return VIEW_TRANSACTIONS

    except Exception as e:
        logger.error(f"Error fetching package earnings: {e}")
        await update.message.reply_text("An error occurred while fetching package earnings.")
        return VIEW_TRANSACTIONS

# Handler for Refund Management
async def refund_management(update, context):
    # Logic to manage refunds
    await update.message.reply_text(
        "Manage Refunds:\n1. Process Refund\n2. View Refund Requests\n\nSelect an action.",
        reply_markup=ReplyKeyboardMarkup([["Process Refund", "View Refund Requests"], ["Back to Monetization"]], resize_keyboard=True)
    )
    return REFUND_MANAGEMENT


async def view_applicant_reports(update, context) -> int:
    """
    Allows the admin to search for a user by username, user ID, or phone number to initiate or review a chat.
    """
    try:
        await update.message.reply_text(
            "🔍 Please enter the Username, User ID, or Phone Number to search for a user:",
            reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
        )
        return SEARCH_APPLICANT_ADMIN

    except Exception as e:
        logger.error(f"Error initiating user search: {e}")
        await update.message.reply_text("An error occurred. Please try again later.")
        return VIEW_APPLICANT_REPORTS

async def handle_search_applicant(update, context) -> int:
    """
    Searches for users that have active chat sessions with the admin by user ID, username, or phone number.
    """
    query = update.message.text.strip()

    if query.lower() == "🔙 back":
        return await back_to_reports(update, context)

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Perform the search in the users table, ensuring they have active chats in employer_admin_chats
        cursor.execute("""
            SELECT DISTINCT u.user_id, u.first_name, u.last_name, u.phone_number
            FROM users u
            INNER JOIN applicant_admin_chats aac ON u.user_id = aac.applicant_id
            WHERE aac.admin_id = %s
              AND (
                  CAST(u.user_id AS TEXT) = %s
                  OR u.username ILIKE %s
                  OR u.phone_number ILIKE %s
              )
        """, (896853541, query, f"%{query}%", f"%{query}%"))
        results = cursor.fetchall()

        if not results:
            await update.message.reply_text(
                "❌ No users found matching your search query.",
                reply_markup=ReplyKeyboardMarkup([["🔙 Back"]], resize_keyboard=True)
            )
            return SEARCH_APPLICANT_ADMIN

        # Display results with inline buttons for selection
        keyboard = [
            [
                InlineKeyboardButton(
                    f"{first_name} {last_name} ({phone_number})",
                    callback_data=f"select_user_{user_id}"
                )
            ]
            for user_id, first_name, last_name, phone_number in results
        ]


        await update.message.reply_text(
            "🔍 Search Results:\nSelect a user to chat with:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return SELECT_APPLICANT

    except Exception as e:
        logger.error(f"Error searching for user: {e}")
        await update.message.reply_text("⚠️ An error occurred. Please try again later.")
        return SEARCH_APPLICANT_ADMIN

    finally:
        if conn:
            cursor.close()
            conn.close()

async def handle_select_applicant(update: Update, context: CallbackContext) -> int:
    """
    Fetches the chat history of the selected user and displays each message separately with sender-specific icons.
    """
    query = update.callback_query
    user_id = query.data.split("_")[-1]

    try:
        conn = psycopg2.connect(
            dbname="my_project_db",
            user="postgres",
            password="1201",
            host="localhost",
            port="5432"
        )
        cursor = conn.cursor()

        # Fetch chat history
        cursor.execute("""
            SELECT sender, message, timestamp
            FROM applicant_admin_chats
            WHERE applicant_id = %s
            ORDER BY timestamp ASC
        """, (user_id,))
        chat_history = cursor.fetchall()

        # Fetch user's details for personalized icons or display
        cursor.execute("""
            SELECT first_name, last_name, gender
            FROM users
            WHERE user_id = %s
        """, (user_id,))
        user_details = cursor.fetchone()

        if not user_details:
            await query.edit_message_text("⚠️ Unable to fetch user details. Please try again later.")
            return VIEW_APPLICANT_REPORTS

        first_name, last_name, gender = user_details
        full_name = f"{first_name} {last_name}".strip()
        user_icon = "👨🏾" if gender == "Male" else "👩🏾"

        # Display chat history
        if chat_history:
            await query.edit_message_text(
                text="📜 <b>Chat History:</b>\n",
                parse_mode="HTML"
            )
            for sender, message, timestamp in chat_history:
                formatted_time = timestamp.strftime("%Y-%m-%d %H:%M:%S")

                if sender == "Applicant":
                    # User message (right-aligned with user-specific icon)
                    text = (
                        f"<b>{user_icon} {full_name}:</b>\n"
                        f"<pre>╭──────────────────╮\n"
                        f"│ {message}\n"
                        f"╰──────────────────╯</pre>\n"
                        f"<i>{formatted_time}</i>"
                    )
                else:
                    # Admin message (left-aligned with admin icon)
                    text = (
                        f"<b>🧑🏿‍💻 Admin:</b>\n"
                        f"<pre>╭──────────────────╮\n"
                        f"│ {message}\n"
                        f"╰──────────────────╯</pre>\n"
                        f"<i>{formatted_time}</i>"
                    )

                await context.bot.send_message(
                    chat_id=query.message.chat_id,
                    text=text,
                    parse_mode="HTML"
                )
        else:
            await query.edit_message_text(
                text="📜 <b>Chat History:</b>\nNo previous messages.",
                parse_mode="HTML"
            )

        # Display action buttons after the messages
        await context.bot.send_message(
            chat_id=query.message.chat_id,
            text="⚙️ Actions:",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("Reply to User", callback_data=f"reply_to_{user_id}")],

            ])
        )

        # Store user ID in context for replying
        context.user_data["current_applicant_id"] = user_id
        return CHAT_WITH_APPLICANT

    except Exception as e:
        logger.error(f"Error fetching chat for user_id {user_id}: {e}")
        await query.edit_message_text("⚠️ An error occurred. Please try again later.")
        return VIEW_APPLICANT_REPORTS

    finally:
        if conn:
            cursor.close()
            conn.close()

async def admin_reply_to_applicant(update, context) -> int:
    """
    Sends a message from the admin to the applicant and updates the chat history.
    """
    if update.message:  # If the update is a message (admin typing a reply)
        admin_message = update.message.text.strip()

        # Handle "Back" button press
        if admin_message.lower() == "🔙 back":  # Match the back button text
            return await back_to_reports(update, context)

        applicant_id = context.user_data.get("current_applicant_id")

        if not applicant_id:
            await update.message.reply_text("⚠️ No active chat session found. Please select a user to chat with.")
            return VIEW_APPLICANT_REPORTS

        try:
            conn = psycopg2.connect(
                dbname="my_project_db",
                user="postgres",
                password="1201",
                host="localhost",
                port="5432"
            )
            cursor = conn.cursor()

            # Log admin's message into the database
            cursor.execute("""
                INSERT INTO applicant_admin_chats (applicant_id, admin_id, sender, message, timestamp)
                VALUES (%s, %s, %s, %s, NOW())
            """, (applicant_id, 896853541, "Admin", admin_message))
            conn.commit()

            # Send the message to the applicant
            cursor.execute("""
                SELECT contact FROM users WHERE user_id = %s
            """, (applicant_id,))
            result = cursor.fetchone()

            if not result:
                await update.message.reply_text("⚠️ Could not find the applicant's contact information.")
                return CHAT_WITH_APPLICANT

            applicant_contact = result[0]

            await context.bot.send_message(
                chat_id=applicant_contact,
                text=(
                    "📩 You have a new message from the admin.\n\n"
                    "📢 Please go to the Messages menu and select 'Contact Admin' to view the message."
                ),
                parse_mode="HTML"
            )

            await update.message.reply_text("✅ Your message has been sent to the applicant.")

            return CHAT_WITH_APPLICANT

        except Exception as e:
            logger.error(f"Error in admin_reply_to_applicant: {e}")
            await update.message.reply_text("⚠️ An error occurred. Please try again.")
            return VIEW_APPLICANT_REPORTS

        finally:
            if conn:
                cursor.close()
                conn.close()

    elif update.callback_query:  # If the update is a callback query (e.g., "Reply to User" button)
        query = update.callback_query
        applicant_id = query.data.split("_")[-1]
        context.user_data["current_applicant_id"] = applicant_id  # Store the user ID for subsequent replies

        await query.edit_message_text(
            text=f"Replying to Applicant ID: {applicant_id}. Type your message below.",
            reply_markup=InlineKeyboardMarkup([])
        )

        return CHAT_WITH_APPLICANT

    return VIEW_APPLICANT_REPORTS



async def back_to_reports(update: Update, context: CallbackContext) -> int:
    """
    Redirects the admin back to the Support & Issue Resolution submenu.
    """
    return await show_support_issue_resolution_menu(update, context)

async def run_job_alerts():
    """Run the job alerts script in an async loop."""
    await main_loop()

# Add this handler to the main function
async def main() -> None:
    application = Application.builder().token("7812697260:AAFTOqIeuV2o4M93vSvu7e44SoOP9IeE8EA").build()

    # Define conversation handler
    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler('start', start),
            CallbackQueryHandler(handle_apply, pattern=r'^apply:\d+$'),
            # Add callback handlers for editing actions
            CallbackQueryHandler(handle_edit_message, pattern=r'^edit_message_\d+$'),
            CallbackQueryHandler(handle_edit_portfolio, pattern=r'^edit_portfolio_\d+$'),
            CallbackQueryHandler(handle_edit_attachments, pattern=r'^edit_attachments_\d+$'),
            CallbackQueryHandler(handle_saved_drafts, pattern=r'^back_to_drafts$'),
            CallbackQueryHandler(handle_upload_payment, pattern=r"^upload_payment_job:\d+$"),
            CommandHandler("search_applicants", search_applicants),
            CommandHandler("start_filtering", start_filtering),

        ],
        states={
            # States for user type selection and capturing applicant or employer information
            USER_REGISTRATION: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_user_profile_section_selection)],
            USER_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_user_type)],
            FIRST_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_first_name)],
            LAST_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_last_name)],
            GENDER: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_gender)],
            COUNTRY: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_country)],
            CITY: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_city)],
            EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_email)],
            DOB: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_dob)],
            CONTACT: [MessageHandler(filters.CONTACT, handle_contact)],

            SELECT_PREMIUM_PACKAGE: [
                CallbackQueryHandler(handle_package_purchase, pattern="^buy_package:"),  # Handles package purchase
                CallbackQueryHandler(handle_upload_payment_screenshot, pattern="^upload_payment:"),
                MessageHandler(filters.TEXT, show_premium_packages),
                MessageHandler(filters.TEXT & filters.Regex(r"🔙 Back"), handle_back_button_for_premium_packages),
                # Handles Back button
            ],

            UPLOAD_PAYMENT_SCREENSHOT: [
                MessageHandler(filters.PHOTO, handle_payment_screenshot),
                CallbackQueryHandler(handle_upload_payment, pattern="^upload_payment_job:"),
                MessageHandler(filters.TEXT & filters.Regex(r"🔙 Back"), handle_back_button_for_job_payments),

            ],

            UPLOAD_PACKAGE_PAYMENT_SCREENSHOT: [
                MessageHandler(filters.PHOTO, process_payment_screenshot),
                MessageHandler(filters.Regex(r"🔙 Back"), handle_back_button),  # Back button handler
            ],

            EMPLOYER_MENU: [
                MessageHandler(filters.Regex('^🗂️ Job Management$'), handle_employer_menu_selection),
                MessageHandler(filters.Regex('^📄 Applications$'), handle_employer_menu_selection),
                MessageHandler(filters.Regex('^🔍 Search & Filter$'), handle_employer_menu_selection),
                MessageHandler(filters.Regex('^🪪 Profile$'), handle_employer_menu_selection),
                MessageHandler(filters.Regex('^💳 Billing & Payments$'), handle_employer_menu_selection),
                MessageHandler(filters.Regex('^📢 Notifications$'), handle_employer_menu_selection),
                MessageHandler(filters.Regex('^⚙️ Performance'), handle_employer_menu_selection),
                MessageHandler(filters.Regex('^📞 Support$'), handle_employer_menu_selection),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_employer_menu_selection),

            ],

            # Job Management Submenu
            JOB_MANAGEMENT: [
                MessageHandler(filters.Regex('^📝 Post a New Job$'), handle_job_management_menu),
                MessageHandler(filters.Regex('^📂 Opened Jobs$'), handle_job_management_menu),
                MessageHandler(filters.Regex('^🕒 Pending Jobs$'), handle_job_management_menu),
                MessageHandler(filters.Regex('^🔒 Closed Jobs$'), handle_job_management_menu),
                MessageHandler(filters.Regex('^🔁 Repost Jobs$'), handle_job_management_menu),
                MessageHandler(filters.Regex('^💾 Saved Jobs$'), handle_job_management_menu),  # Added Drafted Jobs
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_job_management_menu),
                MessageHandler(filters.Regex('^View Drafts$'), view_drafted_jobs),
                CallbackQueryHandler(start_editing_job_draft, pattern='^edit_draft_job:'),
                CallbackQueryHandler(handle_post_job, pattern='^post_draft:'),  # Added handler for Post Job button
                CallbackQueryHandler(handle_delete_job_draft, pattern='^delete_draft:'),
                # Added handler for Delete Draft button
                MessageHandler(filters.Regex('^🔙 Back$'), show_employer_menu)
            ],

            EDIT_JOB_FIELD: [

                CallbackQueryHandler(cancel_edit, pattern="^cancel_edit$")],


            # Applications Submenu
            APPLICATIONS: [
                MessageHandler(filters.Regex('^🔍 View Applicants$'), handle_applications_menu),
                MessageHandler(filters.Regex('^📋 Shortlisted'), handle_applications_menu),
                MessageHandler(filters.Regex('^⚖️ Hired Applicants$'), handle_applications_menu),
                MessageHandler(filters.Regex('^📞 Contact Applicants$'), handle_applications_menu),

                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_applications_menu),
                MessageHandler(filters.Regex('^🔙 Back$'), show_employer_menu)
            ],

            # Search & Filter Submenu
            SEARCH_FILTER: [
                MessageHandler(filters.Regex('^🔍 Search Applicants$'), handle_search_filter_menu),
                MessageHandler(filters.Regex('^🔬 Filter Applicants$'), handle_search_filter_menu),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_search_filter_menu),
                MessageHandler(filters.Regex('^🔙 Back$'), show_employer_menu)
            ],

            # Profile Management Submenu
            PROFILE_MANAGEMENT: [
                MessageHandler(filters.Regex('^➕🪪 Add Profile$'), handle_profile_management_menu),
                MessageHandler(filters.Regex('^🏢 Company Profile$'), handle_profile_management_menu),
                MessageHandler(filters.Regex('^➕📞 Add Contact'), handle_profile_management_menu),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_profile_management_menu),
                MessageHandler(filters.Regex('^🔙 Back$'), show_employer_menu)
            ],

            PROFILE_EDIT_MENU: [
                # Existing handlers
                MessageHandler(filters.Regex('^🏢 Company Name$'), ask_for_company_name),
                MessageHandler(filters.Regex('^📅 Founding Year$'), ask_for_company_founding_year),
                MessageHandler(filters.Regex('^📝 Description$'), ask_for_company_description),
                MessageHandler(filters.Regex('^🏭 Industry$'), ask_for_industry),
                MessageHandler(filters.Regex('^👔 CEO Name$'), ask_for_company_ceo_name),
                MessageHandler(filters.Regex('^👥 Company Size$'), ask_for_company_size),
                MessageHandler(filters.Regex('^🎁 Benefits$'), ask_for_employee_benefits),
                MessageHandler(filters.Regex('^📋 Open Positions$'), ask_for_open_positions),
                MessageHandler(filters.Regex('^💵 Salary Range$'), ask_for_average_salary_range),
                MessageHandler(filters.Regex('^🖼️ Company Logo$'), ask_for_company_logo),
                MessageHandler(filters.Regex('^📜 Certifications$'), ask_for_company_certifications),
                MessageHandler(filters.Regex('^👤 Employer Name$'), ask_for_employer_name),
                MessageHandler(filters.Regex('^💼 Employer Position$'), ask_for_employer_position),
                MessageHandler(filters.Regex('^📞 Employer Contact$'), ask_for_employer_contact),
                MessageHandler(filters.TEXT, edit_employer_profile),
                # Back button handler
                MessageHandler(filters.Regex('^🔙 Back$'), edit_employer_profile)
            ],

            COMPANY_NAME: [MessageHandler(filters.TEXT, save_company_name)],
            INDUSTRY: [MessageHandler(filters.TEXT, save_industry)],
            COMPANY_SIZE: [MessageHandler(filters.TEXT, save_company_size)],
            COMPANY_LOGO: [MessageHandler(filters.PHOTO, save_company_logo),
                           MessageHandler(filters.TEXT & filters.Regex(r'(?i)^🔙 back$'), show_employer_profile_edit_menu)],
            COMPANY_DESCRIPTION: [MessageHandler(filters.TEXT, save_company_description)],
            COMPANY_FOUNDING_YEAR: [MessageHandler(filters.TEXT, save_company_founding_year)],
            COMPANY_CEO_NAME: [MessageHandler(filters.TEXT, save_company_ceo_name)],
            OPEN_POSITIONS: [MessageHandler(filters.TEXT, save_open_positions)],
            COMPANY_CERTIFICATIONS: [MessageHandler(filters.PHOTO | filters.Document.ALL, save_company_certifications),
                                     MessageHandler(filters.TEXT & filters.Regex(r'(?i)^🔙 back$'), show_employer_profile_edit_menu)],

            EMPLOYER_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_employer_name)],
            EMPLOYER_POSITION: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_employer_position)],
            EMPLOYER_CONTACT: [MessageHandler(filters.CONTACT, save_employer_contact),
                               MessageHandler(filters.TEXT & filters.Regex(r'(?i)^🔙 back$'), show_employer_profile_edit_menu)],
            EMPLOYEE_BENEFITS: [MessageHandler(filters.TEXT, save_employee_benefits)],
            AVERAGE_SALARY_RANGE: [MessageHandler(filters.TEXT, save_average_salary_range)],
            APPLY_CONVERSATION: [MessageHandler(filters.TEXT, forward_message)],

            CONFIRM_APPLICATION: [
                MessageHandler(filters.Regex('^(Yes|No)$'), handle_confirmation),
            ],

            COLLECT_INFO: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, collect_application_message),
                MessageHandler(filters.TEXT & filters.Regex(r'(?i)^🔙 back$'), start)
            ],
            SUBMISSION_MENU: [CallbackQueryHandler(handle_submission_menu)],

            SUBMIT_APPLICATION: [
                MessageHandler(filters.Document.ALL, submit_application),
                MessageHandler(filters.TEXT & filters.Regex(r'(?i)^🔙 back$'), collect_application_message)
            ],
            COLLECT_APPLICATION_MESSAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, collect_application_message)],

            COLLECT_PORTFOLIO_LINKS: [MessageHandler(filters.TEXT & ~filters.COMMAND, collect_portfolio_links)],

            REVIEW_APPLICATION: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_review_response),
            ],

            VIEW_SHORTLISTED_STATE: [
                CallbackQueryHandler(view_shortlisted_applicants, pattern='^view_shortlisted$'),
                CallbackQueryHandler(handle_remove_shortlist, pattern='^remove_shortlist_'),
                CallbackQueryHandler(back_to_shortlisted, pattern='^back_to_shortlisted_'),
                CallbackQueryHandler(handle_shortlisted_application_message, pattern='^view_shortlisted_app_message_'),
                CallbackQueryHandler(handle_view_shortlisted_profile, pattern='^view_shortlisted_profile_'),
                CallbackQueryHandler(handle_hire_shortlisted_applicant, pattern='^hire_shortlisted_'),
                CallbackQueryHandler(handle_finalize_job_action, pattern='^close_job_'),
                # New handler for Close Job button
                CallbackQueryHandler(handle_keep_job_active, pattern='^keep_open_'),
                MessageHandler(filters.Regex("^🔙 Back$"), handle_back_to_menu),
                MessageHandler(filters.TEXT & ~filters.COMMAND, validate_shortlisted_input),  # Add this handler
            ],
            CONTACT_APPLICANTS_STATE: [MessageHandler(filters.TEXT, contact_applicants),
                                       MessageHandler(filters.Regex("^🔙 Back to Menu$"), handle_back_to_menu),
                                       ],

            APPLICATION_COMPLETE: [MessageHandler(filters.TEXT & ~filters.COMMAND, application_complete)],
            UPLOAD_CV: [MessageHandler(filters.Document.ALL, handle_resume_app_upload)],  # Corrected function name

            VIEW_APPLICANTS_STATE: [
                CallbackQueryHandler(view_applicants, pattern='^view_applicants$'),
                CallbackQueryHandler(handle_application_message, pattern='^view_app_message_'),
                CallbackQueryHandler(handle_view_app_profile, pattern='^view_app_profile_'),
                CallbackQueryHandler(start_chat, pattern="^start_chat_"),
                CallbackQueryHandler(shortlist_applicant, pattern="^shortlist_"),
                CallbackQueryHandler(handle_hire_applicant, pattern="^hire_"),  # New handler for Hire button
                CallbackQueryHandler(handle_reject_applicant, pattern="^reject_"),  # New handler for Reject button
                CallbackQueryHandler(back_to_applicants, pattern="^back_to_applicants_"),
                CallbackQueryHandler(handle_close_job, pattern="^close_job_"),  # Handler for Close Job button
                CallbackQueryHandler(handle_keep_job_open, pattern="^keep_open_"),  # Handler for Keep Job Open button
                MessageHandler(filters.Regex("^🔙 Back$"), handle_back_to_menu),
                MessageHandler(filters.TEXT & ~filters.COMMAND, validate_user_input),
                # Catch all unrecognized text input
            ],


            PROFILE_CONTACT_MENU: [
                MessageHandler(filters.Regex('^📧 Email$'), ask_for_company_email),
                MessageHandler(filters.Regex('^📞 Phone$'), ask_for_company_phone),
                MessageHandler(filters.Regex('^🏠 Address$'), ask_for_company_address),
                MessageHandler(filters.Regex('^🌐 Website$'), ask_for_company_website),
                MessageHandler(filters.Regex('^🌍 Country$'), ask_for_company_country),
                MessageHandler(filters.Regex('^🏙️ City$'), ask_for_company_city),
                MessageHandler(filters.TEXT, add_company_contact_information),
                MessageHandler(filters.Regex('^🔙 Back$'), show_profile_management_menu),
            ],
            COMPANY_EMAIL: [MessageHandler(filters.TEXT, save_company_email)],
            COMPANY_PHONE: [MessageHandler(filters.TEXT, save_company_phone)],
            COMPANY_ADDRESS: [MessageHandler(filters.TEXT, save_company_address)],
            COMPANY_WEBSITE: [MessageHandler(filters.TEXT, save_company_website)],
            COMPANY_COUNTRY: [MessageHandler(filters.TEXT, save_company_country)],
            COMPANY_CITY: [MessageHandler(filters.TEXT, save_company_city)],
            SEARCH_APPLICANTS_STATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_search_keywords),
                                      MessageHandler(filters.Regex(r"🔙 Back"), handle_back_to_search_filter),],
            VIEW_PROFILE_STATE: [
                CallbackQueryHandler(handle_global_applicant_profile, pattern="^view_profile_global_\\d+$"),
                CallbackQueryHandler(handle_back_to_applicants, pattern="^back_to_applicants$")
            ],
            FILTER_APPLICATIONS_STATE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, select_filter),

            ],

            FILTER_CRITERIA_STATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, apply_filter)],

            BACK_TO_START_STATE: [
                MessageHandler(filters.Regex("^Back$"), back_to_start)
            ],

            MANAGE_JOB_PAYMENTS: [
                CallbackQueryHandler(handle_make_payment, pattern="make_payment:"),
                MessageHandler(filters.TEXT & filters.Regex(r"🔙 Back"), handle_back_button_for_job_payments),
                MessageHandler(filters.TEXT, handle_manage_job_payments),
                CallbackQueryHandler(handle_show_more_unpaid_jobs, pattern="^show_more_unpaid_jobs$"),

            ],
            VIEW_PAYMENT_HISTORY: [
                MessageHandler(filters.TEXT, handle_view_payment_history),  # Handle Back button
                CallbackQueryHandler(handle_show_more_payment_history, pattern="^show_more_payment_history$"),
                # Handle Show More
            ],

            PAYMENT_STAT_BACK: [
                MessageHandler(filters.Regex(r"🔙 Back"), handle_back_from_payment_stat),  # Back button handler
                MessageHandler(filters.TEXT, handle_payment_stat),
            ],

            VIEW_PROFILE: [
                MessageHandler(filters.Regex('^🔙 Back$'), show_profile_management_menu),
                MessageHandler(filters.TEXT, show_employer_profile),
                MessageHandler(filters.Regex('^✅ Get Verified$'), show_employer_profile)
            ],

            JOB_APPLICATION_ALERTS_MENU: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, handle_alert_selection)
        ],

            POST_EXPIRY_ALERTS_MENU: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_expiry_alert_selection)
            ],

            # Billing & Payments Submenu
            BILLING_PAYMENTS: [
                MessageHandler(filters.Regex('^💳 Make Payments$'), handle_billing_payments_menu),
                MessageHandler(filters.Regex('^📜 Payment History$'), handle_billing_payments_menu),
                MessageHandler(filters.Regex('^⭐ Upgrade to Premium$'), handle_billing_payments_menu),
                MessageHandler(filters.Regex('^📈 Payment Stat$'), handle_billing_payments_menu),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_billing_payments_menu),
                MessageHandler(filters.TEXT, handle_billing_payments_menu),
                MessageHandler(filters.Regex('^🔙 Back$'), show_employer_menu)
            ],

            # Notifications Submenu
            NOTIFICATIONS: [
                MessageHandler(filters.Regex('^📢 Application Alerts$'), handle_notifications_menu),
                MessageHandler(filters.Regex('^⏳ Post Expiry Alerts$'), handle_notifications_menu),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_notifications_menu),
                MessageHandler(filters.Regex('^🔙 Back$'), show_employer_menu)
            ],



    # Main Menu and Submenu Handlers
    ADMIN_MENU: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_admin_main_menu_choice)],



    MANAGE_EMPLOYERS: [
        MessageHandler(filters.Regex("Manage Employers"), manage_employers),
    ],



            # Submenu for Post Management
            JOB_POST_MANAGEMENT: [
                MessageHandler(filters.Regex('^Approve/Reject Job Posts$'), approve_reject_job_posts),
                MessageHandler(filters.Regex('^Edit Job Posts$'), edit_job_posts),
                MessageHandler(filters.Regex('^View Flagged Job Posts$'), view_flagged_job_posts),
                MessageHandler(filters.Regex('^🔙 Back$'), show_admin_menu)
            ],

            # Submenu for User Management
            USER_MANAGEMENT: [
                MessageHandler(filters.Regex('^Manage Employers$'), manage_employers),
                MessageHandler(filters.Regex('^Manage Job Seekers$'), manage_job_seekers),
                MessageHandler(filters.Regex('^Ban/Unban Users$'), search_users),
                MessageHandler(filters.Regex('^View Registered Users$'), view_registered_users),
                MessageHandler(filters.Regex('^🔙 Back$'), show_admin_menu)
            ],

            # Submenu for Content Moderation
            CONTENT_MODERATION: [
                MessageHandler(filters.Regex('^Manage Comments$'), manage_comments),
                MessageHandler(filters.Regex('^Flagged Content Review$'), flagged_content_review),
                MessageHandler(filters.Regex('^🔙 Back$'), show_admin_menu)
            ],

            # Submenu for Platform Settings
            PLATFORM_SETTINGS: [
                MessageHandler(filters.Regex('^Job Categories$'), job_categories),
                MessageHandler(filters.Regex('^Location Management$'), location_management),
                MessageHandler(filters.Regex('^Notification Settings$'), notification_settings),
                MessageHandler(filters.Regex('^🔙 Back$'), show_admin_menu)
            ],
            LOCATION_MANAGEMENT: [
                MessageHandler(filters.Regex("^(Add Location)$"), add_location),
                MessageHandler(filters.Regex("^(Remove Location)$"), remove_location),
                MessageHandler(filters.Regex("^(List Locations)$"), list_locations),
                MessageHandler(filters.Regex("^(Back to Platform Settings)$"), cancel)
            ],
            ADD_LOCATION: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_location)],
            REMOVE_LOCATION: [MessageHandler(filters.TEXT & ~filters.COMMAND, delete_location)],
            JOB_CATEGORIES: [
                MessageHandler(filters.Regex("^(Add Category)$"), add_category),
                MessageHandler(filters.Regex("^(Remove Category)$"), remove_category),
                MessageHandler(filters.Regex("^(List Categories)$"), list_categories),
                MessageHandler(filters.Regex("^(Back to Platform Settings)$"), cancel)
            ],
            ADD_CATEGORY: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_category)],
            REMOVE_CATEGORY: [MessageHandler(filters.TEXT & ~filters.COMMAND, delete_category)],

            # Submenu for Analytics & Reports
            ANALYTICS_REPORTS: [
                MessageHandler(filters.Regex('^User Activity Reports$'), user_activity_reports),
                MessageHandler(filters.Regex('^Job Post Insights$'), job_post_insights),
                MessageHandler(filters.Regex('^Applicant Insights$'), applicant_insights),
                MessageHandler(filters.Regex('^Revenue Reports$'), revenue_reports),
                MessageHandler(filters.Regex('^🔙 Back$'), show_admin_menu)
            ],
            USER_ACTIVITY_REPORTS: [
                MessageHandler(filters.Regex("^(Employer Activity)$"), employer_activity),
                MessageHandler(filters.Regex("^(Job Seeker Activity)$"), job_seeker_activity),
                MessageHandler(filters.Regex("^(Back to Analytics & Reports)$"), user_activity_reports)
            ],

            # Job Post Insights State
            JOB_POST_INSIGHTS: [
                MessageHandler(filters.Regex("^(Active Job Posts)$"), job_post_insights),
                MessageHandler(filters.Regex("^(Closed Job Posts)$"), job_post_insights),
                MessageHandler(filters.Regex("^(Back to Analytics & Reports)$"), user_activity_reports)
            ],

            # Applicant Insights State
            APPLICANT_INSIGHTS: [
                MessageHandler(filters.Regex("^(Active Applicants)$"), applicant_insights),
                MessageHandler(filters.Regex("^(Rejected Applicants)$"), applicant_insights),
                MessageHandler(filters.Regex("^(Back to Analytics & Reports)$"), user_activity_reports)
            ],

            # Revenue Reports State
            REVENUE_REPORTS: [
                MessageHandler(filters.Regex("^(Monthly Revenue)$"), revenue_reports),
                MessageHandler(filters.Regex("^(Yearly Revenue)$"), revenue_reports),
                MessageHandler(filters.Regex("^(Back to Analytics & Reports)$"), user_activity_reports)
            ],
            # Submenu for Monetization
            MONETIZATION: [
                MessageHandler(filters.Regex('^Manage Payment Options$'), manage_packages),
                MessageHandler(filters.Regex('^View Transactions$'), view_transactions),
                MessageHandler(filters.Regex('^Refund Management$'), refund_management),
                MessageHandler(filters.Regex('^🔙 Back$'), show_admin_menu)
            ],
            VIEW_TRANSACTIONS: [
                MessageHandler(filters.Regex("^(Job Post Payments)$"), show_job_post_earnings),
                MessageHandler(filters.Regex("^(Package Payments)$"), show_package_earnings),
                MessageHandler(filters.Regex("^(Back to Monetization)$"), cancel),
            ],

            # Submenu for Support & Issue Resolution
            SUPPORT_ISSUE_RESOLUTION: [
                MessageHandler(filters.Regex('^📨 Contact Employers$'), view_user_reports),
                MessageHandler(filters.Regex('^📨 Contact Applicants'), view_applicant_reports),
                MessageHandler(filters.Regex('^🔙 Back$'), show_admin_menu)
            ],

            # Submenu for Employer Management
            EMPLOYER_MANAGEMENT: [
                MessageHandler(filters.Regex('^Manage Employers$'), manage_employers),
                MessageHandler(filters.Regex('^Previous$'), employer_pagination),
                MessageHandler(filters.Regex('^Next$'), employer_pagination),
                MessageHandler(filters.Regex('^Back$'), show_user_management_menu)
            ],

            MANAGE_JOB_SEEKERS: [
                MessageHandler(filters.Regex('^Manage Job Seekers$'), manage_job_seekers),
                MessageHandler(filters.Regex('^Previous$'), applicant_pagination),
                MessageHandler(filters.Regex('^Next$'), applicant_pagination),
                MessageHandler(filters.Regex('^🔙 Back$'), show_user_management_menu)
            ],

            VIEW_REGISTERED_USERS: [
                MessageHandler(filters.Regex('^🔙 Back$'), show_user_management_menu),
            ],
            SEARCH_USERS: [MessageHandler(filters.TEXT & ~filters.COMMAND, search_and_manage_users)],
            BAN_UNBAN_USERS: [
                CallbackQueryHandler(handle_ban_unban_callback, pattern="^(ban|unban)_"),
                MessageHandler(filters.Regex('^🔙 Back$'), show_user_management_menu),
            ],
            SEARCH_JOB_POSTS: [MessageHandler(filters.TEXT & ~filters.COMMAND, search_job_posts),
                               MessageHandler(filters.Regex('^🔙 Back$'), show_post_management_menu),],
            EDIT_SELECTED_JOB: [CallbackQueryHandler(edit_selected_job, pattern=r"^edit_\d+$"),
                                MessageHandler(filters.Regex('^🔙 Back$'), show_post_management_menu), ],
            EDIT_JOB_DETAIL: [MessageHandler(filters.Regex('^🔙 Back$'), show_post_management_menu),
                CallbackQueryHandler(
                    handle_edit_job_detail,
                    pattern=r"^edit_({})_\d+$".format("|".join(FIELD_MAPPING.keys()))
                )
            ],
            WAITING_FOR_NEW_VALUE: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_new_value),
                                    MessageHandler(filters.Regex('^🔙 Back$'), show_post_management_menu), ],

            SEARCH_USER_ADMIN: [MessageHandler(filters.Regex('^🔙 Back$'), back_to_reports),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_search_user)],
            SELECT_USER: [MessageHandler(filters.Regex('^🔙 Back$'), back_to_reports),
                CallbackQueryHandler(handle_select_user, pattern="^select_user_")],

            CHAT_WITH_USER: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, admin_reply_to_user),
                CallbackQueryHandler(admin_reply_to_user, pattern="^reply_to_\\d+$"),

            ],
            VIEW_USER_REPORTS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, view_user_reports),
                CallbackQueryHandler(handle_search_user, pattern="^search_user$")
            ],


            SEARCH_APPLICANT_ADMIN: [MessageHandler(filters.Regex('^🔙 Back$'), back_to_reports),
                                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_search_applicant)],
            SELECT_APPLICANT: [MessageHandler(filters.Regex('^🔙 Back$'), back_to_reports),
                          CallbackQueryHandler(handle_select_applicant, pattern="^select_user_")],

            CHAT_WITH_APPLICANT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, admin_reply_to_applicant),
                CallbackQueryHandler(admin_reply_to_applicant, pattern="^reply_to_\\d+$"),

            ],
            VIEW_APPLICANT_REPORTS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, view_applicant_reports),
                CallbackQueryHandler(handle_search_applicant, pattern="^search_user$")
            ],


            MANAGE_PAYMENT_OPTIONS: [
                MessageHandler(filters.Regex('^Add Package$'), add_package),
                MessageHandler(filters.Regex('^Edit Package$'), edit_package),
                MessageHandler(filters.Regex('^Remove Package$'), remove_package),
                MessageHandler(filters.Regex('^List Packages$'), list_packages),
            ],
            ADD_PACKAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_package_details)],
            EDIT_PACKAGE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, get_package_details),
            ],
            SAVE_PACKAGE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, save_edited_package)
            ],
            REMOVE_PACKAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, confirm_remove_package)],




            # Settings Submenu
            SETTINGS: [
                MessageHandler(filters.Regex('^⚡ Opened Jobs$'), handle_settings_menu),
                MessageHandler(filters.Regex('^🔒 Closed Jobs$'), handle_settings_menu),

                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_settings_menu),
                MessageHandler(filters.Regex('^🔙 Back$'), show_employer_menu)
            ],

            # Support Submenu
            SUPPORT: [
                MessageHandler(filters.Regex('^💬 Contact Admin$'), handle_support_menu),
                MessageHandler(filters.Regex('^🛠️ Help Center$'), handle_support_menu),
                MessageHandler(filters.Regex('^❓ FAQs$'), handle_support_menu),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_support_menu),
                MessageHandler(filters.Regex('^🔙 Back$'), show_employer_menu)
            ],

            HELP_CENTER: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, help_center),
            ],

            FAQS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, faqs),
            ],

            CHAT_WITH_ADMIN: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_user_message),
                MessageHandler(filters.Regex("^🔙 Back$"), end_chat_with_admin)
            ],
            # Menu states for the applicant
            APPLICANT_MAIN_MENU: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_applicant_main_menu_choice)],
            SEARCH_JOBS: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_job_search)],

            # Submenu for Job Search
            JOB_SEARCH_MENU: [
                MessageHandler(filters.Regex('^🌍 By Location$'), handle_search_jobs_by_location),
                MessageHandler(filters.Regex('^🏭 By Industry$'), handle_search_jobs_by_industry),
                MessageHandler(filters.Regex('^🛠️ Filter by Job Type$'), handle_filter_jobs_by_type),
                MessageHandler(filters.Regex('^🆕 Recently Posted$'), handle_recently_posted_jobs),
                MessageHandler(filters.Regex('^💾 Saved Jobs$'), show_saved_jobs),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_job_search_menu_choice),
                MessageHandler(filters.Regex('^🔙 Back to Main Menu$'), show_applicant_main_menu)
            ],

            # Submenu for My Profile
            MY_PROFILE_MENU: [
                MessageHandler(filters.Regex('^🧑🏿‍🎓 View Profile$'), handle_view_profile),
                MessageHandler(filters.Regex('^➕🪪 Add Profile$'), handle_edit_applicant_profile),
                MessageHandler(filters.Regex('^📄 Upload Resume/CV$'), handle_upload_resume),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_my_profile_menu_choice),
                MessageHandler(filters.Regex('^🔙 Back to Main Menu$'), show_applicant_main_menu)
            ],

            APPLICANT_PROFILE_EDIT_MENU: [
                MessageHandler(filters.Regex('^🧑🏾‍💼 Full Name$'), ask_for_full_name),  # Ask for Full Name
                MessageHandler(filters.Regex('^💼 Job Title$'), ask_for_job_title),  # Ask for Job Title
                MessageHandler(filters.Regex('^📍 Location$'), ask_for_location),  # Ask for Location
                MessageHandler(filters.Regex('^📞 Phone Number$'), ask_for_phone_number),  # Ask for Phone Number
                MessageHandler(filters.Regex('^✉️ Email$'), ask_for_email),  # Ask for Email
                MessageHandler(filters.Regex('^📊 Experience Level$'), ask_for_overview),  # Ask for Experience Level
                MessageHandler(filters.Regex('^🛠️ Skills$'), ask_for_skills),  # Ask for Skills
                MessageHandler(filters.Regex('^⏳ Employment Type$'), ask_for_employment_type),  # Ask for Employment Type
                MessageHandler(filters.Regex('^📅 Availability$'), ask_for_availability),  # Ask for Availability
                MessageHandler(filters.Regex('^📜 Certifications$'), ask_for_certifications),  # Ask for Certifications
                MessageHandler(filters.Regex('^🎓 Degrees$'), ask_for_highest_degree),
                MessageHandler(filters.Regex('^🏫 University$'), ask_for_university),
                MessageHandler(filters.Regex('^🏛️ College$'), ask_for_college),
                MessageHandler(filters.Regex('^🎓 GPA$'), ask_for_gpa),  # Add this line for GPA handling
                MessageHandler(filters.Regex('^📅 Graduation Year$'), ask_for_graduation_year),
                MessageHandler(filters.Regex('^🌐 Languages$'), ask_for_languages),
                MessageHandler(filters.Regex('^🌍 Portfolio Link$'), ask_for_portfolio),
                MessageHandler(filters.Regex('^🖼️ Profile Picture$'), ask_for_profile_picture),
                MessageHandler(filters.TEXT, handle_edit_applicant_profile),
                MessageHandler(filters.Regex('^🔙 Back$'), handle_edit_applicant_profile)  # Back to profile edit menu
            ],

            APPLICANT_FULL_NAME: [MessageHandler(filters.TEXT, save_applicant_full_name)],
            APPLICANT_JOB_TITLE: [MessageHandler(filters.TEXT, save_applicant_job_title)],
            APPLICANT_LOCATION: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, save_applicant_location),
            ],

            APPLICANT_PHONE: [MessageHandler(filters.TEXT | filters.CONTACT, save_applicant_phone)],
            APPLICANT_EMAIL: [MessageHandler(filters.TEXT, save_applicant_email)],
            APPLICANT_OVERVIEW: [MessageHandler(filters.TEXT, save_applicant_overview)],
            APPLICANT_SKILLS: [MessageHandler(filters.TEXT, save_applicant_skills)],
            APPLICANT_EMPLOYMENT_TYPE: [MessageHandler(filters.TEXT, save_applicant_employment_type)],
            APPLICANT_AVAILABILITY: [MessageHandler(filters.TEXT, save_applicant_availability)],
            APPLICANT_WORK_EXPERIENCE: [MessageHandler(filters.TEXT, save_applicant_work_experience)],
            APPLICANT_EDUCATION: [MessageHandler(filters.TEXT, save_applicant_education)],
            APPLICANT_CERTIFICATIONS: [MessageHandler(filters.TEXT, save_applicant_certifications)],
            APPLICANT_HIGHEST_DEGREE: [MessageHandler(filters.TEXT, save_applicant_highest_degree)],
            APPLICANT_UNIVERSITY: [MessageHandler(filters.TEXT, save_applicant_university)],
            APPLICANT_COLLEGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_applicant_college)],
            APPLICANT_GPA: [MessageHandler(filters.TEXT, save_applicant_gpa)],
            APPLICANT_GRADUATION_YEAR: [MessageHandler(filters.TEXT, save_applicant_graduation_year)],
            APPLICANT_LANGUAGES: [MessageHandler(filters.TEXT, save_applicant_languages)],

            APPLICANT_RESUME: [MessageHandler(filters.Document.ALL, save_applicant_resume)],
            APPLICANT_PROFILE_PICTURE: [MessageHandler(filters.PHOTO, save_applicant_profile_picture),],
            # Handle document upload here
            ENTER_SPECIFIC_DATE: [
                MessageHandler(filters.Text, handle_specific_date_input)],
            UPLOAD_RESUME: [
                MessageHandler(filters.Regex('^🔙 Back$'), show_profile_menu),
                MessageHandler(filters.Document.ALL, handle_resume_upload),  # Handles file uploads

                MessageHandler(filters.ALL, handle_invalid_input) # Handles back button
            ],

            APPLICANT_PORTFOLIO: [
                CallbackQueryHandler(handle_link_1, pattern='^link_1$'),
                CallbackQueryHandler(handle_link_2, pattern='^link_2$'),
                CallbackQueryHandler(handle_link_3, pattern='^link_3$'),
                CallbackQueryHandler(handle_link_4, pattern='^link_4$'),
                CallbackQueryHandler(view_links, pattern='^view_links$'),
                MessageHandler(filters.Regex('^🔙 Back$'), show_applicant_profile_edit_menu),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_portfolio_input)
            ],
            APPLICANT_PORTFOLIO_LINK: [  # Use this single state for all link inputs
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_portfolio_input),
                MessageHandler(filters.Regex('^🔙 Back$'), show_applicant_profile_edit_menu)
            ],

            APPLICANT_PORTFOLIO_EDIT: [
                CallbackQueryHandler(handle_edit_or_delete_link, pattern='^edit_\\d+$|delete_\\d+$'),
                MessageHandler(filters.Regex('^🔙 Back$'), show_applicant_profile_edit_menu)
            ],
            APPLICANT_PORTFOLIO_EDIT_LINK: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_edited_link),],
            SEARCH_JOBS_BY_LOCATION: [MessageHandler(filters.TEXT, process_location_input)],
            SEARCH_JOBS_BY_INDUSTRY: [MessageHandler(filters.TEXT, process_industry_input)],
            FILTER_JOBS_BY_TYPE: [MessageHandler(filters.TEXT, process_job_type_input)],
            SET_JOB_ALERTS: [MessageHandler(filters.Regex(r'^🔙 Back to Main Menu$'), show_applicant_main_menu),
                             MessageHandler(filters.TEXT & ~filters.COMMAND, handle_invalid_job_alert_input),
                             ],  # Restrict text input
            SELECT_JOB_TYPE: [CallbackQueryHandler(process_alert_criteria_selection, pattern=r'alert:.+')],
            # No per_message argument
            SET_ALERT_CRITERION_INPUT: [MessageHandler(filters.TEXT, process_alert_criteria_selection)],
            CONFIRMATION: [
                MessageHandler(filters.Regex(r'^(Continue|Cancel Application)$'), handle_confirmation_resume_cancel)

            ],
            # Submenu for Applications
            APPLICATIONS_MENU: [
                MessageHandler(filters.Regex('^📄 Active Applications$'), handle_active_applications),
                MessageHandler(filters.Regex('^⚡ Application Status$'), handle_application_status),
                MessageHandler(filters.Regex('^🗂️ History of Applied Jobs$'), handle_history_of_applied_jobs),
                MessageHandler(filters.Regex('^💾 Saved Drafts$'), handle_saved_drafts),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_applications_menu_choice),
                MessageHandler(filters.Regex('^🔙 Back to Main Menu$'), show_applicant_main_menu)
            ],



            # Submenu for Job Alerts
            JOB_ALERTS_MENU: [
                MessageHandler(filters.Regex('^📢 Set Job Alerts$'), handle_set_job_alerts),
                MessageHandler(filters.Regex('^⚙️  Manage Job Alerts$'), handle_manage_job_alerts),
                MessageHandler(filters.Regex('^🗂️ View Alert History$'), handle_view_alert_history),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_job_alerts_menu_choice),
                MessageHandler(filters.Regex('^🔙 Back to Main Menu$'), show_applicant_main_menu)
            ],

            # Submenu for Messages
            MESSAGES_MENU: [
                MessageHandler(filters.Regex('^💬 Contact Admin$'), contact_admin_applicant),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_messages_menu_choice),
                MessageHandler(filters.Regex('^🔙 Back to Main Menu$'), show_applicant_main_menu)
            ],
            CHAT_WITH_ADMIN_APPLICANT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_applicant_message)
            ],
            # Submenu for Skill Assessments
            SKILL_ASSESSMENTS_MENU: [
                MessageHandler(filters.Regex('^🤝🏾 Hired$'), handle_take_new_assessment),
                MessageHandler(filters.Regex('^📋 Shortlisted$'), handle_view_completed_assessments),
                MessageHandler(filters.Regex('^🙅🏾‍♂️ Rejected$'), handle_view_badges_certifications),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_skill_assessments_menu_choice),
                MessageHandler(filters.Regex('^🔙 Back to Main Menu$'), show_applicant_main_menu)
            ],

            # Submenu for Settings
            SETTINGS_MENU: [
                MessageHandler(filters.Regex('^🔒 Privacy Settings$'), handle_privacy_settings),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_settings_menu_choice),
                MessageHandler(filters.Regex('^🔙 Back to Main Menu$'), show_applicant_main_menu)
            ],

            # Submenu for Help & Support
            HELP_SUPPORT_MENU: [
                MessageHandler(filters.Regex('^❓ FAQs$'), handle_faqs),
                MessageHandler(filters.Regex('^📞 Contact Support$'), handle_contact_support),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_help_support_menu_choice),
                MessageHandler(filters.Regex('^🔙 Back to Main Menu$'), show_applicant_main_menu)
            ],



            # Profile editing states
            EDIT_PROFILE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_edit_profile)],
            EDIT_FIRST_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, edit_first_name)],
            EDIT_LAST_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, edit_last_name)],
            EDIT_EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, edit_email)],
            EDIT_GENDER: [MessageHandler(filters.TEXT & ~filters.COMMAND, edit_gender)],
            EDIT_USER_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND, edit_user_type)],
            EDIT_COUNTRY: [MessageHandler(filters.TEXT & ~filters.COMMAND, edit_country)],
            EDIT_CITY: [MessageHandler(filters.TEXT & ~filters.COMMAND, edit_city)],
            EDIT_DOB: [MessageHandler(filters.TEXT & ~filters.COMMAND, edit_dob)],

            # Job-related states for employers
            SELECT_SECTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_section_selection)],

            JOB_TITLE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_job_title)],

            JOB_DESCRIPTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_job_description)],

            JOB_SITE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_job_site_selection)],

            JOB_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_job_type_selection)],

            JOB_SECTOR: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_job_category_selection)],

            EDUCATION_QUALIFICATION: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_education_qualification_selection)],

            EXPERIENCE_LEVEL: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_experience_level_selection)],

            LOCATION_COUNTRY: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_country_selection)],

            LOCATION_CITY: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_city_selection)],

            COMPENSATION_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_compensation_type_selection)],


            SALARY_COMPENSATION: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_salary_compensation)],

            CURRENCY_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_currency_type_selection)],

            VACANCY_NUMBER: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_vacancy_number)],

            APPLICANT_GENDER: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_applicant_gender)],

            JOB_APPLICATION_DEADLINE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_job_application_deadline)],

            EDIT_DRAFT_SECTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_draft_section_selection)],

            EDIT_DRAFT_TITLE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_draft_title)],
            EDIT_DRAFT_DESCRIPTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_draft_description)],
            EDIT_DRAFT_SITE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_draft_site_selection)],
            EDIT_DRAFT_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_draft_type_selection)],
            EDIT_DRAFT_SECTOR: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_draft_sector_selection)],
            EDIT_DRAFT_EDUCATION: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_draft_education_selection)],
            EDIT_DRAFT_EXPERIENCE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_draft_experience_selection)],
            EDIT_DRAFT_COUNTRY: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_draft_country_selection)],
            EDIT_DRAFT_CITY: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_draft_city_selection)],
            EDIT_DRAFT_COMPENSATION_TYPE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_draft_compensation_type_selection)],
            EDIT_DRAFT_SALARY: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_draft_salary_compensation)],
            EDIT_DRAFT_CURRENCY: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_draft_currency_selection)],
            EDIT_DRAFT_VACANCY: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_draft_vacancy_number)],
            EDIT_DRAFT_GENDER: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_draft_gender)],
            EDIT_DRAFT_DEADLINE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_draft_deadline)],

            CONFIRM_JOB_POST: [
                MessageHandler(filters.Regex(r'^(Confirm|Edit|Cancel)$'), handle_confirm)
            ],

            PROFILE_CONFIRMATION: [MessageHandler(filters.TEXT, handle_profile_confirmation)],  # Edit or Confirm

            EDIT_MESSAGE_STATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_edited_message)],
            EDIT_PORTFOLIO_STATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_edited_portfolio)],
            EDIT_ATTACHMENTS_STATE: [
                MessageHandler(filters.Document.ALL, save_edited_attachments),  # Handle document uploads
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_edit_attachments)  # Handle other text inputs
            ],


            # Capture /menu in any state globally
            '*': [CommandHandler('exit', exit)]



        },
        fallbacks=[
            CommandHandler('exit', exit),  # Handles /exit command
            CommandHandler('start', start),
            MessageHandler(filters.Regex('Help'), fallback_help),  # Help-related fallback
            MessageHandler(filters.ALL, fallback_general),  # General fallback for unmatched input
        ],  # Also handle the fallback as menu command
        per_chat=True,
    )

    # Add callback query handler to manage approve/deny buttons
    application.add_handler(conv_handler)
    application.add_handler(CommandHandler('exit', exit))  # Globally handle the /menu command
    application.add_handler(CallbackQueryHandler(confirm_job_type_selection, pattern=r'alert:confirm_selection'))
    application.add_handler(CallbackQueryHandler(process_alert_criteria_selection, pattern=r'alert:.+'))
    application.add_handler(CallbackQueryHandler(process_job_type_selection, pattern=r'alert:job_type_.+'))
    application.add_handler(CallbackQueryHandler(handle_application_submission, pattern="^submit_application$"))
    application.add_handler(CallbackQueryHandler(handle_download_cv, pattern=r'^download_cv_\d+$'))
    application.add_handler(CallbackQueryHandler(handle_download_cv_profile, pattern=r'^download_cv_profile_\d+$'))
    application.add_handler(CallbackQueryHandler(handle_download_logo, pattern="^download_logo_"))
    application.add_handler(CallbackQueryHandler(handle_download_certifications, pattern="^download_certifications_"))
    # Callback handler for when the employer clicks the "Chat" button
    application.add_handler(CallbackQueryHandler(start_chat, pattern=r"^start_chat_\d+$"))
    application.add_handler(
        CallbackQueryHandler(handle_download_profile_picture, pattern=r'^download_profile_pic_\d+$'))

    application.add_handler(CallbackQueryHandler(handle_download_resume, pattern=r'^download_resume_\d+$'))

    application.add_handler(CallbackQueryHandler(handle_edit_draft, pattern=r'^edit_draft_\d+$'))
    application.add_handler(CallbackQueryHandler(handle_submit_draft, pattern=r'^submit_draft_\d+$'))
    application.add_handler(CallbackQueryHandler(handle_delete_draft, pattern=r'^delete_draft_\d+$'))
    application.add_handler(CallbackQueryHandler(handle_view_single_application, pattern='^view_applications$'))

    application.add_handler(CallbackQueryHandler(handle_request_payment, pattern=r"^request_payment:\d+$"))

    # Add the handler for view profile
    applicant_view_profile_handler = CallbackQueryHandler(applicant_begin_view_profile, pattern=r'^view_profile_\d+$')

    application.add_handler(applicant_view_profile_handler)

    application.add_handler(CallbackQueryHandler(back_to_application, pattern=r'^back_to_application_\d+$'))
    application.add_handler(CallbackQueryHandler(shortlist_begin_applicant, pattern=r'^shortlists_\d+$'))
    # Add the handler for "View Application"
    application.add_handler(CallbackQueryHandler(view_begin_application, pattern=r'^view_application_\d+$'))


    # Add the CallbackQueryHandler for the save button
    application.add_handler(CallbackQueryHandler(save_job, pattern=r'save:\d+'))  # Regex to match "save:job_id"
    application.add_handler(CallbackQueryHandler(remove_saved_job, pattern=r'remove:\d+'))  # Regex to match "remove:job_id"
    # Register handler for closing jobs
    application.add_handler(CallbackQueryHandler(close_job, pattern=r'^close_job:\d+$'))
    application.add_handler(CallbackQueryHandler(toggle_alert_status, pattern="toggle_alert_status"))

    application.add_handler(CallbackQueryHandler(start_editing_job_draft, pattern=r'^edit_draft:\d+$'))

    application.add_handler(CallbackQueryHandler(cancel_edit, pattern=r'^cancel_edit$'))


    # Add this handler to your dispatcher
    application.add_handler(CallbackQueryHandler(approve_verification, pattern="^approve_verification_"))

    # Add this handler to your dispatcher for "Yes" and "No" responses
    application.add_handler(MessageHandler(filters.TEXT & filters.Regex("^(Yes|No)$"), handle_confirmation))

    # Add this handler to your dispatcher
    application.add_handler(CallbackQueryHandler(deny_verification, pattern="^deny_verification_"))

    # Register handler
    application.add_handler(CallbackQueryHandler(handle_remove_alert, pattern=r"^alert_remove:\d+$"))

    # Repost handler - when an employer requests repost, the request goes to admin
    application.add_handler(CallbackQueryHandler(handle_repost_request, pattern=r'^repost:\d+$'))

    # Admin actions for approve/deny repost
    application.add_handler(CallbackQueryHandler(handle_admin_action, pattern=r'^(approve_repost|deny_repost):\d+$'))

    # Register the handler in the dispatcher
    application.add_handler(CallbackQueryHandler(handle_back_to_applicants, pattern="^back_to_applicants$"))

    # Register the handler
    application.add_handler(CallbackQueryHandler(handle_global_applicant_profile, pattern="^view_profile_global_"))

    application.add_handler(
        CallbackQueryHandler(narrowed_global_applicants_profile, pattern=r"^narrowed_global_applicants_profile_"))
    application.add_handler(CallbackQueryHandler(process_chat_with_applicant, pattern=r"^process_chat_with_applicant_"))
    application.add_handler(CallbackQueryHandler(narrow_chat_with_applicant, pattern=r"^narrow_chat_with_applicant_"))
    application.add_handler(CallbackQueryHandler(narrow_back_to_applicants, pattern="^back_to_filtered_applicants$"))
    application.add_handler(CallbackQueryHandler(handle_make_payment, pattern=r"^make_payment:\d+$"))
    application.add_handler(CallbackQueryHandler(handle_upload_payment, pattern=r"^upload_payment_job:\d+$"))
    application.add_handler(CallbackQueryHandler(handle_confirm_payment, pattern=r"^confirm_payment:\d+:.+$"))
    application.add_handler(CallbackQueryHandler(handle_reject_payment, pattern=r"^reject_payment:\d+:.+$"))
    application.add_handler(CallbackQueryHandler(handle_package_purchase, pattern="^buy_package:"))
    application.add_handler(CallbackQueryHandler(handle_upload_payment_screenshot, pattern="^upload_payment:"))
    application.add_handler(CallbackQueryHandler(confirm_premium_payment, pattern="^confirm_payment:"))
    application.add_handler(CallbackQueryHandler(toggle_search_visibility, pattern="toggle_search_visibility"))

    # If you have a general approval mechanism, handle it here (for non-repost approvals)
    application.add_handler(CallbackQueryHandler(handle_approval, pattern=r'^(approve|deny):'))

    application.add_handler(conv_handler)

    # Run the job alerts coroutine in parallel
    asyncio.create_task(run_job_alerts())

    await application.run_polling()


if __name__ == "__main__":
    # Start the job closer scheduler
    start_scheduler()
    import nest_asyncio
    nest_asyncio.apply()
    asyncio.run(main())